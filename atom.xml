<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ranshan丶</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://q32757468.github.io/"/>
  <updated>2019-07-26T11:10:06.121Z</updated>
  <id>https://q32757468.github.io/</id>
  
  <author>
    <name>hsl</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>webpack的基本使用</title>
    <link href="https://q32757468.github.io/2019/07/25/webpack%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>https://q32757468.github.io/2019/07/25/webpack的基本使用/</id>
    <published>2019-07-25T14:43:46.000Z</published>
    <updated>2019-07-26T11:10:06.121Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ebpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。这是webpack中文文档中的一段话。合理的使用好webpack可以使我们模块化开发以及后期的维护更加的便利，这也是webpack会是现在比较流行的打包工具之一，这篇博客就将介绍webpack的基本用法。<br><a id="more"></a></p></blockquote><h3 id="npm的使用"><a href="#npm的使用" class="headerlink" title="npm的使用"></a>npm的使用</h3><p>如果对于npm还不是特别的熟练或者是了解可以先看一看这一部分的内容，来讲一讲npm的使用，npm是一款基于node.js的包管理工具，我们项目中用到的许多包都可以通过npm来安装到项目中然后加以使用，先来说一说简单的命令：</p><ul><li><p>首先是在项目中使用<code>npm init</code>来生成一个<strong>package.json</strong>这个配置文件中保存的是项目信息，也可以通过使用<code>npm init -y</code>来快速的生成一个package,但是要注意的一点是如果当前项目所在的文件名称中包含中文，那么就不能快速创建package文件，在手动配置时需要将项目名称命名为非中文的名称，这里简单的介绍npm，就不详细解释package中的内容了。</p></li><li><p>npm安装模块的基本语法：<code>npm install &lt;Module Name&gt;</code>，其中<code>install</code>可以简写为一个<code>i</code>，如果不加模块名称则安装所有package中保存有信息的包.</p></li><li><p>可以通过<code>npm uninstall &lt;Module Name&gt;</code>来卸载已经安装模块。</p></li><li><p>可以通过<code>npm update &lt;Module Name&gt;</code>来更新已经安装模块。</p></li><li><p>可以使用<code>npm install &lt;Module Name&gt;  -g</code>来全局安装模块，没有<code>-g</code>则只是安装在项目中。</p></li><li><p>可以通过<code>npm install npm -g</code>命令升级npm来保持npm是最新版本。</p></li><li><p>切换包的仓库，默认的npm的包的仓库是在国外的，所以国内访问的话就会有较大的延迟，所以会导致下载速度较慢，这里提供一种较简单的切换包的仓库的办法：<br><code>npm i nrm -g</code>安装<strong>nrm</strong>这样一个工具，然后通过<code>nrm ls</code>可以查看所有支持的包的仓库名称，通过<code>nrm use taobao</code>则可以切换仓库地址，这里就以淘宝镜像为例。这样下载速度就可以有很明显的提升。</p></li><li><p><code>npm install &lt;Module Name&gt;  -S</code>与<code>npm install &lt;Module Name&gt;  -D</code>的区别，首先弄懂这二者之间的区别要先了解到<code>-D</code>是<code>--save</code>的缩写，而 <code>-D</code>是<code>--save-dev</code>的缩写，这二者之间的区别就在于<code>-S</code>会将包的信息保存到<strong>package</strong>的“dependencies”中，而<code>-D</code>则将保存到“devDependencies”中。而这二者之间的区别就在于如果是“dependencies”中的包是项目发布或者是运行时所依赖的包，而“devDependencies”中的包则是开发时说要用到的包。总的来说就是像jQuery这种在运行时就需要用到的包就需要通过<code>npm install &lt;Module Name&gt;  -S</code>来安装，而在开发过程中使用的工具，就像webpack这样的就是使用<code>npm install &lt;Module Name&gt;  -D</code>来安装，因为发布运行时并不依赖这些开发工具。</p></li><li><p>这里在简单介绍一下npx<br>npx 是在npm中的一种安装工具，在npm 5.2.0的版本的时候就已经开始默认安装了，那么这个工具究竟是干什么的呢。</p><ul><li><p>我们都知道可以全局安装和单独在项目中安装模块，但是只有全局安装时才可以直接使用模块提供的一些命令，如果只是在项目中安装的包则需要在<strong>package.json</strong>中配置<strong>script</strong>然后通过<code>npm run-script</code>的形式来执行命令。</p></li><li><p>那么有了npx就可以不用这么麻烦了，直接通过<code>npx &lt;command&gt;</code>就可以直接执行本地的而非全局中的命令，并且如果项目中没有安装相应的包则会先帮你安装，十分的便利。</p></li></ul></li></ul><p>这里就介绍一些我平时可能用的比较多的一些命令，其他的就不详细介绍了，开始介绍webpack的使用。</p><h3 id="webpack的安装"><a href="#webpack的安装" class="headerlink" title="webpack的安装"></a>webpack的安装</h3><ul><li><p>先在项目文件夹中初始化一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure></li><li><p>在创建两个文件夹dist和src,dist存放打包后的文件，src放源文件。</p></li><li><p>安装webpack</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm i webpack webpack-cli -D</span><br></pre></td></tr></table></figure></li></ul><p>由于这里使用的webpack只是一个项目的构建工具，所以使用<code>-D</code>的形式来安装，并且由于后面一些插件需要项目本地安装webpack，所以这里就没有使用全局安装。</p><h3 id="webpack的初步使用"><a href="#webpack的初步使用" class="headerlink" title="webpack的初步使用"></a>webpack的初步使用</h3><p>这里通过引入jQuery来简单的使用一下webpack：</p><ul><li><p>在src文件夹中创建两个文件index.html和index.js，并且引入：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"test"</span>&gt;</span>这是一段文字<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../dist/bundle.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>这里以使用jQuery为例，如果我们不使用webpack进行打包，那么我们要使用jQuery就必须在页面中还要引入jQuery，这样会造成二次加载，造成不必要的资源浪费，所以我们可以使用ES6中的引入模块的语法，在index.js中引入jQuery模块。</p><ul><li><p>先安装jQuery，由于时运行时也需要的依赖，所以通过<code>-S</code>的方式来安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm i jquery -S</span><br></pre></td></tr></table></figure></li><li><p>引入jQuery，并且进行一些操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">'jquery'</span></span><br><span class="line">$(<span class="string">'.test'</span>).html(<span class="string">'这是一段新的文字'</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>但是通过上面这些操作是会直接报错的，因为浏览器目前还不支持这样的使用语法。这也是为什么要使用webpack的原因之一，通过webpack就可以将这文件打包，并且将其中的新语法进行转换，从而使得浏览器能够运行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npx webpack ./src/index.js -o ./dist/bundle.js --mode development</span><br><span class="line">(这里也可以配置package中的script来简化操作命令)</span><br></pre></td></tr></table></figure></li></ul><p>此时原来报错的js文件就打包好了，打包好的新的名为bundle.js的文件就存放在dist文件夹中，我们需要在html中引入新的js文件</p><blockquote><p>这里的mode可以不配置，默认时producition模式，后面可以在配置文件中进行配置。</p></blockquote><ul><li>引入好打包好的js文件再次打开网页就可以发现并不会再报错了，并且可以正确的执行相关操作，这样就进行好了一次简单的打包。</li></ul><h3 id="webpac配置文件"><a href="#webpac配置文件" class="headerlink" title="webpac配置文件"></a>webpac配置文件</h3><p>webpack的相关配置都是通过配置<strong>webpack.config.js</strong>这个文件来实现的，这个文件默认没有，需要自己手动的创建，并且放在项目的根目录中。</p><p>我们可以先做一下简单的配置：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入处理路径的模块</span></span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="comment">//配置信息</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: path.resolve(__dirname, <span class="string">'src/index.js'</span>), <span class="comment">// 项目入口文件</span></span><br><span class="line">  output: &#123; <span class="comment">// 配置输出选项</span></span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>), <span class="comment">// 配置输出的路径</span></span><br><span class="line">    filename: <span class="string">'bundle.js'</span> <span class="comment">// 配置输出的文件名</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//配置模式：development、production none 三选一</span></span><br><span class="line">  mode: <span class="string">'development'</span> <span class="comment">//开发过程中使用development、发布时使用production。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过这样简单的配置我们再次打包时所用的命令就会更加的简单了，因为配置都写在了配置文件中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npx webpack</span><br></pre></td></tr></table></figure></p><p>通过配置好相关的配置文件，就可以在执行命令的时候就不用再加上相应的配置了。</p><h3 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h3><p>通过上面的例子我们会发现这样打包其实也是不够便捷的，那么我们可以通过安装插件来使我们的使用更加的便捷。</p><h4 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h4><p>这款插件的作用就是不再需要我们自己手动的去打包，使用了这款插件以后当我们保存代码以后就会进行自动打包，使我们的开发更加的便利。</p><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm i webpack-dev-server -D</span><br></pre></td></tr></table></figure><h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><p>可以通过<code>$ npx webpack-dev-server</code>来启动服务</p><h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><ul><li>首先我们可以通过配置package中的script来简化我们的命令：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,</span><br><span class="line">  &quot;dev&quot;: &quot;webpack-dev-server&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>这样设置以后我们就可以通过<code>npm run dev</code>来简化操作了。</p><ul><li>我们可以配置webpack-dev-server来更进一步的简化我们的操作，有两种方式：</li></ul><p>方式一：<br>修改<strong>package.josn</strong>中的命令来配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;dev&quot;: &quot;webpack-dev-server --hot --port 4321 --open --contentBase src&quot;</span><br></pre></td></tr></table></figure></p><p>这里解释一下这些配置都是什么含义：</p><ul><li><p><code>--hot</code> 启用热更新</p></li><li><p><code>--port 4321</code>修改端口为4321</p></li><li><p><code>--open</code> 自动打开浏览器</p></li><li><p><code>--contentBase src</code>默认打开的是src文件夹而不是项目跟路径</p></li></ul><p>方式二：<br>配置<strong>webpack.config.js</strong></p><ol><li><p>头部引入webpack包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const webpack = require(&apos;webpack&apos;);</span><br></pre></td></tr></table></figure></li><li><p>在module.exports新增配置信息：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">  hot: <span class="literal">true</span>,</span><br><span class="line">  open: <span class="literal">true</span>,</span><br><span class="line">  port: <span class="number">4321</span>,</span><br><span class="line">  contentBase: <span class="string">'src'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在 plugins 数组中新增：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  new webpack.HotModuleReplacementPlugin()</span><br><span class="line">],</span><br></pre></td></tr></table></figure></li></ol><h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><p>这样配置好后再继续使用确实是会简便很多，但是启动之后我们还是能够发现一个问题，那就是似乎启动之后的页面并没有得到我们想要的结果，那么问题处在哪里呢，其实这是因为通过<strong>webpack-dev-server</strong>启动打包的js文件并不是我们手动打包生成的那个js文件，并且原来我们手动打包生成的那个js文件也已经无效了，而通过 webpack-dev-server 打包生成的js文件是存放在内存中的，路径是在项目的根路径中，所以解决这个问题的方法有三种。</p><ol><li><p>修改网页的引用路径：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/bundle.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>修改 webpack-dev-server 配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">  publicPath: &quot;/dist/&quot;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li><li><p>使用 html-webpack-plugin 插件<br>后面详细介绍这款插件，这里就不做过多介绍。</p></li></ol><h4 id="html-webpack-plugin"><a href="#html-webpack-plugin" class="headerlink" title="html-webpack-plugin"></a>html-webpack-plugin</h4><p>前面说到了在使用 webpack-dev-server 出现的问题，也提到了这个问题也可以通过 <strong>html-webpack-plugin</strong> 这款插件来解决，那么来看看如何使用这款插件：</p><h5 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm i html-webpack-plugin -D</span><br></pre></td></tr></table></figure><h5 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h5><ul><li><p>导入模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const htmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);</span><br></pre></td></tr></table></figure></li><li><p>添加到 plugins 数组中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  new htmlWebpackPlugin(&#123;</span><br><span class="line">    template: path.resolve(__dirname, &apos;src/index.html&apos;),//源文件路径</span><br><span class="line">    filename: &apos;index.html&apos;//自动生成的HTML文件的名称</span><br><span class="line">  &#125;)</span><br><span class="line">],</span><br></pre></td></tr></table></figure></li></ul><p>配置好以后就可以使用了，那么这款插件是起什么作用的呢，前面提到了 webpack-dev-server 插件会将js文件生成到根路径内存中，那么 html-webpack-plugin 这款插件也是类似的，将html文件生成到内存中，并且会将页面中原本对js的引用失效，换成对内存中在根路径的js文件的引用，刚好也解决了前面插件的问题，同时存放在内存中也能够提高运行速度，并且会在output.path的路径中生成一份由我们命名的html文件，方便管理，并且这个新生成的文件会自动引入入口js文件，所以在源文件中就要把原来对入口文件的引用去掉。</p><h3 id="loaders"><a href="#loaders" class="headerlink" title="loaders"></a>loaders</h3><p>loader 用于对模块的源代码进行转换。当源代码中引入了非js模块的时候就有可能会出现无法打包的情况，这是因为webpack默认是无法处理除了js之外的文件的，那么此时就要用到各种各样的loader来帮助我们处理这些文件或者模块了。</p><h4 id="css-loader"><a href="#css-loader" class="headerlink" title="css-loader"></a>css-loader</h4><p>在一个前端项目中我们除了js之外最长用到的应该就是css文件了，如果直接在入口文件中引入css文件的话在打包的时候就会报错，这是后就需要用相应的loader来处理了。</p><p>像是这样直接使用就会报错：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">'jquery'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./index.css'</span> </span><br><span class="line">$(<span class="string">'.test'</span>).html(<span class="string">'这是一段新的文字'</span>);</span><br></pre></td></tr></table></figure></p><p>那么来看看如何使用 css loader：</p><ol><li><p>先是通过<code>$ npm i style-loader css-loader -D</code>来安装两个需要的loader</p></li><li><p>然后再到配置文件中进行相应的配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123; <span class="comment">// 用来配置第三方loader模块</span></span><br><span class="line">  rules: [ <span class="comment">// 匹配规则</span></span><br><span class="line">    &#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">use</span>: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>] &#125;<span class="comment">//处理css文件的规则</span></span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>test 就是相应要匹配的文件，这里使用的是正则表达式，表示匹配的是以 .css 结尾的文件。use是一个表示要用什么loader来处理前面 test 匹配的文件。</p></blockquote><h4 id="less-loader"><a href="#less-loader" class="headerlink" title="less-loader"></a>less-loader</h4><p>less-loader 与css-loader类似，只不过是用来处理less文件的：</p><ol><li>通过<code>npm i less-loader less -D</code> 来安装。</li></ol><p>2.设置匹配规则：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; test: /\.less$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;, &apos;less-loader&apos;] &#125;,</span><br></pre></td></tr></table></figure></p><h4 id="sass-loader"><a href="#sass-loader" class="headerlink" title="sass-loader"></a>sass-loader</h4><p>sass-loader 与css-loader类似，只不过是用来处理scss文件的：</p><ol><li>通过<code>npm i sass-loader node-sass --D</code></li></ol><p>2.设置匹配规则：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; test: /\.scss$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;, &apos;sass-loader&apos;] &#125;</span><br></pre></td></tr></table></figure></p><h4 id="file-loader"><a href="#file-loader" class="headerlink" title="file-loader"></a>file-loader</h4><p>当我们通过url地址引用一些图片或者是字体图标的时候，webpack默认也是处理不了的，这个时候我们就需要使用到<strong>file-loader</strong>了：</p><p>比如在css中设置背景图片时：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.test</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: aqua;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(./images/1.png);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用 file-loader ：</p><ol><li>通过<code>$ npm i file-loader -D</code>安装</li></ol><p>2.设置匹配规则：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">test</span>: <span class="regexp">/\.(png|jpg|gif)$/</span>, <span class="attr">use</span>: <span class="string">'file-loader?name=[name].[ext]'</span> &#125;,   <span class="comment">//匹配图片，并且设置参数图片名称为图片原本名称加上原本后缀名</span></span><br><span class="line">&#123; <span class="attr">test</span>: <span class="regexp">/\.(ttf|eot|svg|woff|woff2)$/</span>, <span class="attr">use</span>: <span class="string">'file-loader'</span> &#125;,<span class="comment">//匹配字体</span></span><br></pre></td></tr></table></figure></p><p>可以像这样设置参数，具体有哪些选项并且有什么作用可以看<a href="https://www.webpackjs.com/loaders/file-loader/" target="_blank" rel="noopener">这里</a>。</p><h4 id="其他loader"><a href="#其他loader" class="headerlink" title="其他loader"></a>其他loader</h4><p>还有其他的一些loader这里就不一一介绍了，在有需要的情况下可以选择安装，这里是<a href="https://www.webpackjs.com/loaders/" target="_blank" rel="noopener">官方文档</a>。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>webpack是一款非常优秀的打包工具，这篇博客的例子非常简单，只演示了单入口单页面的情况，但是我们已经可以看出使用webpack带来的便利了，所有的资源全部被打包在了<code>output.path</code>目录中，也可以通过配置<strong>file-loader</strong>将图片之类的资源放在单独的子目录中在图片多的情况下方便管理。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ebpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。这是webpack中文文档中的一段话。合理的使用好webpack可以使我们模块化开发以及后期的维护更加的便利，这也是webpack会是现在比较流行的打包工具之一，这篇博客就将介绍webpack的基本用法。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>理解JS中的执行环境</title>
    <link href="https://q32757468.github.io/2019/07/21/%E7%90%86%E8%A7%A3JS%E4%B8%AD%E7%9A%84%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83/"/>
    <id>https://q32757468.github.io/2019/07/21/理解JS中的执行环境/</id>
    <published>2019-07-21T11:18:41.000Z</published>
    <updated>2019-07-25T09:32:46.937Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;执行环境（execution context）也有翻译为执行上下文，这是JS中非常基础但是也非常重要的一个概念，通过理解执行环境我们可以更加了解js的运作机制。<br><a id="more"></a></p></blockquote><h3 id="什么是执行环境"><a href="#什么是执行环境" class="headerlink" title="什么是执行环境"></a>什么是执行环境</h3><p><strong>执行环境</strong>定义了变量或函数有权访问的其他数据，决定了它们各自的行为。这是高级编程中的一句话。</p><p>说简单点理解，<strong>执行环境</strong>其实就是一个环境，在这个环境中保存了一些重要的数据。</p><p>每个函数都有自己的<strong>执行环境</strong>，此外还存在一个全局的执行环境，在web浏览器中，该执行环境被认为是window对象（因为所有的属性和方法都是window对象创建的）。</p><p>当<strong>执行环境</strong>中的所有代码执行完毕后，该执行环境就会被销毁，退出执行栈。（全局执行环境直到浏览器关闭才会被销毁）</p><h3 id="执行环境与执行栈"><a href="#执行环境与执行栈" class="headerlink" title="执行环境与执行栈"></a>执行环境与执行栈</h3><p>要理解执行环境我们还需要了解一个概念：<strong>执行栈</strong>。我们都知道栈是一种LIFO（Last-In-First-Out）的数据结构，也就是后进先出。</p><p>通过我前面的关于js事件循环机制的文章现在我们可以知道，当js执行到非异步的函数的时候会立马将该函数推入到执行栈中，那么现在我们可以知道被推入执行栈的是该函数的执行环境,当函数执行完毕就会被弹出，也就是执行环境被销毁，然后根据执行流继续执行后面的代码。</p><p>到这里我相信执行环境的基本概念已经有了，也就是在执行某一函数时的环境，当函数执行完毕该环境就会被销毁。</p><p>现在我们可以通过一个例子来更加形象的理解执行栈与执行环境：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  console.log(&apos;csznb&apos;);</span><br><span class="line">  function bar() &#123;</span><br><span class="line">    console.log(&apos;cszsfyq&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">function baz() &#123;</span><br><span class="line">  console.log(&apos;cszfcs&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们可以通过图片方便理解：<br><img src="http://m.qpic.cn/psb?/V131x4904WMIoW/zfAwo9zxnj2TpvYz6yNVcFum7BaXmPIokG4SckB0snM!/b/dLYAAAAAAAAA&bo=WgQtAgAAAAADB1M!&rf=viewer_4"></p><ul><li><p>通过图片我们就可以很直观的理解执行栈与执行环境了。</p></li><li><p>在开始执行foo函数之前，执行栈中就只有全局的执行环境，</p></li><li><p>当执行到foo函数就会把其执行环境推入执行栈中执行其中的代码，</p></li><li><p>当执行到bar函数则把bar函数的执行环境推入到执行栈中，由于此时这两个函数都还没有执行完毕，所以这两个函数的执行环境都存在于执行栈中，</p></li><li><p>当执行完bar函数中的代码，bar函数的执行环境就被弹出，foo函数的代码也意味着执行完毕，执行环境也被弹出，</p></li><li><p>接着开始执行baz函数，将其执行环境推入执行栈中，当执行完函数中的代码则被弹出，</p></li><li><p>最后只剩下一个全局执行环境，当浏览器关闭，全局执行环境也被销毁。</p></li></ul><h3 id="执行环境中的内容"><a href="#执行环境中的内容" class="headerlink" title="执行环境中的内容"></a>执行环境中的内容</h3><p>前面也提到了执行环境其实就是一个环境，其中保存了重要的数据，那么究竟保存的是什么数据呢？</p><ul><li><p>首先执行环境中很重要的一部分就是<strong>变量对象</strong>，在执行环境的创建时就会建立活动对象。</p></li><li><p>执行环境中还保存了<strong>作用域链</strong>，当代码在一个环境中执行时，会创建变量对象的一个作用域链。</p></li><li><p>另外在执行环境中还确定了<strong>this的指向</strong>。</p></li></ul><p>关于这三者的详细理解这里我就不介绍了，后面会些专门的文章来解释。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>当执行到一个函数，该函数的执行环境就会被推入执行栈，当这个函数完全执行完毕执行环境就会被弹出执行栈。全局执行环境一开始就存在与执行栈之中，只有当浏览器关闭才会被销毁。</p><p>这里只介绍了一些关于执行环境基本的知识，后面还会有更加详细的关于变量对象以及作用域链的理解。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;执行环境（execution context）也有翻译为执行上下文，这是JS中非常基础但是也非常重要的一个概念，通过理解执行环境我们可以更加了解js的运作机制。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JS原型与原型链以及继承</title>
    <link href="https://q32757468.github.io/2019/07/19/JS%E5%8E%9F%E5%9E%8B%E9%93%BE%E4%B8%8E%E7%BB%A7%E6%89%BF/"/>
    <id>https://q32757468.github.io/2019/07/19/JS原型链与继承/</id>
    <published>2019-07-19T10:46:26.000Z</published>
    <updated>2019-07-20T10:31:45.507Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在js对象中有一个非常重要的概念，就是原型，通过原型模式创建对象就可以共享特定的属性以及方法，合理的使用就可以减少代码量以及减少资源的消耗。这里提到原型就不得不提一下原型搜索机制：当以读取模式访问一个实例属性时，首先会在实例中搜索该属性。如果没有找到该属性，则会继续搜索实例的原型，这是在没有原型链的情况下，在通过原型链实现继承的情况下，搜索过程就得以沿着原型链继续向上。实际上原型链就是扩展了原型的搜索范围。而原型链的产生主要是通过继承来实现，这就是原型与原型链及继承这三者之间的关系。<br><a id="more"></a></p></blockquote><h3 id="原型与原型对象"><a href="#原型与原型对象" class="headerlink" title="原型与原型对象"></a>原型与原型对象</h3><p>在理解原型链与继承之前需要理解原型与原型对象的概念：</p><ul><li><p>我们都知道，我们创建的每一个函数都拥有一个<code>prototype</code>属性，这个属性的属性值是一个指针，指向一个对象，而这个对象就是原型对象，其中保存了我们定义的所有在原型上的属性或者方法，那么只要是在原型对象当中，那么这个函数的所有实例就可以访问到其中的属性或者方法，所以所这些属性和方法是共享的。</p></li><li><p>在原型对象当中，有一个属性叫做<code>constructor</code>，这个属性的属性值是一个指针，指向了当初添加了原型的那个函数。</p></li><li><p>当调用了函数创建了一个实例对象的时候，这个实例内部又还会有一个属性，这个属性是一个指针叫做<code>[[prototype]]</code>，而这个指针就指向了原型对象,对于这个属性的访问没有定义相关的标准，但是在Firefox、chrome、safari中每个实例对象都可以看到一个<strong>proto</strong>属性，其它浏览器则是完全不可见。</p></li><li><p>构造函数、原型、原型对象这三者之间的关系可以这样理解（假设有一个Person构造函数并且有相应的原型对象）：<br><img src="http://m.qpic.cn/psb?/V131x4904WMIoW/l1zNaitxZQ3jFWO5QacsM47xsgfZLDvec*pb00eWCOM!/b/dMMAAAAAAAAA&bo=IQWHAQAAAAADB4A!&rf=viewer_4"><br>通过这张图就可以很直观的看出三者之间的关系了。</p></li></ul><blockquote><p>值得注意的一点是由于原型中查找相应的值是一次搜索过程，所以一旦修改了原型对象，所发生的改变就会立刻反映出来，实例或者构造函数中原型的值也会立刻跟着变化，无论创建的先后。</p></blockquote><blockquote><p>正如上面所提到可以修改原型对象，一旦重写了原型对象就会导致constructor的指针发生变化，如果需要则要手动设置constructor.</p></blockquote><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><ul><li><p>ECMAScript中描述了<strong>原型链</strong>的概念，并将原型链作为实现继承的主要方法。</p></li><li><p>前面我们已经简单了解过原型的相关知识了，那么原型链其实顾名思义就像一条链条一样，这条链条上全都是各种不同的原型，而我们由前面就可以知道属性的搜索机制是先在当前实例中找，找不到再到原型中找，通过原型链连接许多不同的原型就可以扩大属性的搜索范围，这就是原型链的作用。</p></li><li><p>这是实现原型链的一种基本模式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name1 = <span class="string">'csz1'</span>;</span><br><span class="line">  Test1.prototype.name2 = <span class="string">'csz2'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name3 = <span class="string">'csz3'</span>;</span><br><span class="line">  Test2.prototype.name4 = <span class="string">'csz4'</span>;</span><br><span class="line">&#125;</span><br><span class="line">Test2.prototype = <span class="keyword">new</span> Test1();</span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> Test2();</span><br><span class="line"><span class="built_in">console</span>.log(obj.name1);<span class="comment">//通过原型链访问到Test1 csz1</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.name2);<span class="comment">//通过原型链访问到Test2 csz2</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.name3);<span class="comment">//在实例中找到          csz3</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.name4);<span class="comment">//在原型中找到          csz4</span></span><br></pre></td></tr></table></figure></li></ul><p>可以看出通过手动将Test1构造函数的实例绑定到Test2的原型上形成一条原型链，Test2的实例就可以通过原型链访问到Test1实例中的属性以及原型中的属性。</p><p>这条原型链可以简单的像这样表示：<br><code>obj[[prototype]] =&gt; Test2.prototype =&gt; new Test1() =&gt; Test1.prototype =&gt; Object.prototype</code></p><blockquote><p>需要注意的一点是在设置原型的时候最好不要通过对象字面量来创建<code>原型方法</code>，这会导致重写原型链，从而致使原型链被切断。</p></blockquote><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p> 许多OO语言都支持两种继承模式，接口继承与实现继承，ECMAScript则只支持实现继承，并且将原型链作为实现继承的主要方法。</p><p> 通过上面对原型链的理解，我们也知道如何通过原型链来实现继承（主要就是通过搜索机制）。</p><p> 主要有六种继承的方式：</p><h4 id="一、通过原型链来实现继承"><a href="#一、通过原型链来实现继承" class="headerlink" title="一、通过原型链来实现继承"></a>一、通过原型链来实现继承</h4><ul><li><p>通过上面原型链的例子我们知道可以通过将一个构造函数的实例设置给另一个构造函数的原型通过原型链来实现继承，并且可以看出原型链的作用十分强大。</p></li><li><p>但是直接通过原型链来实现继承也存在一些问题，我们可以看看下面这个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name1 = <span class="string">'csz1'</span>;</span><br><span class="line">  <span class="keyword">this</span>.arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line">  Test1.prototype.name2 = <span class="string">'csz2'</span>;</span><br><span class="line">  Test1.prototype.fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'test1'</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name3 = <span class="string">'csz3'</span>;</span><br><span class="line">  Test2.prototype.name4 = <span class="string">'csz4'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将Test的原型设置为Test1的实例，这条语句必须写在Test2外面</span></span><br><span class="line">Test2.prototype = <span class="keyword">new</span> Test1();</span><br><span class="line">Test2.prototype.constructor = Test2;</span><br><span class="line"><span class="keyword">const</span> obj1 = <span class="keyword">new</span> Test2();</span><br><span class="line"><span class="keyword">const</span> obj2 = <span class="keyword">new</span> Test2();</span><br><span class="line">obj1.arr.push(<span class="number">999</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj1.arr);  <span class="comment">//[1, 2, 3, 4, 5, 6, 999]</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2.arr);  <span class="comment">//[1, 2, 3, 4, 5, 6, 999]</span></span><br></pre></td></tr></table></figure></li></ul><p>可以看出当我们通过 obj1 这个实例修改了数组 arr 中的值，结果导致 obj2 中数组 arr 中的值也一起跟着修改了，那么为什么会出现这样的结果呢，其实我们不难发现当我们在执行这条语句的时候<code>Test2.prototype = new Test1();</code>是直接将一个实例设置给了 Test2的原型，这就会导致原本在Test1实例属性中的数组到了Test2中就变成了原型中的数组，那么就相当于在Test2的原型中设置了一个引用类型的属性一样，我们都知道原型对象中的属性相当于是共享的，所以结果可想而知。很明显得不到我们想要的结果。这是其中的一个问题。</p><ul><li>还有一个问题则是在创建子类型实例时无法很完美的给超类型传递参数（虽然可以传递，但会影响到所有的实例）。所以实践当中不推荐使用这种方式来实现继承。</li></ul><h4 id="二、借用构造函数"><a href="#二、借用构造函数" class="headerlink" title="二、借用构造函数"></a>二、借用构造函数</h4><p>为了解决上面出现的这些问题，开发人员开始使用一种叫做<strong>借用构造函数（constructor stealing）</strong>的技术，使用起来也很简单，在子类型构造函数中调用超类型构造函数就可以实现。</p><ul><li>可以传递参数：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test1</span>(<span class="params">money</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name1 = <span class="string">'csz1'</span>;</span><br><span class="line">  <span class="keyword">this</span>.money = money;</span><br><span class="line">  <span class="keyword">this</span>.arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line">  Test1.prototype.name2 = <span class="string">'csz2'</span>;</span><br><span class="line">  Test1.prototype.fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'test1'</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//借用了Test构造函数，并且可以通过call或者aplly方法来传递参数并改变this指向</span></span><br><span class="line">  Test1.call(<span class="keyword">this</span>, <span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">this</span>.name3 = <span class="string">'csz3'</span>;</span><br><span class="line">  Test2.prototype.name4 = <span class="string">'csz4'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj2 = <span class="keyword">new</span> Test2();</span><br><span class="line"><span class="built_in">console</span>.log(obj2.money);  <span class="comment">//1000</span></span><br></pre></td></tr></table></figure></li></ul><p>通过这个例子可以看出通过借用构造函数可以实现参数的正常传递，获取到相对应的值。</p><blockquote><p>为了确保子类型的属性不被借用来的构造函数重写，应该确保将子类型的属性写在借用来的超类型构造函数之后。</p></blockquote><ul><li>子类型实例间不会相互影响：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test1</span>(<span class="params">money</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name1 = <span class="string">'csz1'</span>;</span><br><span class="line">  <span class="keyword">this</span>.money = money;</span><br><span class="line">  <span class="keyword">this</span>.arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line">  Test1.prototype.name2 = <span class="string">'csz2'</span>;</span><br><span class="line">  Test1.prototype.fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'test1'</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name3 = <span class="string">'csz3'</span>;</span><br><span class="line">  Test1.call(<span class="keyword">this</span>, <span class="number">1000</span>);</span><br><span class="line">  Test2.prototype.name4 = <span class="string">'csz4'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj1 = <span class="keyword">new</span> Test2();</span><br><span class="line"><span class="keyword">const</span> obj2 = <span class="keyword">new</span> Test2();</span><br><span class="line">obj1.arr.push(<span class="number">999</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj1.arr);<span class="comment">//1, 2, 3, 4, 5, 6, 999]</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2.arr);<span class="comment">//[1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure></li></ul><p>可以看出由于借用来的属性全在构造函数当中，不在原型当中，所以不会出现引用类型的数据相互影响的情况。</p><h5 id="借用构造函数存在的问题"><a href="#借用构造函数存在的问题" class="headerlink" title="借用构造函数存在的问题"></a>借用构造函数存在的问题</h5><p>由于借用构造函数借来的属性以及方法全都是在构造函数的实例当中，所以单纯的这种方式就无法访问到超类型的原型上的属性和方法:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test1</span>(<span class="params">money</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name1 = <span class="string">'csz1'</span>;</span><br><span class="line">  <span class="keyword">this</span>.money = money;</span><br><span class="line">  <span class="keyword">this</span>.arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line">  Test1.prototype.name2 = <span class="string">'csz2'</span>;</span><br><span class="line">  Test1.prototype.fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'test1'</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name3 = <span class="string">'csz3'</span>;</span><br><span class="line">  Test1.call(<span class="keyword">this</span>, <span class="number">1000</span>);</span><br><span class="line">  Test2.prototype.name4 = <span class="string">'csz4'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj1 = <span class="keyword">new</span> Test2();</span><br><span class="line"><span class="keyword">const</span> obj2 = <span class="keyword">new</span> Test2();</span><br><span class="line">obj1.arr.push(<span class="number">999</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj1.arr);<span class="comment">//1, 2, 3, 4, 5, 6, 999]</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2.arr);<span class="comment">//[1, 2, 3, 4, 5, 6]</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2.name2);<span class="comment">//undefined</span></span><br></pre></td></tr></table></figure></p><p>可以看出访问存在于超类型构造函数原型中的属性是访问不到的，所以单纯的借用构造函数也是不推荐使用的。</p><h4 id="三、组合继承"><a href="#三、组合继承" class="headerlink" title="三、组合继承"></a>三、组合继承</h4><p>为了解决前面提到的两种方法的缺点，就出现了组合继承，组合继承简单来说就是将通过<strong>原型链</strong>来继承和通过<strong>借用构造函数</strong>来继承这两方法进行组合，互相取长补短，发挥二者的优势，以达到一个较好的继承效果。其实现思路是通过<strong>原型链</strong>的方式来继承超类型原型上的属性和方法，通过<strong>借用构造函数</strong>来继承超类型中构造函数上的属性和方法。</p><p>来看看具体是怎么实现的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test1</span>(<span class="params">money</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name1 = <span class="string">'csz1'</span>;</span><br><span class="line">  <span class="keyword">this</span>.money = money;</span><br><span class="line">  <span class="keyword">this</span>.arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line">  Test1.prototype.name2 = <span class="string">'csz2'</span>;</span><br><span class="line">  Test1.prototype.fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'这是test1'</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 通过借用构造函数来继承实例中的属性和方法</span></span><br><span class="line">  Test1.call(<span class="keyword">this</span>, <span class="number">999</span>);</span><br><span class="line">  <span class="keyword">this</span>.name3 = <span class="string">'csz3'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过原型链来继承超类型构的原型</span></span><br><span class="line">Test2.prototype = <span class="keyword">new</span> Test1();</span><br><span class="line">Test2.prototype.constructor = Test2;</span><br><span class="line">Test2.prototype.name4 = <span class="string">'csz4'</span>;</span><br><span class="line"><span class="keyword">const</span> obj1 = <span class="keyword">new</span> Test2();</span><br><span class="line"><span class="keyword">const</span> obj2 = <span class="keyword">new</span> Test2();</span><br><span class="line"><span class="built_in">console</span>.log(obj1.name2);<span class="comment">//csz2</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1.money);<span class="comment">//999</span></span><br><span class="line">obj1.arr.push(<span class="number">666</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj1.arr);<span class="comment">// [1, 2, 3, 4, 5, 6, 666]</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2.arr);<span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure></p><p>从结果可以看出使用<strong>组合继承</strong>成功的集合了原型链继承和借用构造函数继承的优点，同时弥补了二者的缺点，是一种比较实用的继承方式，推荐使用。</p><blockquote><p>组合继承也并不是完全没有缺点，也存在一些小问题，像是要调用两次超类型构造函数，存在资源的浪费，但是问题不大，后面会介绍一种更加完美的继承方式，到时再详细介绍。</p></blockquote><h4 id="四、原型式继承"><a href="#四、原型式继承" class="headerlink" title="四、原型式继承"></a>四、原型式继承</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原型式继承由道格拉斯·克罗克福德在2006年写了一篇文章，题为Prototypal Inheritance in JavaScript （JavaScript中的原型式继承）中介绍，他介绍了一种实现继承的方法，这种方法并没有使用严格意义上的构造函数。他的想法是借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。为了实现这个目的，他给出了如下函数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125; </span><br><span class="line">  F.prototype = o; </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><p>通过这个函数就可以看出其实这个函数的作用就是将一个已有的对象转化为一个中间构造函数的原型对象，最后通过这个函数来返回新的实例，而这个新的实例则是这个在函数中的构造函数的实例，所以新的实例就会将我们传递给函数的这个对象当作原型对象。</p></li><li><p>从本质上来说，object()函数对传入其的对象进行了一次浅复制。</p></li><li><p>简单一点理解就是通过这个函数可以返回一个新的对象，返回的所有新对象共享传递给函数的对象作为原型对象。与原型链模式类似，所以在在使用引用类型的数据的时候需要格外注意。</p></li></ul><p>我们可以通过一个例子来理解：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line">  F.prototype = o;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line">obj1 = &#123;</span><br><span class="line">  name: <span class="string">'csz1'</span>,</span><br><span class="line">  age: <span class="number">56</span>,</span><br><span class="line">  arr: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj2 = object(obj1);</span><br><span class="line"><span class="keyword">const</span> obj3 = object(obj1);</span><br><span class="line"><span class="built_in">console</span>.log(obj2.name);<span class="comment">//csz1</span></span><br><span class="line"><span class="comment">//引用类型的数据会相互影响</span></span><br><span class="line">obj2.arr.push(<span class="number">666</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj3.arr);<span class="comment">//[1, 2, 3, 4, 5, 6, 7, 666]</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2.arr);<span class="comment">//[1, 2, 3, 4, 5, 6, 7, 666]</span></span><br></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;克罗克福德主张的这种原型式继承需要有一个对象作为基础，如果有一个现成的对象，需要根据这个对象为原型创建一个新的对象再稍作修改的话，使用这种方式就比较快速便捷。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ECMAScript5中新增了一个<code>Object.creat()</code>方法来规范原型式继承，这个方法接收两个参数，第一个参数是一个需要作为基础的对象，第二个参数是为新对象定义额外属性的对象。</p><ul><li><p>当只传入一个参数时效果与前面的克罗克福德的object函数一样。</p></li><li><p>第二个参数的格式与可以设置新对象的额外属性，新的属性会覆盖掉作为第一个参数的那个对象的同名属性，使用格式Object.defineproperties()方法一致：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">obj1 = &#123;</span><br><span class="line">  name: <span class="string">'csz1'</span>,</span><br><span class="line">  age: <span class="number">56</span>,</span><br><span class="line">  arr: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj2 = <span class="built_in">Object</span>.create(obj1, &#123;</span><br><span class="line">  <span class="comment">//要使用这种格式</span></span><br><span class="line">  name: &#123;</span><br><span class="line">    value: <span class="string">'csz2'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(obj2.name);<span class="comment">//csz2</span></span><br></pre></td></tr></table></figure></li></ul><p>在需要使用到原型式继承时可以直接使用<code>Object.creat()</code>会更加的便捷。</p><h4 id="五、寄生式继承"><a href="#五、寄生式继承" class="headerlink" title="五、寄生式继承"></a>五、寄生式继承</h4><p>寄生式（parasitic）继承是与原型式继承紧密相关的一种思路，并且同样也是由克罗克福德推而广之的。让我们来看看它是如何工作的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">obj1 = &#123;</span><br><span class="line">  name: <span class="string">'csz1'</span>,</span><br><span class="line">  age: <span class="number">56</span>,</span><br><span class="line">  arr: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> clone = <span class="built_in">Object</span>.create(original);</span><br><span class="line">  clone.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"hi"</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj2 = createAnother(obj1);</span><br><span class="line"><span class="built_in">console</span>.log(obj2.sayHi());<span class="comment">//hi</span></span><br></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实可以看出寄生式继承是原型式继承的一种扩展，相当于是把<strong>原型式继承的函数</strong>以及<strong>新对象需要扩充的属性</strong>同时封装在一个函数当中。可以在需要使用原型式继承并且需要在内部扩充属性时使用。</p><blockquote><p>注意在使用寄生式继承来为对象添加方法时不能够做到函数复用，这一点类似创建对象时的造函数模式。</p></blockquote><h4 id="六、寄生组合式继承"><a href="#六、寄生组合式继承" class="headerlink" title="六、寄生组合式继承"></a>六、寄生组合式继承</h4><p>前面提到了比较完美的<strong>组合继承</strong>也存在着缺陷，两次调用超类型构造函数，并且存在着资源浪费的情况（因为原型是超类型的实例所以会存在着有属性与子类型实例重名的情况，造成不必要的资源浪费），虽然问题不大，但是有一种更加完美的继承方式，也就是<strong>寄生组合式继承</strong>。</p><p>那么 寄生组合式继承是如何解决问题的呢：</p><ul><li><p>首先，还是使用<strong>借用构造函数</strong>来实现对超类型实例中属性和方法的继承。</p></li><li><p>其次，使用<strong>原型链的混成形式</strong>来继承原型中的属性和方法。具体做法原理是使用寄生式继承来继承超类型的原型对象，将结果指定给子类型的原型，并且将<code>constructor</code>重新指会子类型。可以将这一过程封装成一个函数，并设置两个参数，一个是子类型，一个是超类型，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">obj1, obj2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> prototype = <span class="built_in">Object</span>.create(obj2.prototype);  <span class="comment">//创建原型对象</span></span><br><span class="line">  prototype.constructor = obj1;                   <span class="comment">//将constructor重新指向子类型</span></span><br><span class="line">  obj1.prototype = prototype;                     <span class="comment">//修改子类型的prototype</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>使用 寄生组合式继承 来优化前面的组合继承的例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test1</span>(<span class="params">money</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name1 = <span class="string">'csz1'</span>;</span><br><span class="line">  <span class="keyword">this</span>.money = money;</span><br><span class="line">  <span class="keyword">this</span>.arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line">  Test1.prototype.name2 = <span class="string">'csz2'</span>;</span><br><span class="line">  Test1.prototype.fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'这是test1'</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 通过借用构造函数来继承实例中的属性和方法</span></span><br><span class="line">  Test1.call(<span class="keyword">this</span>, <span class="number">999</span>);</span><br><span class="line">  <span class="keyword">this</span>.name3 = <span class="string">'csz3'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过原型链混成形式来继承超类型构的原型</span></span><br><span class="line">inheritPrototype(Test2, Test1);</span><br><span class="line">Test2.prototype.name4 = <span class="string">'csz4'</span>;</span><br><span class="line"><span class="keyword">const</span> obj1 = <span class="keyword">new</span> Test2();</span><br><span class="line"><span class="keyword">const</span> obj2 = <span class="keyword">new</span> Test2();</span><br><span class="line"><span class="built_in">console</span>.log(obj1.name2);<span class="comment">//csz2</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1.money);<span class="comment">//999</span></span><br><span class="line">obj1.arr.push(<span class="number">666</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj1.arr);<span class="comment">// [1, 2, 3, 4, 5, 6, 666]</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2.arr);<span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure></p><p>可以看出依然可以得出一样的理想的结果，但是通过这种形式就不存在着资源浪费的情况，是最完美的一种继承方式。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这里着重介绍了继承的几种方式，以及优缺点，理解这六种继承方式是非常有必要的，以后就知道该使用哪种继承方式了，同时也对理解JS这门语言十分有帮助。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>《JavaScript高级程序设计(第三版)》</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在js对象中有一个非常重要的概念，就是原型，通过原型模式创建对象就可以共享特定的属性以及方法，合理的使用就可以减少代码量以及减少资源的消耗。这里提到原型就不得不提一下原型搜索机制：当以读取模式访问一个实例属性时，首先会在实例中搜索该属性。如果没有找到该属性，则会继续搜索实例的原型，这是在没有原型链的情况下，在通过原型链实现继承的情况下，搜索过程就得以沿着原型链继续向上。实际上原型链就是扩展了原型的搜索范围。而原型链的产生主要是通过继承来实现，这就是原型与原型链及继承这三者之间的关系。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JS中的高阶函数</title>
    <link href="https://q32757468.github.io/2019/07/16/JS%E4%B8%AD%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/"/>
    <id>https://q32757468.github.io/2019/07/16/JS中的高阶函数/</id>
    <published>2019-07-16T06:32:27.000Z</published>
    <updated>2019-07-16T07:07:03.599Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;函数是一门语言的重要组成部分，并且js中的函数还有很多特别的地方，比如函数是第一公民，那么这次来了解一下什么是高阶函数。<br><a id="more"></a></p></blockquote><h3 id="什么是高阶函数"><a href="#什么是高阶函数" class="headerlink" title="什么是高阶函数"></a>什么是高阶函数</h3><p>高阶函数的概念很简单，指的就是一个函数将另一个函数作为参数，那么这个函数就是高阶函数。<br>一个简单的高阶函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function sum(x, y, fn) &#123;</span><br><span class="line">  return fn(x) + fn(y);</span><br><span class="line">&#125;</span><br><span class="line">function add1(num) &#123;</span><br><span class="line">  return num += 1;</span><br><span class="line">&#125;</span><br><span class="line">console.log(sum(2, 3, add1));</span><br></pre></td></tr></table></figure></p><p>这就是一个简单的高阶函数，将一个函数作为另一个函数的参数。</p><h3 id="JS中自带的高阶函数"><a href="#JS中自带的高阶函数" class="headerlink" title="JS中自带的高阶函数"></a>JS中自带的高阶函数</h3><ul><li><p>map/reduce</p></li><li><p>filter</p></li><li><p>sort</p></li><li><p>。。。还有其他很多的方法都是高阶函数</p></li></ul><p>以上这些我们经常用的方法其实都是高阶函数，因为我们每次在使用时都需要传递一个函数作为参数。</p><h3 id="自己写一个Map函数"><a href="#自己写一个Map函数" class="headerlink" title="自己写一个Map函数"></a>自己写一个Map函数</h3><p>既然我们现在知道了什么是高阶函数，那么我们就可以自己写一个与js中自带的高阶函数类似的高阶函数出来，这里我们自己写一个类似map方法的高阶函数出来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.myMap = myMap;</span><br><span class="line">function myMap(fn) &#123;</span><br><span class="line">  let arr = [];</span><br><span class="line">  for (let i = 0; i &lt; this.length; i++) &#123;</span><br><span class="line">    arr.push(fn(this[i], i))</span><br><span class="line">  &#125;</span><br><span class="line">  return arr;</span><br><span class="line">&#125;</span><br><span class="line">const arr2 = [1, 23, 3, 45, 6];</span><br><span class="line">const res = arr2.myMap(function (item, index) &#123;</span><br><span class="line">  return item + index;</span><br><span class="line">&#125;)</span><br><span class="line">console.log(res);//[1, 24, 5, 48, 10]</span><br></pre></td></tr></table></figure><p>这样就实现了一个我们自己的map方法，在效果方面与js中自带的方法几乎没有差别，实现js中其他的高阶函数的做法和这个类似。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过了解掌握高阶函数对于理解js中的函数很有帮助，并且学会使用高阶函数在以后的开发中也会很有帮助。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;函数是一门语言的重要组成部分，并且js中的函数还有很多特别的地方，比如函数是第一公民，那么这次来了解一下什么是高阶函数。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JS中的基本包装类型</title>
    <link href="https://q32757468.github.io/2019/07/16/JS%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B/"/>
    <id>https://q32757468.github.io/2019/07/16/JS中的基本包装类型/</id>
    <published>2019-07-16T03:38:20.000Z</published>
    <updated>2019-07-16T04:54:38.098Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们都知道js中的数据有两大类型，基本数据类型和引用类型，但是我们也知道从逻辑上来说其实基本类型的数据其实并不是对象，也就没有属性和方法，但实际上我们在使用的过程中这些基本类型的数据也是有属性和方法的，其实这主要是依赖于基本包装类型。<br><a id="more"></a></p></blockquote><h3 id="理解基本包装类型"><a href="#理解基本包装类型" class="headerlink" title="理解基本包装类型"></a>理解基本包装类型</h3><ul><li><p>那么为什么我们使用的基本类型数据会有方法和属性呢，其实主要是由于基本包装类型的原因，当我们在对基本类型的数据调用一个属性或者方法时其实后台还会有一系列的操作来进行转换，从而能够正确的获取结果，我们可以像下面这样理解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  const str=&apos;这是一个字符串&apos;;</span><br><span class="line">  const len=str.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过这样的操作我们可以length这个属性来获取到字符串的长度，并且将这个长度赋值给 len 这个变量。、</p></li></ul><p>+但实际上它在后台的操作可以这样进行理解：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">const str_ = new String(&apos;这是一个字符串&apos;);  //创建基本包装类型的对象，并且自动获取到字符串的值</span><br><span class="line">const len=str_.length;    //调用基本包装类型对象的属性来获取长度</span><br><span class="line">str_=null;              //调用结束后销毁对象</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过上面的例子我们就可以很简单的理解基本包装类型了，基本包装类型就像是一个中转站一样，虽然基本类型的数据不是对象，但是通过后台的操作创建一个基本包装类型对象，所以我们调用基本类型的属性或者是方法实际上调用的是基本包装类型的属性或者方法，当调用完毕后再进行销毁，最终我们看到的结果就像是基本数据类型有属性或者是方法一样。</p><h3 id="不能给基本类型数据添加属性或者方法"><a href="#不能给基本类型数据添加属性或者方法" class="headerlink" title="不能给基本类型数据添加属性或者方法"></a>不能给基本类型数据添加属性或者方法</h3><p>我们可以看出虽然基本类型数据表面上看起来可以调用数据和方法，但是实际上我们也还是不能够给他们添加方法或者是属性，因为他们根本上还是基本类型数据，并且基本包装类型对象在执行完毕后会立即销毁：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  var str2 = &apos;字符串&apos;;</span><br><span class="line">  str2.name = &apos;csz&apos;;</span><br><span class="line">  console.log(str2.name);//报错，不能在字符串上创建</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="可以创建基本包装类型对象"><a href="#可以创建基本包装类型对象" class="headerlink" title="可以创建基本包装类型对象"></a>可以创建基本包装类型对象</h3><p>我们可以通过显示调用<code>Boolean、Number、String</code>来创建基本包装类型对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  const str = new String(&apos;这是一个通过构造函数创建的字符串&apos;);</span><br><span class="line">  const num = new Number(1234);</span><br><span class="line">  const res = new Boolean(true);</span><br><span class="line">  const str2 = new Object(&apos;这是一个通过Object构造函数创建的字符串&apos;);</span><br><span class="line">  console.log(typeof str);//object</span><br><span class="line">  console.log(str instanceof String);//true</span><br><span class="line">  console.log(typeof num);//object</span><br><span class="line">  console.log(num instanceof Number);//true</span><br><span class="line">  console.log(typeof str2);//object</span><br><span class="line">  console.log(str2 instanceof String);//true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出是可以通过显示的创建基本包装类型对象的，甚至可以直接通过<code>Objct</code>构造函数自动识别来创建，但是并不推荐通过这种方式来创建基本类型数据，因为这样创建的数据通过<code>typeof</code>判断的是一个对象，而不是基本数据类型。</p><p>特别是在创建Boolean类型数据时尤为要注意：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  const res = new Boolean(false);</span><br><span class="line">  console.log(res &amp;&amp; true);//true </span><br><span class="line">  const res2 = false;</span><br><span class="line">  console.log(res2 &amp;&amp; true);//false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>得到这个结果也并不奇怪，因为通过基本包装类型创建的数据实际上是一个对象，当进行比较运算时，对象都是一律按<code>true</code>处理的，所以这里并不能得到我们想要的结果。</p><blockquote><p>所以建议永远不要通过实例化构造函数的形式来创建Boolean类型的数据。</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>基本包装类型很好理解，了解基本包装类型对于对于理解js运作机制也很有帮助，还有就是一些要注意的地方，比如不要不要通过实例化构造函数的形式来创建Boolean类型的数据。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;我们都知道js中的数据有两大类型，基本数据类型和引用类型，但是我们也知道从逻辑上来说其实基本类型的数据其实并不是对象，也就没有属性和方法，但实际上我们在使用的过程中这些基本类型的数据也是有属性和方法的，其实这主要是依赖于基本包装类型。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JS中sort方法的使用</title>
    <link href="https://q32757468.github.io/2019/07/13/JS%E4%B8%ADsort%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86/"/>
    <id>https://q32757468.github.io/2019/07/13/JS中sort方法的使用及其原理/</id>
    <published>2019-07-13T04:09:41.000Z</published>
    <updated>2019-07-13T15:40:11.997Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们都知道数组有一个用来排序的方法 sort ，这个方法很有用，免去了我们自己排序的方法，并且这个方法在不同种情况下采用的排序算法也不一样，有着不错的性能，这次来了解一下它的具体用法。<br><a id="more"></a></p></blockquote><h3 id="直接使用sort方法"><a href="#直接使用sort方法" class="headerlink" title="直接使用sort方法"></a>直接使用sort方法</h3><p>sort方法可以不传递参数直接使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  const arr = [1, 23, 4, 5, 122, 223];</span><br><span class="line">  console.log(arr.sort());//结果：[1, 122, 223, 23, 4, 5]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><p>可以看出在不传递参数的情况下直接使用sort方法对一个纯数字的数组来说不能得到我们想要的结果。</p></li><li><p>原因是因为如果不传递参数，那么在执行sort方法的时候会自动调用 toString 方法将数组中的每个元素都转化为字符串，然后再进行排序。</p></li><li><p>我们都知道字符串之间的比较实际上比较的是它们的unicode码值，所以就会出现上面的这种结果。</p></li></ul><h3 id="接收参数进行排序"><a href="#接收参数进行排序" class="headerlink" title="接收参数进行排序"></a>接收参数进行排序</h3><p>sort方法可以接受一个函数作为参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const arr = [1, 2, 3, 3, 52345, 1, 50, 230];</span><br><span class="line">compare = (value1, value2) =&gt; &#123;</span><br><span class="line">  switch (true) &#123;</span><br><span class="line">    case value1 &lt; value2: return -1; break;</span><br><span class="line">    case value1 = value2: return 0; break;</span><br><span class="line">    case value1 &gt; value2: return 1; break;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(arr.sort(compare));//结果：[1, 1, 2, 3, 3, 50, 230, 52345]</span><br></pre></td></tr></table></figure></p><ul><li><p>比较函数接收两个参数，如果想要第一个参数位置位于第二个参数之前，那么就需要比较函数的返回值是一个负数</p></li><li><p>如果想要第一个参数位置位于第二个参数之后，这需要比较函数的返回值是一个正数</p></li><li><p>如果想要两个参数相等，则需要比较函数的返回值是0；</p></li></ul><p>通过传递一个比较函数作为参数就不会自动的将数组中的元素转化为字符串了，并且通过相应设置就能很轻松的获取到我们想要的结果。</p><h3 id="数组中只有数字"><a href="#数组中只有数字" class="headerlink" title="数组中只有数字"></a>数组中只有数字</h3><p>当数组中只有数字的时候可以将将排序作为sort方法参数的比较函数简化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const arr = [1, 2, 3, 3, 52345, 1, 50, 230];</span><br><span class="line">compare2 = (value1, value2) =&gt; &#123;</span><br><span class="line">  return value1 - value2;</span><br><span class="line">&#125;</span><br><span class="line">console.log(arr.sort(compare2));//结果：[1, 1, 2, 3, 3, 50, 230, 52345]</span><br></pre></td></tr></table></figure></p><p>可以看出简化后的函数十分的简单，但是只能用于对数字进行排序的情况，根据实际情况选择使用。</p><h3 id="一个小例子"><a href="#一个小例子" class="headerlink" title="一个小例子"></a>一个小例子</h3><p>通过sort排序来实现以下我们经常见到的表格中内容的排序：</p><ul><li><p>CSS:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">table</span> &#123;</span><br><span class="line">  <span class="attribute">border-collapse</span>: collapse;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">20px</span> auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">td</span>,</span><br><span class="line"><span class="selector-tag">th</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#name</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">630px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>HTML:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"name"</span>&gt;</span>按姓名<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"age"</span>&gt;</span>按年龄<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"money"</span>&gt;</span>按财富<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>年龄<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>财富<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>JS:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个存放数据的数组</span></span><br><span class="line"><span class="keyword">let</span> info = [</span><br><span class="line">  &#123; <span class="string">'name'</span>: <span class="string">'csz'</span>, <span class="string">'age'</span>: <span class="string">'18'</span>, <span class="string">'money'</span>: <span class="number">99999999999</span> &#125;,</span><br><span class="line">  &#123; <span class="string">'name'</span>: <span class="string">'csz2'</span>, <span class="string">'age'</span>: <span class="string">'19'</span>, <span class="string">'money'</span>: <span class="number">9399999999999</span> &#125;,</span><br><span class="line">  &#123; <span class="string">'name'</span>: <span class="string">'csz3'</span>, <span class="string">'age'</span>: <span class="string">'17'</span>, <span class="string">'money'</span>: <span class="number">9239999999999</span> &#125;,</span><br><span class="line">  &#123; <span class="string">'name'</span>: <span class="string">'csz4'</span>, <span class="string">'age'</span>: <span class="string">'16'</span>, <span class="string">'money'</span>: <span class="number">9935999999999</span> &#125;,</span><br><span class="line">  &#123; <span class="string">'name'</span>: <span class="string">'csz5'</span>, <span class="string">'age'</span>: <span class="string">'41'</span>, <span class="string">'money'</span>: <span class="number">99991599399999</span> &#125;,</span><br><span class="line">];</span><br><span class="line"><span class="comment">//复制一份，保存原始的没有规律的数据</span></span><br><span class="line"><span class="keyword">let</span> info2 = [...info];</span><br><span class="line"><span class="comment">//变回最原始的状态</span></span><br><span class="line">byNormal = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  info2 = [...info];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//按照年龄升序</span></span><br><span class="line">byAge = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  info2.sort(<span class="function">(<span class="params">value1, value2</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">parseInt</span>(value1.age) - <span class="built_in">parseInt</span>(value2.age);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//按照姓名升序</span></span><br><span class="line">byName = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  info2 = [...info];</span><br><span class="line">  info2.sort();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//按照财富升序</span></span><br><span class="line">byMoney = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  info2.sort(<span class="function">(<span class="params">value1, value2</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value1.money - value2.money;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//将数组中的数据渲染到页面中</span></span><br><span class="line">toHtml = <span class="function">(<span class="params">type</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> name:</span><br><span class="line">      byName();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> age:</span><br><span class="line">      byAge();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> money:</span><br><span class="line">      byMoney();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      byNormal();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> str = <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">for</span> (item <span class="keyword">of</span> info2) &#123;</span><br><span class="line">    str += <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;tr&gt;</span></span><br><span class="line"><span class="string">    &lt;td&gt;<span class="subst">$&#123;item.name&#125;</span>&lt;/td&gt;</span></span><br><span class="line"><span class="string">    &lt;td&gt;<span class="subst">$&#123;item.age&#125;</span>&lt;/td&gt;</span></span><br><span class="line"><span class="string">    &lt;td&gt;<span class="subst">$&#123;item.money&#125;</span>&lt;/td&gt;</span></span><br><span class="line"><span class="string">  &lt;/tr&gt;</span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">document</span>.querySelector(<span class="string">'tbody'</span>).innerHTML = str;</span><br><span class="line">&#125;</span><br><span class="line">toHtml();</span><br><span class="line"><span class="comment">// 为三个按钮分别绑定渲染的功能</span></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'#name'</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; toHtml(name) &#125;;</span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'#age'</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; toHtml(age) &#125;;</span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'#money'</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; toHtml(money) &#125;;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>这里实现的都是升序，降序的做法更加的简单，只需要将升序结果的数组调用以下reserve方法就可以了。</p></blockquote><p><img src="http://m.qpic.cn/psb?/V131x4904WMIoW/AewM4ovvv7uA0F.svwqvQcepoctT*sbnJQXK8NthqkM!/b/dLgAAAAAAAAA&bo=NgJWAgAAAAADB0I!&rf=viewer_4"></p><h3 id="各浏览器中的实现"><a href="#各浏览器中的实现" class="headerlink" title="各浏览器中的实现"></a>各浏览器中的实现</h3><ul><li><p>Mozilla/Firefox : 归并排序（<a href="https://dxr.mozilla.org/seamonkey/source/js/src/jsarray.c#2097ps://en.cppreference.com/w/cpp/algorithm/qsort" target="_blank" rel="noopener">jsarray.c 源码</a>）</p></li><li><p>V8 ：数组长度小于一定值时用插入排序，其它用快速排序（<a href="https://github.com/v8/v8/blob/ad82a40509c5b5b4680d4299c8f08d6c6d31af3c/src/js/array.js" target="_blank" rel="noopener">array.js 源码</a> 第710行）</p></li><li><p>Webkit ：底层实现用了 C++ 库中的 qsort() 方法（<a href="https://en.cppreference.com/w/cpp/algorithm/qsort" target="_blank" rel="noopener">JSArray.cpp 源码</a>）</p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>今天在看高级编程的时候看到相关知识，然后自己尝试了一下，再分享记录一下，也可以通过各个浏览器的解释器的代码学习一下排序的知识。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;我们都知道数组有一个用来排序的方法 sort ，这个方法很有用，免去了我们自己排序的方法，并且这个方法在不同种情况下采用的排序算法也不一样，有着不错的性能，这次来了解一下它的具体用法。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>简单理解js中的内存空间与垃圾回收</title>
    <link href="https://q32757468.github.io/2019/07/11/%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3js%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <id>https://q32757468.github.io/2019/07/11/简单理解js中的内存空间与垃圾回收机制/</id>
    <published>2019-07-11T06:56:40.000Z</published>
    <updated>2019-07-11T10:09:53.087Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;想要更加的了解js就需要对它的运作机制有更加深入的了解，这次来了解以下js的内存空间与垃圾回收机制，通过理解这两个概念对我们的开发十分有帮助。<br><a id="more"></a></p></blockquote><h3 id="内存空间"><a href="#内存空间" class="headerlink" title="内存空间"></a>内存空间</h3><p>我们都知道js中的数据类型有基础数据类型与引用数据类型之分，二者的运作机制也不一样。</p><h4 id="基础数据类型与栈内存"><a href="#基础数据类型与栈内存" class="headerlink" title="基础数据类型与栈内存"></a>基础数据类型与栈内存</h4><ul><li><p>我们知道在创建执行上下文时会找到所有变量声明，并且创建VO同时消耗一定的内存空间，当到达执行阶段的时候VO成为AO，所有变量都可以访问。</p></li><li><p>当变量的值被修改时就会直接在相应栈内存空间对变量的值进行修改。</p></li><li><p>当复制一个变量会直接在VO中创建这个变量的值的副本，同时占用新的栈内存空间。</p></li></ul><p><img src="http://m.qpic.cn/psb?/V131x4904WMIoW/z*R*IeVf8ofKH3UImPKBD2VQgzyGlwQ5Sz8lcpBZPgc!/b/dLsAAAAAAAAA&bo=NgEUAgAAAAADBwM!&rf=viewer_4"></p><h3 id="引用数据类型与堆内存"><a href="#引用数据类型与堆内存" class="headerlink" title="引用数据类型与堆内存"></a>引用数据类型与堆内存</h3><ul><li><p>而引用类型的数据在创建执行上下文后，到达执行阶段时，变量保存的实际上是对象的引用，保存的也就是堆内存中堆内存的地址。</p></li><li><p>当复制一个引用类型的值的时候也会在VO中创建一个值的副本，但是区别在于基础类型的值就是栈内存空间中的值，而引用类型的值是一个地址，所以即使复制了一份，其实两个变量引用的是同一个对象。</p></li><li><p>当复制保存着对象的某个变量时，操作的是对象的引用。但在为对象添加属性时，操作的是实际的对象，所以修改复制的变量，也会影响到被复制的哪一个变量。</p></li></ul><p><img src="http://m.qpic.cn/psb?/V131x4904WMIoW/WeIMtcs*I.Iyfd6yw*nID7ZWqUtzAUsGG2vMMsDBERo!/b/dFMBAAAAAAAA&bo=OQPVAQAAAAADF9w!&rf=viewer_4"></p><h3 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h3><p>js有自动的垃圾回收机制，所有通常我们可以不用管垃圾回收这件事，而垃圾回收一般有两个策略。</p><h4 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h4><p>标记清除说简单点就像名字这样理解，清除被标记的变量。</p><ul><li><p>垃圾收集器会在运行时给内存中所有的变量都加上标记</p></li><li><p>然后会去掉环境中的变量，以及环境中引用的变量的标记</p></li><li><p>删除那些被标记的变量以及他们的值并且回收相应的内存空间</p></li></ul><blockquote><p>到 2008年为止，IE、Firefox、Opera、Chrome和 Safari的 JavaScript实现使用的都是标记清除式的 垃圾收集策略（或类似的策略），只不过垃圾收集的时间间隔互有不同。</p></blockquote><h4 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h4><p>引用计数就是记录变量的引用次数，当变量每被使用一次，赋值给另一个变量，该变量的引用次数就加以，被赋值的变量被其他变量赋值，该变量引用次数就减一。如果这个变量引用次数为0则在垃圾收集器运作时将其回收。</p><blockquote><p>最早是Netscape使用这种方法，但是因为这种方法存在问题，所以后来被弃用了。</p></blockquote><p>###垃圾回收与内存空间及其优化</p><ul><li><p>局部变量只在函数执行的过程中存在。而在这个过程中，会为局部变量在栈（或堆）内存上分配相应的空间，以便存储它们的值。然后在函数中使用这些变量，直至函数执行结束。此时，局部变量就没有存在的必要了，因此可以释放它们的内存以供将来使用。在这种情况下，很容易判断变量是否还有存在的要</p></li><li><p>由于分配给web浏览器的内存空间通常相比桌面应用程序要更加的少，所以要尽可能都优化内存的消耗。</p></li><li><p>但是全部变量就不一样，全局变量就在那，不知道你什么时候会用它，并不会被回收，所以并不推荐使用过多的全局变量，推荐使用<code>let</code>与<code>const</code>来创建块级变量，减少内存的消耗。</p></li><li><p>如果使用了全局变量，最好的处理方式就是在这个变量不再使用就将其设置为<code>null</code>以优化内存消耗。</p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过梳理清楚js中有关内存相关的知识，可以有对js更加深的认识，对开发以及性能会有很大帮助。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;想要更加的了解js就需要对它的运作机制有更加深入的了解，这次来了解以下js的内存空间与垃圾回收机制，通过理解这两个概念对我们的开发十分有帮助。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ES6的使用</title>
    <link href="https://q32757468.github.io/2019/07/10/ES6%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://q32757468.github.io/2019/07/10/ES6的使用/</id>
    <published>2019-07-10T10:30:10.000Z</published>
    <updated>2019-07-11T06:12:18.649Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ES6， 全称 ECMAScript 6.0 ，是 JavaScript 的下一个版本标准，2015.06 发版。ES6 主要是为了解决 ES5 的先天不足，比如 JavaScript 里并没有类的概念，但是目前浏览器的 JavaScript 是 ES5 版本，大多数高版本的浏览器也支持 ES6，不过只实现了 ES6 的部分特性和功能。ES6的发布到现在已经有很长一段时间了，各个浏览器的新版本也都支持ES6的大部分语法，使用ES6能够极大的提高我们开发的效率以及使提高代码的可读性。<br><a id="more"></a></p></blockquote><p>使用ES6来书写代码可以很大程度上的提高代码的书写效率，并且使用也相对简便，新的ES6语法涉及的还是挺多的，这里就介绍使用一些比较常见并且实用的ES6语法。</p><h3 id="声明关键字-let-与-const"><a href="#声明关键字-let-与-const" class="headerlink" title="声明关键字 let 与 const"></a>声明关键字 let 与 const</h3><p>在ES5中我们都是只是用 var 关键字来声明变量，但是 var 存在很多的缺陷，比如定义很多全局变量会导致变量名称冲突，全局变量不好回收，导致占用内存过多需要手动释放等等，使用 let 与 const 就可以有效的避免这些问题。</p><p>先来看看他们之间的区别：<br>  <table style="text-align: center">    <tr>      <td> </td>      <td>var</td>      <td>let</td>      <td>const</td>    </tr>    <tr>      <td>作用域</td>      <td>全局、函数</td>      <td>代码块</td>      <td>代码块</td>    </tr>    <tr>      <td>重新赋值</td>      <td>能</td>      <td>能</td>      <td>不能</td>    </tr>    <tr>      <td>变量提升</td>      <td>能</td>      <td>不能</td>      <td>不能</td>    </tr>    <tr>      <td>重复声明</td>      <td>能</td>      <td>不能</td>      <td>不能</td>    </tr>  </table></p><ul><li><p>其实通过这张表格就能很清楚的知道他们之间的区别了</p></li><li><p>这里的代码块指的是大括号内，也就是<code>{ }</code>，在大括号中定义的变量在大括号外部就无法访问了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  let a = 30;</span><br><span class="line">  const b = 40;</span><br><span class="line">&#125;</span><br><span class="line">console.log(a);//报错未定义</span><br><span class="line">console.log(b);//报错未定义</span><br></pre></td></tr></table></figure></li><li><p>不支持变量提升</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  console.log(a, b);//报错</span><br><span class="line">  let a = 100;</span><br><span class="line">  const b = 10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>const无法重新赋值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  const b = 10;</span><br><span class="line">  b = 100;    </span><br><span class="line">  //报错</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>暂时性死区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a = 100;</span><br><span class="line">&#123;</span><br><span class="line">  console.log(a);</span><br><span class="line">  let a;</span><br><span class="line">  //报错</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ES6 明确规定，代码块内如果存在 let 或者 const，代码块会对这些命令声明的变量从块的开始就形成一个封闭作用域。代码块内，在声明变量 变量 之前使用它会报错。</p></li></ul><p>推荐不要使用 var 关键字了，全部用 let 与 const 代替。</p><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>ES6为我们提供了箭头函数。</p><ul><li><p>使用箭头函数可以使代码的可读性更强</p></li><li><p>并且使用箭头函数可以更好的明确<code>this</code>的指向，就不用特别麻烦的去考虑this的指向了</p><ul><li><p>在不使用箭头函数的情况下函数中的this总是指向调用者，就是说谁最后调用了该函数，那么this就指向谁，此时的this指向是动态的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const name = &apos;csz2&apos;;</span><br><span class="line">&#123;</span><br><span class="line">  const obj = &#123;</span><br><span class="line">    name: &apos;csz&apos;,</span><br><span class="line">    foo() &#123;</span><br><span class="line">      console.log(`$&#123;this.name&#125;fcnb`);  //cszfcnb</span><br><span class="line">      console.log(this);                //&#123;name: &quot;csz&quot;, foo: ƒ&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  obj.foo();   //cszfcnb  //&#123;name: &quot;csz&quot;, foo: ƒ&#125;</span><br><span class="line">  const bar = obj.foo;</span><br><span class="line">  bar();    //csz2fcnb  //Window &#123;postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, parent: Window, …&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>但是动态的this函数指向在使用回调函数的时候经常会得不到我们想要的结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var name = &apos;csz3&apos;;</span><br><span class="line">&#123;</span><br><span class="line">  const obj = &#123;</span><br><span class="line">    name: &apos;csz&apos;,</span><br><span class="line">    chara: [&apos;fcyq&apos;],</span><br><span class="line">    foo() &#123;</span><br><span class="line">      this.chara.map(function (chara) &#123;</span><br><span class="line">        console.log(`$&#123;this.name&#125;$&#123;chara&#125;`);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  obj.foo();    //结果是  csz3fcyq  此时的this指向了 Window ,很显然这不是我们想要的。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在使用了箭头函数以后 this 的指向就会变成静态的，即在创建函数时 this 指向谁那么调用时this 也指向谁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var name = &apos;csz3&apos;;</span><br><span class="line">&#123;</span><br><span class="line">  const obj = &#123;</span><br><span class="line">    name: &apos;csz&apos;,</span><br><span class="line">    chara: [&apos;fcyq&apos;],</span><br><span class="line">    foo() &#123;</span><br><span class="line">      this.chara.map(chara =&gt; &#123;</span><br><span class="line">        console.log(`$&#123;this.name&#125;$&#123;chara&#125;`);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  obj.foo();    //结果是  cszfcyq  这样就解决了上面出现的问题</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>所以合理的使用箭头函数可以使开发更加的简便</p></li><li><p>由于使用了箭头函数之后this的指向是静态的，所以在有些情况下也是不适合使用箭头函数的<br>例如在创建构造函数时，在对象中创建方法时，各种事件的回调等等，这些情况都不适合用回调函数，否则会出现很多意想不到的错误。</p></li></ul></li></ul><h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><p>使用结构赋值可以很轻松的给数组或者是赋值。</p><h4 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h4><ul><li><p>基本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  const arr = [1, 2, 3, 4, 5, 6];</span><br><span class="line">  const [a, b, c] = arr;</span><br><span class="line">  console.log(a, b, c);//结果1 2 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>可以使用默认值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  const arr = [1, 2];</span><br><span class="line">  const [a, b, c = 30] = arr;</span><br><span class="line">  console.log(a, b, c);//结果1 2 30</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>但结果为 undefined 就会使用默认值。</p><ul><li>可以使用剩余运算符<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  const arr = [1, 2, 3, 4, 5, 6];</span><br><span class="line">  const [a, b, ...c] = arr;</span><br><span class="line">  console.log(a, b, c);//结果1 2 (4) [3, 4, 5, 6]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>默认运算符的结果将保存为数组。</p><h4 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h4><p>对象结构与数组解构类似，但是也有区别：</p><ul><li><p>基本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  const obj = &#123;</span><br><span class="line">    a: 10,</span><br><span class="line">    b: 20,</span><br><span class="line">    c: 30</span><br><span class="line">  &#125;;</span><br><span class="line">  const &#123; a, b, c &#125; = obj;</span><br><span class="line">  console.log(a, b, c);//10 20 30</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>重命名<br>由于有时变量名并不一定和对象中的属性名相同，所以可以重命名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  const obj = &#123;</span><br><span class="line">    a: 10,</span><br><span class="line">    b: 20,</span><br><span class="line">    c: 30</span><br><span class="line">  &#125;;</span><br><span class="line">  const &#123; a: A, b: B, c: C &#125; = obj;</span><br><span class="line">  console.log(A, B, C);//10 20 30</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>大部分都与数组解构类似所以不做演示了。</p></blockquote><h3 id="剩余运算符"><a href="#剩余运算符" class="headerlink" title="剩余运算符"></a>剩余运算符</h3><ul><li><p>使用剩余运算符可以一次性的拿到所有的剩余的参数或者是对象、数组中的元素</p></li><li><p>可以在解构赋值时使用<br>参考本篇博客解构赋值。</p></li><li><p>可以用获取函数参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  function foo(...arg) &#123;</span><br><span class="line">    console.log(arg);</span><br><span class="line">  &#125;</span><br><span class="line">  foo(1, 2, 3, 4, 5, 6);//结果(6) [1, 2, 3, 4, 5, 6]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>我们可以看出在获取参数方面和 <code>arguments</code> 有一些相似，都不关心传了多少个参数，想用某个参数直接从数组中调用就可以了<br>但是他们之间还是有很明显的区别的：</p><pre><code>- 剩余运算符需要进行设置，需要传递一个剩余运算符名称，通过这个名称来获取参数。而``arguments``不用设置，直接使用arguments来调用参数就可以了。- 剩余运算符是一个真正的数组，可以调用数组的方法。而``arguments``是一个伪数组，不能调用数组的相关方法。</code></pre><h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3><ul><li><p>ES6新增了一种字符串的包裹方式，使用<code>`</code>反引号进行包裹。这就是模板字符串。</p></li><li><p>模板字符串中可以使用变量。通过使用<code>${}</code>包裹变量就可以变量在能够在模板字符串解析,<code>${}</code>内可以是变量也可以是任意表达式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  const a = 10;</span><br><span class="line">  const b = 20;</span><br><span class="line">  const str = `a+b=$&#123;a + b&#125;`;</span><br><span class="line">  console.log(str);//结果a+b=30</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>可以看出使用模板是十分的方便，再也不用麻烦的拼接以及检查。</p><ul><li>模板字符串顾名思义可以用来定义模板：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  const template = `</span><br><span class="line">  &lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;row&quot;&gt;</span><br><span class="line">      &lt;h1&gt;这是标题&lt;/h1&gt;</span><br><span class="line">      &lt;p&gt;&lt;span&gt;😊&lt;/span&gt; 这是一段文字描述&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;`;</span><br><span class="line">  console.log(template);</span><br><span class="line">  document.querySelector(&apos;body&apos;).innerHTML = template;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在ES5中我们要书写一个模板并且要保持一定的格式是非常麻烦的一件事情，因为涉及到众多双引号有时候还会有单引号，如今在ES6中我们直接使用模板字符串就可以很轻松的定义一个可读性非常强的模板。十分的方便。</p><h3 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h3><p><code>扩展运算符</code> 的作用与剩余运算符的作用相反， <code>剩余运算符</code>  是可以将剩余部分合并成为一个数组，而  扩展运算符  则是可以将可遍历对象进行拆分。</p><ul><li><p>使用非常简单，在需要拆分的可遍历对象前面加<code>...</code>即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  const str = &apos;asdfghjkl&apos;;</span><br><span class="line">  const obj = &#123; a: 10, b: 20, c: 30 &#125;;</span><br><span class="line">  const arr = [1, 2, 3, 4, 5, 6];</span><br><span class="line">  console.log(...str);      //a s d f g h j k l</span><br><span class="line">  console.log(&#123; ...obj &#125;);  //&#123;a: 10, b: 20, c: 30&#125;</span><br><span class="line">  console.log([...arr]);  //6) [1, 2, 3, 4, 5, 6]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>用来拼接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  const arr = [1, 2, 3, 4, 5, 6];</span><br><span class="line">  const arr2 = [...arr, ...arr];</span><br><span class="line">  console.log([...arr2]);   //(12) [1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>通过扩展运算符就可以十分轻松的对可遍历对象进行拼接或者是对数组或者是对象的深拷贝。</p><ul><li>作为参数传递给函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  function sum(...num) &#123;</span><br><span class="line">    return num.reduce((pre, cur) =&gt; pre + cur);</span><br><span class="line">  &#125;</span><br><span class="line">  const nums = [1, 2, 3, 4, 5, 6];</span><br><span class="line">  console.log(sum(...nums));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>就像这个求和函数一样，我们要给数组求和，不用关心数组里面有多少元素，直接将数组扩展为函数的参数就可以进行求和了，十分的简单便捷。</p><h3 id="新的迭代器"><a href="#新的迭代器" class="headerlink" title="新的迭代器"></a>新的迭代器</h3><p>js中原来存在的这几种迭代方式都存在一些不方便的地方：</p><ul><li>for 循环在很多场景下不够简便，并且代码可读性较差</li><li>forEach 循环不能够使用 <code>break</code>和<code>continue</code></li><li><p>for in 循环遍历的是遍历对象上的所有可枚举属性，甚至包括原型属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  Array.prototype.test2 = &apos;456&apos;;</span><br><span class="line">  const arr = [1, 2, 3, 4, 5, 6, 7];</span><br><span class="line">  arr.test = &apos;123&apos;;</span><br><span class="line">  for (index in arr) &#123;</span><br><span class="line">    console.log(arr[index]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://m.qpic.cn/psb?/V131x4904WMIoW/96r62kRzScMB5MKAr1Y5TactkvsfCCafy7k7fBBJkkY!/b/dFMBAAAAAAAA&bo=sQP3AAAAAAADB2c!&rf=viewer_4"></p><p>可以看出使用for in 循环不仅会把属性遍历出来，连数组原型上的属性都会遍历出来。</p></li></ul><p>所以 for of 循环就产生了：</p><ul><li>基本：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  const arr = [1, 2, 3, 4, 5, 6];</span><br><span class="line">  for (num of arr) &#123;</span><br><span class="line">    console.log(num); //1 2 3 4 5 6</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>for of 循环可以很轻松的遍历数组中的元素。</p><ul><li><p>通过<code>entries()</code>方法同时遍历索引和值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  const arr = [1, 2, 3, 4, 5, 6, 7];</span><br><span class="line">  for ([index, item] of arr.entries()) &#123;</span><br><span class="line">    console.log(`index:$&#123;index&#125;,item:$&#123;item&#125;`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>可以使用 break 和 continue</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  const arr = [1, 2, 3, 4, 5, 6, 7];</span><br><span class="line">  for (num of arr) &#123;</span><br><span class="line">    console.log(num);</span><br><span class="line">    if (num == 3) &#123;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>结果： 1 2 3</p><blockquote><p>通过以上可以看出在原生js中，迭代器中for of 循环是最强大的。</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>ES6为我们提供了一系列的新的功能，可以看出这些功能十分的强大，加以利用可以很大程度的提高我们的开发效率。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ES6， 全称 ECMAScript 6.0 ，是 JavaScript 的下一个版本标准，2015.06 发版。ES6 主要是为了解决 ES5 的先天不足，比如 JavaScript 里并没有类的概念，但是目前浏览器的 JavaScript 是 ES5 版本，大多数高版本的浏览器也支持 ES6，不过只实现了 ES6 的部分特性和功能。ES6的发布到现在已经有很长一段时间了，各个浏览器的新版本也都支持ES6的大部分语法，使用ES6能够极大的提高我们开发的效率以及使提高代码的可读性。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>简单理解js单线程异步与事件循环机制</title>
    <link href="https://q32757468.github.io/2019/07/06/%E5%85%B3%E4%BA%8Ejs%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%BC%82%E6%AD%A5%E4%B8%8E%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    <id>https://q32757468.github.io/2019/07/06/关于js单线程异步与事件循环机制的学习/</id>
    <published>2019-07-06T05:02:49.000Z</published>
    <updated>2019-07-07T05:14:45.323Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这几天在学习过程中遇到一些问题，在找相关资料的情况下了解到js单线程和事件循环机制的一些知识，通过看一些大牛的文章，感觉又学习到了很多，对js有了更深的理解，这里来记录一下我学习完之后的一些理解。<br><a id="more"></a></p></blockquote><h3 id="js单线程"><a href="#js单线程" class="headerlink" title="js单线程"></a>js单线程</h3><p>我们都知道js实际上是单线程的，但是很多时候很多操作其实是异步的，那么这是怎么实现的呢，js单线程该如何实现异步。其实虽然js是单线程的，但是浏览器并不是单线程的，浏览器是多线程的。</p><p>那么浏览器内核一般都有哪些常驻现成：</p><ul><li><p>GUI渲染线程</p><ul><li>负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。</li><li>当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行</li><li>注意，GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。</li></ul></li><li><p>JS引擎线程</p><ul><li>也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎）</li><li>JS引擎线程负责解析Javascript脚本，运行代码。</li><li>JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序</li><li>同样注意，GUI渲染线程与JS引擎线程是互斥的，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。</li></ul></li><li><p>事件触发线程</p><ul><li>归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）</li><li>当JS引擎执行代码块时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中</li><li>当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理</li><li>注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）</li></ul></li><li><p>定时触发器线程</p><ul><li>传说中的setInterval与setTimeout所在线程</li><li>浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）</li><li>因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）</li><li>注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。</li></ul></li><li><p>异步http请求线程</p><ul><li>在XMLHttpRequest在连接后是通过浏览器新开一个线程请求</li><li>将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。</li></ul></li></ul><p>再补充一张图：<br><img src="https://image-static.segmentfault.com/208/433/2084336019-5a65972413011"><br>（本文图片来源及上述描述均转自<a href="https://segmentfault.com/a/1190000012925872#articleHeader8" target="_blank" rel="noopener">这位大牛</a>）</p><p>通过以上可以看出虽然js本身是单线程的，但是浏览器内核中却有这么多的线程协助，那么自然可以实现异步。</p><h3 id="事件循环机制"><a href="#事件循环机制" class="headerlink" title="事件循环机制"></a>事件循环机制</h3><p>既然前面说到js是存在异步任务的，并且浏览器内核中存在这么多的线程，那么js的事件循环机制究竟是怎么样的呢。</p><p>js中存在同步任务以及异步任务</p><ul><li>同步任务在主线程中执行，形成一个<code>任务栈</code>  （进行最终处理的只有任务栈）</li><li>浏览器内核中存在的事件触发线程，这个线程控制一个 <code>任务队列</code>，当这些异步任务（比如像点击事件之类的）产生了结果（那些回调函数之类的），事件触发线程就会将这些结果放到 任务队列当中</li></ul><p>那么执行栈与任务队列之间有什么关系呢：</p><ul><li>所有的处理最终都是在任务栈中进行的，这是js的主线程。</li><li>所有的异步结果也就是任务队列中的任务最终也是要交给任务栈进行处理的。</li><li>当主线程空闲的时候就会主动去读取任务队列，并且执行任务队列中的可执行的任务。如此循环</li></ul><p>这张图片很形象：<br><img src="https://segmentfault.com/img/remote/1460000012925884?w=636&h=518"></p><p>大概理解可以是在主线程中的执行栈的运行过程中会根据页面中的内容会调用到一些异步任务，那么这些异步任务产生的结果就会有事件触发线程之类的线程提交到任务队列，然后当执行栈空闲的时候就会执行这些任务，这样形成一个循环，这就是我理解的事件循环机制。</p><h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>这里单独说一下定时器，其实我之所以会找这方面的资料也是因为我在使用定时器的时候遇到一些问题没有想明白，那么定时器其实是很特别的，因为定时器有一个独享的线程，就是<strong>定时器线程</strong>，之所以会有定时器线程是因为定时器需要一个定时的功能，很显然主线程如此的繁忙，交给主线程来定时是不够准确的，那么就由浏览器的一个单独的线程来定时，当达到定时器设定的时间时，<strong>定时器线程</strong>就会将要处理的特定的结果（也就是定时器的回调）推入到任务队列当中等待主线程执行。</p><h4 id="在W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。这里可以看一个例子："><a href="#在W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。这里可以看一个例子：" class="headerlink" title="在W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。这里可以看一个例子："></a>在W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。这里可以看一个例子：</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function () &#123;</span><br><span class="line">    console.log('这是定时器的内容');</span><br><span class="line">&#125;, 10)</span><br><span class="line">console.log('这是一句话');</span><br><span class="line">console.log('这是另一句话');</span><br><span class="line">console.log('这是又是一句话');</span><br></pre></td></tr></table></figure><p>这段代码的执行结果会是什么？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//这是一句话</span><br><span class="line">//这是另一句话</span><br><span class="line">//这是又是一句话</span><br><span class="line">//这是定时器的内容</span><br></pre></td></tr></table></figure></p><ul><li>这就是这段代码的执行结果，如果在我了解事件循环机制之前我可能会认为因为定时器时10ms之后触发，所以会在最后。</li><li>但是这里有一个问题，如果定时器后面的代码量非常多呢，执行的时间很长会怎么样，定时器中的内容还会是最后输出的吗。</li><li>但是现在通过事件循环机制我知道，无论后面的代码执行需要再长的时间，定时器的时间再短，也都是定时器最后执行，就是因为事件循环机制，因为只有当主线程空闲的时候才会去执行任务队列中的内容。</li></ul><h4 id="关于定时器的使用差别"><a href="#关于定时器的使用差别" class="headerlink" title="关于定时器的使用差别"></a>关于定时器的使用差别</h4><p>这里有一个问题，是直接使用<code>setInterval</code>还是利用<code>setTimeout</code>模拟，先来说说这二者之间的区别：</p><ul><li><p>在使用setTimeout模拟时，第二次以及之后再次开启的定时器是需要在上一次的setTimeout中的回调执行完毕之后才会再次开启，所以这之间是存在误差的，那么有多少的误差就取决于回调执行的时间。</p></li><li><p>如果是直接使用setInterval则不会有setTimeout那样的情况，setInterval的定时器开启是非常准时的，不需要等待回调执行完毕就会准时的再次开启，那么这样会产生一些问题，如果上一次的回调还没有执行完下一次就来了怎么办，或者是即使上一次的执行完了，但是用了较多的时间，中间的时间间隔就会变得非常短，导致代码连续运行。</p></li><li><p>当浏览器最小化的时候setInterval是不执行的，当窗口恢复的时候就会一次性全部执行。</p></li></ul><p>所以最好的解决办法是用setTimeout模拟setInterval或者用requestAnimationFrame。</p><blockquote><p>补充：JS高程中有提到，JS引擎会对setInterval进行优化，如果当前事件队列中有setInterval的回调，不会重复添加。不过，仍然是有很多问题</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过看大牛的文章受益颇多，大牛文章的内容我没有全部仔细看完，只琢磨了我现在暂时想知道的东西，等有时间把大牛文章中的东西全部弄明白。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://segmentfault.com/a/1190000012925872#articleHeader0" target="_blank" rel="noopener">撒网要见鱼：从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;这几天在学习过程中遇到一些问题，在找相关资料的情况下了解到js单线程和事件循环机制的一些知识，通过看一些大牛的文章，感觉又学习到了很多，对js有了更深的理解，这里来记录一下我学习完之后的一些理解。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于for循环中使用setTimeout</title>
    <link href="https://q32757468.github.io/2019/07/05/%E5%85%B3%E4%BA%8Efor%E5%BE%AA%E7%8E%AF%E4%B8%AD%E4%BD%BF%E7%94%A8setTimeout/"/>
    <id>https://q32757468.github.io/2019/07/05/关于for循环中使用setTimeout/</id>
    <published>2019-07-05T12:52:37.000Z</published>
    <updated>2019-07-07T13:40:03.942Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;今天本来打算学习es6,结果刚开始就遇到一个问题，关于for循环中使用 var 和 使用 let 所带来的差别，我为了详细弄懂其中的原理，就查资料，查到了很多关于这方面的知识，这次就来记录一下。<br><a id="more"></a></p></blockquote><h3 id="在for循环中使用setTimeout的问题"><a href="#在for循环中使用setTimeout的问题" class="headerlink" title="在for循环中使用setTimeout的问题"></a>在for循环中使用setTimeout的问题</h3><p>有时候我们会有这样的需求，就是在for循环中使用到setTimeout，但是不一定能够得到我们想要的结果，看这个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是10次10.</p><p>其实在这种情况下我想要的情况应该是输出从0-9，而不是十次10。</p><p>那么为什么会这样呢，我是这样理解的：</p><ul><li>首先 <code>setTimeout</code> 是异步执行的并且先要到任务队列中才会到执行栈中，所以 <code>setTimeout</code> 的回调一定是最后执行的。</li><li>在执行回调的时候会先在函数的局部作用域中去找 <code>i</code> 但是很显然是找不到的，然后会去全局作用域中找 <code>i</code>，这时就能找到，但是此时的<code>i</code>已经是<code>10</code>了，所以会输出10次10。</li></ul><h3 id="解决这个问题的多种方式"><a href="#解决这个问题的多种方式" class="headerlink" title="解决这个问题的多种方式"></a>解决这个问题的多种方式</h3><h4 id="使用-let"><a href="#使用-let" class="headerlink" title="使用 let"></a>使用 let</h4><p>在es6中可以使用<code>let</code>来声明块级变量，并且只在块级作用域中有效。来看看是如何解决这个问题的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台打印结果0-9</p><p>可以看出其实使用let很轻松的就将问题解决了，那么这是如何解决的呢？<br>我是这样理解的：</p><ul><li><p>首先 <code>setTimeout</code> 是异步执行的并且先要到任务队列中才会到执行栈中，所以 <code>setTimeout</code> 的回调一定是最后执行的。这些都是不变的。</p></li><li><p>但是区别在于由于使用了<code>let</code>来声明变量，所以在会在块级作用域中去找<code>i</code>，并且因为在每一次循环时都创建了一个不同的块级作用域（变量i不同），所以能够找到，并且按照顺序将<code>i</code>的值输出出来。</p></li></ul><h4 id="使用闭包"><a href="#使用闭包" class="headerlink" title="使用闭包"></a>使用闭包</h4><p>通过闭包也可以解决问题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(i);</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台打印结果0-9</p><p>那么闭包是如何解决的呢？<br>这是我的理解：</p><ul><li>首先 <code>setTimeout</code> 是异步执行的并且先要到任务队列中才会到执行栈中，所以 <code>setTimeout</code> 的回调一定是最后执行的。这些都是不变的。</li></ul><p>+在执行匿名函数的时候形成了闭包，会保持对<code>i</code>的引用，就导致在每次循环的过程中匿名函数的作用域中都会有当前<code>i</code>的值，所以当后面执行回调函数的时候就能够在匿名函数的作用域中找到对应的<code>i</code>的值。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这两天一直在看这方面的文章，感觉弄懂了很多这些方面的知识，继续加油。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;今天本来打算学习es6,结果刚开始就遇到一个问题，关于for循环中使用 var 和 使用 let 所带来的差别，我为了详细弄懂其中的原理，就查资料，查到了很多关于这方面的知识，这次就来记录一下。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>对于闭包函数的简单理解</title>
    <link href="https://q32757468.github.io/2019/07/05/%E5%AF%B9%E4%BA%8E%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0%E7%9A%84%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/"/>
    <id>https://q32757468.github.io/2019/07/05/对于闭包函数的简单理解/</id>
    <published>2019-07-05T04:04:50.000Z</published>
    <updated>2019-07-10T02:58:49.912Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;闭包是ECMAScript （JavaScript）最强大的特性之一，但用好闭包的前提是必须理解闭包。学习和理解闭包是十分必要的，这次我学习后对闭包的简单理解。<br><a id="more"></a></p></blockquote><h3 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h3><ul><li><p>什么是闭包，通过我的理解就是由于js的机制，外部函数无法使用内部函数的变量，但是内部函数可以使用外部函数的变量，当这样一个使用了外部函数的变量的内部函数在包含他的外部函数之外被调用了，那么就形成了闭包。</p></li><li><p>可以看出要形成闭包至少要这几个条件：</p><ul><li>至少两个函数，一个内部函数，一个嵌套在外部函数里面的内部函数</li><li>内部函数中使用了外部函数中的变量</li><li>在外部函数以外的地方调用了内部函数</li></ul></li><li><p>一个简单的闭包函数</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function a() &#123;</span><br><span class="line">    //外部函数中有一个变量</span><br><span class="line">    count = 1;</span><br><span class="line">    //将内部函数返回出去</span><br><span class="line">    return function () &#123;</span><br><span class="line">        //内部函数中使用了外部函数中的变量</span><br><span class="line">        count++;</span><br><span class="line">        console.log(count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//此时b指向的就是内部函数</span><br><span class="line">var b = a();</span><br><span class="line">//在全局中调用了b所指向的内部函数，所以变量 count 就会一直保存在全局AO中</span><br><span class="line">b();    //2</span><br><span class="line">//当再次调用的时候就会继续使用全局中没有被回收的变量 count </span><br><span class="line">b();    //3</span><br><span class="line">b();    //4</span><br></pre></td></tr></table></figure></li></ul><h3 id="闭包的用途"><a href="#闭包的用途" class="headerlink" title="闭包的用途"></a>闭包的用途</h3><p>可以通过上面的一个简单的闭包函数可以看到，当执行完函数之后，<code>count</code>的值并没有被释放，可以长久的保存并且不会污染全局变量。</p><h3 id="闭包的高级用法"><a href="#闭包的高级用法" class="headerlink" title="闭包的高级用法"></a>闭包的高级用法</h3><p>闭包通常可以配合匿名函数使用：</p><p>配合匿名立即执行函数使用就可以很轻松的将一个函数转化为闭包。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b;</span><br><span class="line">        (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> obj = &#123;</span><br><span class="line">                a() &#123;</span><br><span class="line">                    count++</span><br><span class="line">                    <span class="built_in">console</span>.log(count);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            b = obj;</span><br><span class="line">        &#125;)();</span><br><span class="line">        b.a();  <span class="comment">//2</span></span><br><span class="line">        b.a();  <span class="comment">//3</span></span><br><span class="line">        b.a();  <span class="comment">//4</span></span><br></pre></td></tr></table></figure><p>将最开始的例子改写以下，这样也是一个闭包，虽然没有返回值，但是最终还是通过对象来调用了内部的函数从而使用了外部函数的变量，实际上还是一个闭包。</p><p>还有一个闭包的例子参考我的另一篇博客<a href="https://q32757468.github.io/2019/07/05/%E5%85%B3%E4%BA%8Efor%E5%BE%AA%E7%8E%AF%E4%B8%AD%E4%BD%BF%E7%94%A8setTimeout/#more">关于for循环中使用setTimeout</a></p><h3 id="如何创建一个闭包"><a href="#如何创建一个闭包" class="headerlink" title="如何创建一个闭包"></a>如何创建一个闭包</h3><ul><li>定义外层函数，封装被保护的局部变量。</li><li>定义内层函数，执行对外部函数变量的操作。</li><li>外层函数返回内层函数的对象，并且外层函数被调用，结果保存在一个全局的变量中。（实际上不一定要返回内部函数，返回内部函数只是使内部函数在全局中被使用的一种方式）</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过这次的学习对闭包有了一定的了解，由于闭包不会释放外部函数变量，所以会一直消耗内存，所以闭包的使用有利有弊，合理的使用对开发有帮助的，需要在项目中多多使用，渐渐深入理解。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/onepixel/p/5062456.html" target="_blank" rel="noopener">让你分分钟理解 JavaScript 闭包</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;闭包是ECMAScript （JavaScript）最强大的特性之一，但用好闭包的前提是必须理解闭包。学习和理解闭包是十分必要的，这次我学习后对闭包的简单理解。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vue-js的学习（watch、computed的使用）</title>
    <link href="https://q32757468.github.io/2019/07/04/vue-js%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%88watch%E3%80%81computed%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%89/"/>
    <id>https://q32757468.github.io/2019/07/04/vue-js的学习（watch、computed的使用）/</id>
    <published>2019-07-04T02:04:56.000Z</published>
    <updated>2019-07-04T10:35:20.022Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这次来学习以下vue中的两个选项，watch和computed 这两个是用来监听数据的变化的，但是又有区别。以前我监听数据的变化都是通过原生js的 oninput或者是 keyup 事件来判断数据是否发生变化，但是很显然在vue中这样是不够哦高效的，那么在vue中正确使用 watch 和 computed 可以大大的提高我们的开发效率。<br><a id="more"></a></p></blockquote><h3 id="watch的使用"><a href="#watch的使用" class="headerlink" title="watch的使用"></a>watch的使用</h3><p>watch是vue实例中的一个选项，是一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。Vue 实例将会在实例化时调用 $watch()，遍历 watch 对象的每一个属性。</p><p>可以像这样使用：</p><ul><li>监听文本框数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; v-model=&quot;a&quot;&gt;+</span><br><span class="line">        &lt;input type=&quot;text&quot; v-model=&quot;b&quot;&gt;=</span><br><span class="line">        &lt;input type=&quot;text&quot; v-model=&quot;c&quot;&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script src=&quot;./../../js/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        var vm = new Vue(&#123;</span><br><span class="line">            el: &quot;#app&quot;,</span><br><span class="line">            data() &#123;</span><br><span class="line">                return &#123;</span><br><span class="line">                    a: &apos;&apos;,</span><br><span class="line">                    b: &apos;&apos;,</span><br><span class="line">                    c: &apos;&apos;,</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            methods: &#123;</span><br><span class="line">                watchAB() &#123;</span><br><span class="line">                    this.c = this.a + &apos;-&apos; + this.b;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            watch: &#123;</span><br><span class="line">                // 可以直接写函数，直接写函数的话可以有两个参数，一个是改变之前的值，一个是改变之后的值</span><br><span class="line">                // a: function (newVal, oldVal) &#123;</span><br><span class="line">                //     this.c = newVal + &apos;-&apos; + this.b</span><br><span class="line">                // &#125;,</span><br><span class="line">                // b: function (newVal, oldVal) &#123;</span><br><span class="line">                //     this.c = this.a + &apos;-&apos; + newVal</span><br><span class="line">                // &#125;,</span><br><span class="line"></span><br><span class="line">                // 也可以直接调用已经有的方法，但是不能向上面一样有两个参数</span><br><span class="line">                a: &quot;watchAB&quot;,</span><br><span class="line">                b: &quot;watchAB&quot;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><ul><li>监听路径变化<ul><li>watch不仅仅能够监听文本框的数据变化，它能够监听到vue中一切数据的变化，十分的强大</li><li>例如监听路径的变化：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//这里可以不用加this</span><br><span class="line">&quot;$route.fullPath&quot;: function (newVal, oldVal) &#123;</span><br><span class="line">    //这里用path或者是fullPath来判断都可以，但是要注意大小写</span><br><span class="line">    if (newVal == &quot;/test&quot;) &#123;</span><br><span class="line">        alert(&apos;跳转到了test组件&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><blockquote><p>注意，不应该使用箭头函数来定义 watcher 函数,理由是箭头函数绑定了父级作用域的上下文，所以 this 将不会按照期望指向 Vue 实例</p></blockquote><h3 id="computed的使用"><a href="#computed的使用" class="headerlink" title="computed的使用"></a>computed的使用</h3><p>同样一个例子我们也可以使用 computed 来完成，我们也可以看出他们之间的区别。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; v-model=&quot;a&quot;&gt;+</span><br><span class="line">        &lt;input type=&quot;text&quot; v-model=&quot;b&quot;&gt;=</span><br><span class="line">        &lt;input type=&quot;text&quot; v-model=&quot;c&quot;&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script src=&quot;./../../js/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;./../../js/vue-router.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        var vm = new Vue(&#123;</span><br><span class="line">            el: &quot;#app&quot;,</span><br><span class="line">            data() &#123;</span><br><span class="line">                return &#123;</span><br><span class="line">                    a: &apos;&apos;,</span><br><span class="line">                    b: &apos;&apos;,</span><br><span class="line">                    //这里不再需要对c进行定义</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            methods: &#123;</span><br><span class="line"></span><br><span class="line">            &#125;,</span><br><span class="line">            computed: &#123;</span><br><span class="line">                // 如果在computed中要对某个数据进行监听计算，那么这个数据需要放到computed中来进行定义</span><br><span class="line">                c: function () &#123;</span><br><span class="line">                    // 然后还需要将我们需要的结果返回出去</span><br><span class="line">                    return this.a + &quot;-&quot; + this.b</span><br><span class="line">                &#125; //并且这个结果还会被缓存，但我们再次调用这个结果的时候并不会再次重新计算，而是单纯的重新调用，除非结果发生了变化。</span><br><span class="line">            &#125;,</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在vue中虽然也可以使用事件来监听数据的改变，但是在大部分情况下使用vue中的 watch 和 computed 会更加的适合vue并且有更高的效率。在合适的场景正确的使用这两个选项可以很大程度上的提高我们的开发效率，要合理使用。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;这次来学习以下vue中的两个选项，watch和computed 这两个是用来监听数据的变化的，但是又有区别。以前我监听数据的变化都是通过原生js的 oninput或者是 keyup 事件来判断数据是否发生变化，但是很显然在vue中这样是不够哦高效的，那么在vue中正确使用 watch 和 computed 可以大大的提高我们的开发效率。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vue-js的学习（路由的学习与使用）</title>
    <link href="https://q32757468.github.io/2019/07/02/vue-js%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%88%E8%B7%AF%E7%94%B1%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%89/"/>
    <id>https://q32757468.github.io/2019/07/02/vue-js的学习（路由的学习与使用）/</id>
    <published>2019-07-02T10:07:13.000Z</published>
    <updated>2019-07-04T01:36:28.289Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这次来学习vue中的路由，那么什么是前端路由，前端路由就是在单页面中通过url地址的hash来进行单页面的跳转的，而且并不会重新请求页面，这就是前端路由，一般都是通过 # 来实现的。这次来具体学习以下vue-router这个库来实现vue中的路由功能。<br><a id="more"></a></p></blockquote><h3 id="如何使用vue-router"><a href="#如何使用vue-router" class="headerlink" title="如何使用vue-router"></a>如何使用vue-router</h3><h4 id="首先是要引入vue-router包"><a href="#首先是要引入vue-router包" class="headerlink" title="首先是要引入vue-router包"></a>首先是要引入vue-router包</h4><p>那么，其实引入的方式有很多种，可以直接下载到本地引入，也可以使用npm之类的，具体可以看官方网站的介绍<a href="https://router.vuejs.org/zh/installation.html" target="_blank" rel="noopener">介绍</a>。</p><h4 id="创建一个组件构造器"><a href="#创建一个组件构造器" class="headerlink" title="创建一个组件构造器"></a>创建一个组件构造器</h4><p>这里要注意的是这里创建的不是一个组件，而是一个构造器，虽然路由是在不同的组件之间进行切换，但是这里先是创建构造器，也就是通过<code>Vue.extend</code>来创建构造器，最后通过路由router将构造器注册成为组件。就像下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var login=Vue.extend(&#123;</span><br><span class="line">      template: &apos;&lt;h1&gt;登录组件&lt;/h1&gt;&apos;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>可以看出这就是我们在学习前面的创建组件的时候的创建构造器的方式，所以这个也可以简写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var register=&#123;</span><br><span class="line">      template: &apos;&lt;h1&gt;注册组件&lt;/h1&gt;&apos;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></p><p>直接用一个对象来表示构造器。而构造其中的模板就是我们之后路由组件中的内容。</p><h4 id="通过VueRouter来创建路由实例及定义路由规则"><a href="#通过VueRouter来创建路由实例及定义路由规则" class="headerlink" title="通过VueRouter来创建路由实例及定义路由规则"></a>通过VueRouter来创建路由实例及定义路由规则</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const router = new VueRouter(&#123;      //创建一个路由对象</span><br><span class="line">    routes: [&#123;                      //routes的意思就是道路的意思，这个数组里面就放我们所要定义的路由规则</span><br><span class="line">                                 //这个数组里面用对象来表示每个路由规则，两个对象就是两条路由规则</span><br><span class="line">            path: '/login',     //对象里面的path表示路由的地址</span><br><span class="line">            component: login    //component表示对应的路由组件</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            path: '/register',</span><br><span class="line">            component: register</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>这里要注意的是这里的routes是一个数组，写的时候不要写错了。</p></blockquote><h4 id="挂在到vue实例中"><a href="#挂在到vue实例中" class="headerlink" title="挂在到vue实例中"></a>挂在到vue实例中</h4><p>在实例中挂载过来路由规则才会生效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">      el: &apos;#app&apos;,</span><br><span class="line">      router: router // 使用 router 属性来使用路由规则,可以直接简写成一个router，因为键和值都是一样的。</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h4 id="使用-router-link-来对路由组件进行导航"><a href="#使用-router-link-来对路由组件进行导航" class="headerlink" title="使用 router-link 来对路由组件进行导航"></a>使用 router-link 来对路由组件进行导航</h4><p>其实可以通过HTML本身自带的 a 标签来设置url地址来设置hash来实现导航跳转的目的，但是在vue-router中也提供了进行导航的方式，并且更加的实用。<br>就是使用 router-link ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;router-link to=&quot;/login&quot;&gt;登录&lt;/router-link&gt;</span><br><span class="line">    &lt;router-link to=&quot;/register&quot;&gt;注册&lt;/router-link&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>router-link标签默认在页面上是渲染成 a 标签的，同样，这个也可以通过 <code>tag</code>  属性来进行修改。</p><h4 id="使用-router-view-将路由组件挂载到页面中"><a href="#使用-router-view-将路由组件挂载到页面中" class="headerlink" title="使用 router-view 将路由组件挂载到页面中"></a>使用 router-view 将路由组件挂载到页面中</h4><p>前面都只是创建路由组件，但是创建好了没有放到页面里面去也相当于没有什么用，这里就需要通过 router-view 标签将前面定义过的路由组件放到页面中去。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 默认一个 router-view 只会显示一条平级的路由规则 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>要注意的一件事情是一个 router-view 默认只显示当前url地址匹配到的路由组件的内容，如果没有匹配到那么就不会显示出来，比如前面都没有设置根路径的路由那么页面初始的状态下是什么都不会显示的，只有在路由切换到相应的地址的时候才会有显示。</p></blockquote><h3 id="设置路由重定向"><a href="#设置路由重定向" class="headerlink" title="设置路由重定向"></a>设置路由重定向</h3><p>在很多时候我们需要将一个路由地址可以对应多种路径，比如让上面的页面在根路径下默认显示 login 那么这个时候就需要使用路由重定向来将根路径重定向到 login<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path: &apos;/&apos;,</span><br><span class="line">    //这里要注意的是这里redirect后面跟的是重定向的路径</span><br><span class="line">    redirect: &apos;/login&apos; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们只需要给我们需要重定向的路径添加一条路由规则并且给它重定向到我们想要的路径就可以了。</p><h3 id="设置路由链接激活样式"><a href="#设置路由链接激活样式" class="headerlink" title="设置路由链接激活样式"></a>设置路由链接激活样式</h3><p>有时候我们需要给当前所在位置的 router-link 设置高亮，那么这个时候我们就可以通过给 <code>router-link-active</code>这个类设置样式来实现我们想要的效果，因为我们每次切换路由vue每次都会自动的将这个类放到当前所在的 router-link 上，所以只需要修改这个类的样式就可以了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    .router-link-active &#123;</span><br><span class="line">        color: red;</span><br><span class="line">        font-size: 20px;</span><br><span class="line">        background-color: aqua;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p><img src="http://m.qpic.cn/psb?/V131x4904WMIoW/T*wp.OVMRn7cJA0qmNP*P6Z6JqkexmQw0C4wpB85sMg!/b/dDABAAAAAAAA&bo=AQOoAQAAAAADB4k!&rf=viewer_4"></p><p>可以看出这个样式成功应用上去了。</p><p>当然，这个类的名称是可以自定义修改的，我们只需要在创建路由对象的时候设置 <code>linkActiveClass</code>就可以来全局配置这个链接激活状态的类名。<br>就像这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    <span class="comment">// 这里设置链接激活的类</span></span><br><span class="line">    linkActiveClass: <span class="string">'myclass'</span>,     <span class="comment">//设置过后就需要通过修改我们自定义的类来设置链接激活样式了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里设置路由规则</span></span><br><span class="line">    routes: [&#123;</span><br><span class="line">            path: <span class="string">'/'</span>,</span><br><span class="line">            redirect: <span class="string">'/login'</span> </span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            path: <span class="string">'/login'</span>,</span><br><span class="line">            component: login</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            path: <span class="string">'/register'</span>,</span><br><span class="line">            component: register</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="设置路由组件切换动时画效果"><a href="#设置路由组件切换动时画效果" class="headerlink" title="设置路由组件切换动时画效果"></a>设置路由组件切换动时画效果</h3><p>设置路由组件间的动画切换效果也很简单，只需要将 <code>router-view</code>标签 放进动画的 <code>transition</code>标签里面并且设置动画的两组类（或者直接用第三方的库）就可以了。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line">    <span class="selector-class">.myclass</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: red;</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">        <span class="attribute">background-color</span>: aqua;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-class">.v-enter</span>,</span><br><span class="line">    <span class="selector-class">.v-leave-to</span> &#123;</span><br><span class="line">        <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">translateX</span>(150px);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-class">.v-enter-active</span>,</span><br><span class="line">    <span class="selector-class">.v-leave-active</span> &#123;</span><br><span class="line">        <span class="attribute">transition</span>: all <span class="number">1s</span> ease;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span> <span class="attr">mode</span>=<span class="string">"out-in"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过这样的设置就可以使组件在切换的时候拥有动画效果了。</p><h3 id="路由嵌套"><a href="#路由嵌套" class="headerlink" title="路由嵌套"></a>路由嵌套</h3><p>假如如有组件中还嵌套有路由,那么要实现一层一层的显示路由就要用到路由嵌套，在需要嵌套的路由规则中通过 <code>children</code> 来实现路由嵌套。</p><ul><li><p>首先是在一个路由构造器中嵌套有子路由</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/login"</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/register"</span>&gt;</span>注册<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transition</span> <span class="attr">mode</span>=<span class="string">"out-in"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"test"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是登录组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/login/son"</span>&gt;</span>点这里切换到子组件<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>然后是定义了子路由,并且将其嵌套在父级的路由规则中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> son = &#123;</span><br><span class="line">    template: <span class="string">"&lt;h1&gt;这是嵌套在里面的子组件&lt;/h1&gt;"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    linkActiveClass: <span class="string">'myclass'</span>,</span><br><span class="line">    routes: [&#123;</span><br><span class="line">            path: <span class="string">'/'</span>,</span><br><span class="line">            redirect: <span class="string">'/login'</span> <span class="comment">//这里要注意的是这里redirect后面跟的是重定向的路径</span></span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            path: <span class="string">'/login'</span>,</span><br><span class="line">            component: login,</span><br><span class="line">            <span class="comment">// children是父组件规则中的一个属性的值，并且这是一个数组，这个数组里面放的就是子路由的路径规则，相当于是在一条路由规则里面来定义新的路由规则</span></span><br><span class="line">            children: [</span><br><span class="line">                <span class="comment">// 这里一样可以写很多条的子路由规则</span></span><br><span class="line">                &#123;</span><br><span class="line">                    path: <span class="string">'son'</span>,  <span class="comment">//这里使用的相对路径</span></span><br><span class="line">                    component: son</span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            path: <span class="string">'/register'</span>,</span><br><span class="line">            component: register</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>这里要注意的一点是子路由中的路由规则中的路径使用的是相对路径，并且是相对于父级路由的相对路径，如果使用的是从根路径开始的绝对路径，那么就只会显示子路由中的内容，就不会显示父级路由中的内容。</p></blockquote><ul><li>这里也可以看到效果，当我们切换到子路由，显示了从父级路由开始的路由组件：<br><img src="http://m.qpic.cn/psb?/V131x4904WMIoW/6hUG*9YVk7hmAeE59TRW.VwtRkvFbw21GYJYweNhOzo!/b/dL8AAAAAAAAA&bo=dgQMAgAAAAADB14!&rf=viewer_4"></li></ul><h3 id="路由参数的传递及获取的两种方式"><a href="#路由参数的传递及获取的两种方式" class="headerlink" title="路由参数的传递及获取的两种方式"></a>路由参数的传递及获取的两种方式</h3><p>我们经常会有需求在url地址中传递参数，那么在vue中拿到参数以及获取参数的方式有两种：</p><h4 id="第一种，通过query"><a href="#第一种，通过query" class="headerlink" title="第一种，通过query"></a>第一种，通过query</h4><p>传递参数的方式像是在学php时用get方式传递数据时使用的方法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/login?id=1&amp;name=csz"</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure><p>获取参数的方法：</p><ul><li><p>首先我们要知道在我们创建的vue实例中有一个$route属性，这个属性中就包含了我们的路由信息，通过展开这个属性，我们可以发现有一个 query 属性，而这个属性是一个对象，包含了我们通过查询字符串所传递的参数，我们就可以通过调用这个对象来拿到我们的参数。<br><img src="http://m.qpic.cn/psb?/V131x4904WMIoW/gRrhsGcI.*0vtKmQ59Vuz4G8xc3xaZR5uigGv20OQs0!/b/dFIBAAAAAAAA&bo=EwQkAQAAAAADBxA!&rf=viewer_4"></p></li><li><p>通过这种方式我们可以很轻松的拿到我们想要的参数并且使用它</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;这是登录组件---&#123;&#123;this.$route.query.id&#125;&#125;&lt;/h1&gt;</span><br></pre></td></tr></table></figure></li></ul><p>那么此时当我们切换到登录组件的时候就还会额外显示我们传递的id参数了。</p><h4 id="第二种，通过params"><a href="#第二种，通过params" class="headerlink" title="第二种，通过params"></a>第二种，通过params</h4><p>这种方式与query有很明显的区别：</p><ul><li><p>首先是传递参数的方式有所区别</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link to=&quot;/register/2/csz2&quot;&gt;注册&lt;/router-link&gt;</span><br></pre></td></tr></table></figure><ul><li>可以看出这里在url地址上只设置了参数的值，并没有对参数设置名称。</li><li>参数的名称还需要在设置路由路径的时候进行设置：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        path: &apos;/register/:id/:name&apos;,</span><br><span class="line">        component: register</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>通过这种方式也能实现一样的效果，并且拿到参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;这是注册组件---&#123;&#123;this.$route.params.id&#125;&#125;&lt;/h1&gt;</span><br></pre></td></tr></table></figure></li></ul><p>也可以成功拿到我们想要的值。</p><h3 id="命名视图"><a href="#命名视图" class="headerlink" title="命名视图"></a>命名视图</h3><p>在有些场景我们希望同时展示多个视图，也就是多个 <code>&lt;router-view&gt;&lt;/router-view&gt;</code> ，但是默认情况下我们在页面中使用多个 <router-view></router-view> 的话也不会显示多个视图，那么这个时候我们就需要通过对视图来进行命名来显示我们想要的视图了。</p><h4 id="首先是对视图进行命名"><a href="#首先是对视图进行命名" class="headerlink" title="首先是对视图进行命名"></a>首先是对视图进行命名</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrap"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">router-view</span> <span class="attr">name</span>=<span class="string">"left"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">router-view</span> <span class="attr">name</span>=<span class="string">"right"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>只要对视图进行了命名就可以指定这个视图显示什么路由组件了。</p><h4 id="创建构造器以及创建路由实例"><a href="#创建构造器以及创建路由实例" class="headerlink" title="创建构造器以及创建路由实例"></a>创建构造器以及创建路由实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var top1 = &#123; //这里还有一个大问题，一个bug，就是组件构造器的名字不能够使用 top 否则直接会找不到这个构造器从而报错</span><br><span class="line">    template: &apos;&lt;h3 class=&quot;top1&quot;&gt;这是上边部分&lt;/h3&gt;&apos;</span><br><span class="line">&#125;</span><br><span class="line">var left = &#123;</span><br><span class="line">    template: &apos;&lt;h3 class=&quot;left&quot;&gt;这是左边部分&lt;/h3&gt;&apos;</span><br><span class="line">&#125;</span><br><span class="line">var right = &#123;</span><br><span class="line">    template: &apos;&lt;h3 class=&quot;right&quot;&gt;这是右边部分&lt;/h3&gt;&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">    routes: [&#123;</span><br><span class="line">        path: &apos;/&apos;,</span><br><span class="line">        components: &#123;       //这里使用的是components而不是component</span><br><span class="line">            default: top1, //没有设置name的默认就是用default</span><br><span class="line">            right,</span><br><span class="line">            left,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>需要在同一级路径显示多个路由组件就需要在配置这条路径的路由规则的时候使用  <code>components</code> 来配置显示的路由组件，这里面是一个对象，是 视图  <code>name:构造器名字</code> 的这种形式，对于没有命名的视图则使用 default 来进行配置。</p><p><img src="http://m.qpic.cn/psb?/V131x4904WMIoW/8yPBUkHvZsoDoT*Gz01W2KTd5fihtXgxL0GqK9iFORU!/b/dL8AAAAAAAAA&bo=gAcSBAAAAAADB7M!&rf=viewer_4"></p><blockquote><p>这里要注意的是这里因为配置的是多个路由组件，所以使用的是 components 而不是前面只显示单个组件时的 component。</p></blockquote><p>这里我发现一个vue中的bug，起初我在定义三个路由组件的构造器的时候使用了 top left right 这三个名字，最后在页面中查看，只显示了后面两个组件，然后控制台报了一个错误，说有一个组件没有定义，然后我猜想是不是定义top的时候哪里写错了，后面发现并不是，后面我只能猜测难道是因为名字的问题？然后我改了一个名字，果真是名字的问题。这里值得注意以下。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这是是对vue router学习的一些笔记，有一些问题需要注意</p><ul><li><p>两种方式都可以传递参数并且获取到参数，但是二者有明显的区别，要注意区分，使用哪种方式看个人习惯就好了，我比较习惯于使用query来传递和获取参数。</p></li><li><p>在命名视图的时候有一个bug，要多注意，以后对组件命名尽量不要使用 top 这个名字来命名。 </p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;这次来学习vue中的路由，那么什么是前端路由，前端路由就是在单页面中通过url地址的hash来进行单页面的跳转的，而且并不会重新请求页面，这就是前端路由，一般都是通过 # 来实现的。这次来具体学习以下vue-router这个库来实现vue中的路由功能。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vue-js的学习（ref的学习）</title>
    <link href="https://q32757468.github.io/2019/07/02/vue-js%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%88ref%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%89/"/>
    <id>https://q32757468.github.io/2019/07/02/vue-js的学习（ref的学习）/</id>
    <published>2019-07-02T03:10:09.000Z</published>
    <updated>2019-07-02T03:35:25.528Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在vue中是不提倡操作dom元素的,但是很多时候还是需要去操作dom元素的,那么这个时候该如何去获取dom元素,并且对他进行操作呢,如果直接通过原生js的各种选择器来操作的话其实也行,用jQuery也可以,但是在vue中都不提倡这样操作,其实我们就可以通过vue中的ref来获取以及操作dom元素.<br><a id="more"></a></p></blockquote><h3 id="来看一个简单的例子"><a href="#来看一个简单的例子" class="headerlink" title="来看一个简单的例子"></a>来看一个简单的例子</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"test"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- ref就像是一个id一样可以设置在元素身上，也可以设置在组件的引用标签上 --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 设置在dom元素上那么在vue中拿到的就是dom元素原生对象 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h1</span> <span class="attr">ref</span>=<span class="string">"test"</span>&gt;</span>这是vue实例中的一句话<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"myalert"</span>&gt;</span>点击我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"myalert2"</span>&gt;</span>点击我2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 如果设置在组件的引用标签上拿到的就是一个vue实例的对象 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">test</span> <span class="attr">ref</span>=<span class="string">"test2"</span>&gt;</span><span class="tag">&lt;/<span class="name">test</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./../../js/vue.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el: <span class="string">"#app"</span>,</span></span><br><span class="line"><span class="undefined">            data() &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">                &#125;</span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="undefined">            methods: &#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">// 可以成功对一个原生的dom对象进行了操作,输出了它里面的文本</span></span></span><br><span class="line"><span class="undefined">                myalert() &#123;</span></span><br><span class="line"><span class="javascript">                    alert(<span class="keyword">this</span>.$refs.test.innerText);</span></span><br><span class="line"><span class="undefined">                &#125;,</span></span><br><span class="line"><span class="javascript">                <span class="comment">// 成功的对一个vue实例对象进行了操作，输出了它里面的属性</span></span></span><br><span class="line"><span class="undefined">                myalert2() &#123;</span></span><br><span class="line"><span class="javascript">                    alert(<span class="keyword">this</span>.$refs.test2.mgs);</span></span><br><span class="line"><span class="undefined">                &#125;</span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="undefined">            components: &#123;</span></span><br><span class="line"><span class="undefined">                test: &#123;</span></span><br><span class="line"><span class="xml">                    template: "<span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是一个子组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>",</span></span><br><span class="line"><span class="undefined">                    data() &#123;</span></span><br><span class="line"><span class="javascript">                        <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">                            mgs: <span class="string">'这是子组件中的一句话'</span>,</span></span><br><span class="line"><span class="undefined">                        &#125;</span></span><br><span class="line"><span class="undefined">                    &#125;,</span></span><br><span class="line"><span class="undefined">                &#125;</span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">        &#125;)</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过以上例子我们就可以看出:</p><ul><li><p>通过在标签上设置ref来注册<code>$refs</code>对象</p></li><li><p>注册在组件引用标签上与注册在dom元素上是有差别的,如果是注册在组件上那么拿到的就是一个组件实例,如果注册在dom元素上拿到的就是一个原生的dom对象.</p></li><li><p>可以通过给子组件注册ref来获取到子组件中的属性以及方法并进行操作.</p></li></ul><p><img src="http://m.qpic.cn/psb?/V131x4904WMIoW/udRf.GDUfo.MCwlGajd42SwgHrKsEJ0QfsqWaf7W81M!/b/dL4AAAAAAAAA&bo=sQRxAQAAAAADB.c!&rf=viewer_4"></p><p>通过在控制台中的查看我们也可以看出$refs是一个对象,里面保存了注册了ref的dom对象或者组件实例.</p><blockquote><p>注意是通过<code>this.$refs</code>来使用,s不能漏了,因为里面可以保存许多的内容.</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>ref的使用比较简单,但是感觉作用很强大,以后开发要灵活运用.</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在vue中是不提倡操作dom元素的,但是很多时候还是需要去操作dom元素的,那么这个时候该如何去获取dom元素,并且对他进行操作呢,如果直接通过原生js的各种选择器来操作的话其实也行,用jQuery也可以,但是在vue中都不提倡这样操作,其实我们就可以通过vue中的ref来获取以及操作dom元素.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vue.js的学习（向子组件传递属性以及方法）</title>
    <link href="https://q32757468.github.io/2019/07/01/vue-js%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%90%91%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BC%A0%E9%80%92%E5%B1%9E%E6%80%A7%E4%BB%A5%E5%8F%8A%E6%96%B9%E6%B3%95%EF%BC%89/"/>
    <id>https://q32757468.github.io/2019/07/01/vue-js的学习（向子组件传递属性以及方法）/</id>
    <published>2019-07-01T09:46:37.000Z</published>
    <updated>2019-07-01T14:41:13.259Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前面学习了创建组件的几种方式，那么这次来学习以下父组件如何向子组件传递属性以及方法，，因为父组件只能使用父组件中的值和方法，子组件也是一样，那么有时子组件就需要用到父组件的方法该如何做呢，我发现虽然父组件无法获取到子组件内部的东西，但是子组件和父组件其实是有交叉的地方的，也就是在页面中引用子组件的那个标签，那么vue中就是通过这个标签作为中间桥梁来给子组件传递属性的，那么来试一试。<br><a id="more"></a></p></blockquote><h3 id="向子组件传递属性"><a href="#向子组件传递属性" class="headerlink" title="向子组件传递属性"></a>向子组件传递属性</h3><p>向子组件传递属性值主要给组件的引用标签绑定一个中间值来实现，下面是一个例子：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 创建好一个子组件 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 我们可以通过test这个桥梁来传递父组件的属性，这个属性只需要绑定在这个标签上面就好了 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">test</span> <span class="attr">:pmsg</span>=<span class="string">'msg'</span>&gt;</span><span class="tag">&lt;/<span class="name">test</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"test"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是子组件---&#123;&#123;pmsg&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./../../js/vue.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        Vue.component(<span class="string">'test'</span>, &#123;</span></span><br><span class="line"><span class="javascript">            template: <span class="string">'#test'</span>,</span></span><br><span class="line"><span class="undefined">            data() &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> &#123;&#125;</span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 然后通过props来拿到绑定的属性</span></span></span><br><span class="line"><span class="javascript">            props: [<span class="string">'pmsg'</span>], <span class="comment">//注意props是一个只读不可写的数组</span></span></span><br><span class="line"><span class="undefined">        &#125;)</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el: <span class="string">"#app"</span>,</span></span><br><span class="line"><span class="undefined">            data() &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">                    msg: <span class="string">'这是父组件中的一句话'</span>,</span></span><br><span class="line"><span class="undefined">                &#125;</span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="undefined">        &#125;)</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p><blockquote><p>要注意的一件事情是props是一个只读不可写的数组</p></blockquote><p><img src="http://m.qpic.cn/psb?/V131x4904WMIoW/xGjaqlSBIzLiRLeW9HraUqS5GhBkqpwL.hP60gLb6eo!/b/dL4AAAAAAAAA&bo=CwN6AQAAAAADB1E!&rf=viewer_4"><br>可以看出子组件成功拿到了父组件的变量并且将其渲染到页面中。</p><h3 id="子组件触发父组件的方法"><a href="#子组件触发父组件的方法" class="headerlink" title="子组件触发父组件的方法"></a>子组件触发父组件的方法</h3><p>子组件既然可以获取到父组件的属性，那么也可以触发到父组件的方法，触发的方式与获取父组件的属性的方式类似。<br>下面看演示：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 创建好一个子组件 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 我们可以通过test这个桥梁来传递父组件的方法，这个属性只方法绑定在这个标签上面就好了 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">test</span> @<span class="attr">sonalert</span>=<span class="string">"myalert"</span>&gt;</span><span class="tag">&lt;/<span class="name">test</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"test"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h2</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"myclick"</span>&gt;</span>单击我<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./../../js/vue.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        Vue.component(<span class="string">'test'</span>, &#123;</span></span><br><span class="line"><span class="javascript">            template: <span class="string">'#test'</span>,</span></span><br><span class="line"><span class="undefined">            data() &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">                    msg: <span class="string">'这是子组件中的一句话'</span>,</span></span><br><span class="line"><span class="undefined">                &#125;</span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="undefined">            methods: &#123;</span></span><br><span class="line"><span class="undefined">                myclick() &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="comment">// emit英文的意思就是触发的意思，这里就可以通过emit来触发前面绑定过的方法，并且后面的参数是作为要触发的方法的参数</span></span></span><br><span class="line"><span class="javascript">                    <span class="keyword">this</span>.$emit(<span class="string">'sonalert'</span>, <span class="keyword">this</span>.msg)</span></span><br><span class="line"><span class="undefined">                &#125;</span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="undefined">        &#125;)</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el: <span class="string">"#app"</span>,</span></span><br><span class="line"><span class="undefined">            data() &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">                    msg: <span class="string">'这是父组件中的一句话'</span>,</span></span><br><span class="line"><span class="undefined">                &#125;</span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="undefined">            methods: &#123;</span></span><br><span class="line"><span class="undefined">                myalert(str) &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="comment">// 最终执行出来的结果这里的this.msg使父组件中的</span></span></span><br><span class="line"><span class="javascript">                    alert(<span class="keyword">this</span>.msg + str);</span></span><br><span class="line"><span class="undefined">                &#125;</span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="undefined">        &#125;)</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>可以看出传递方法的方式与传递属性的方式类似，都是将要传递的东西绑定在引用标签上，只不过绑定方法是用<code>@</code>来绑定，调用的方法也有区别，是用<code>this.$emit(&#39;sonalert&#39;, this.msg)</code>这种方式来触发。</p><p><img src="http://m.qpic.cn/psb?/V131x4904WMIoW/7PE.j8CxBZEBE1Ys4JBrRJaurnXCzXSusP*diYpnBuc!/b/dMMAAAAAAAAA&amp;bo=GQbIAQAAAAADB*Q!&amp;rf=viewer_4" alt="调用成功"></p><blockquote><p>还有要注意的两点是</p><ul><li>通过上面的例子我们也可以看出，虽然这个传递过来的方法是在子组件中执行的，但是实际的执行者是父组件，相当于是通过让子组件来使父组件执行它自己的方法。</li><li>可以通过这种方式来给父组件传递参数，通过上面的例子我们也可以看出，我们在子组件中触发父组件的方法的时候传递了参数，而在方法执行的时候也把子组件传递的参数当作方法的参数执行了。</li></ul></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>灵活运用好父子组件之间传值或者传递方法对开发有很大的帮助，这也是我必须学习的，通过这一些的小demo也算是把这俩搞清楚了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;前面学习了创建组件的几种方式，那么这次来学习以下父组件如何向子组件传递属性以及方法，，因为父组件只能使用父组件中的值和方法，子组件也是一样，那么有时子组件就需要用到父组件的方法该如何做呢，我发现虽然父组件无法获取到子组件内部的东西，但是子组件和父组件其实是有交叉的地方的，也就是在页面中引用子组件的那个标签，那么vue中就是通过这个标签作为中间桥梁来给子组件传递属性的，那么来试一试。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vue.js的学习（创建组件的三种方式以及一些问题）</title>
    <link href="https://q32757468.github.io/2019/07/01/vue-js%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%88%9B%E5%BB%BA%E7%BB%84%E4%BB%B6%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%89/"/>
    <id>https://q32757468.github.io/2019/07/01/vue-js的学习（创建组件的三种方式）/</id>
    <published>2019-07-01T08:37:40.000Z</published>
    <updated>2019-07-01T10:12:36.048Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;学习vue也有一段时间了，前面学习了vue中的一些基础的只是，由于期末的原因忙于期末作业就暂停了vue的学习，现在放假了，有时间了就继续学习vue，今天来学习以下vue中的组件，我们都知道其实vue是组件化开发，运用好组件可以大大的提高我们开发的效率。<br><a id="more"></a></p></blockquote><h3 id="创建组件的三种方式"><a href="#创建组件的三种方式" class="headerlink" title="创建组件的三种方式"></a>创建组件的三种方式</h3><h4 id="使用extend来创建组件"><a href="#使用extend来创建组件" class="headerlink" title="使用extend来创建组件"></a>使用extend来创建组件</h4><p>vue中的extend可以创建一个组件构造器，注意这个创建的不是组件，而是组件构造器，还要通过component注册之后才是组件实例，下面是演示：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ext = Vue.extend(&#123;</span><br><span class="line">            template: <span class="string">"&lt;p&gt;这是一段文字&lt;/p&gt;"</span></span><br><span class="line">        &#125;)</span><br><span class="line"><span class="comment">//component方法有两个参数，第一个参数就是将来我们组件在html中的标签名，就是我们要以什么标签名去将组件应用到网页中，第二个参数就是一个构造器，这个构造器中的template就是我们的组件的模板。</span></span><br><span class="line">Vue.component(<span class="string">'test'</span>, ext);</span><br></pre></td></tr></table></figure></p><p>也可以直接这样写：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'test'</span>, Vue.extend(&#123;</span><br><span class="line">            template: <span class="string">"&lt;p&gt;这是一段文字&lt;/p&gt;"</span></span><br><span class="line">        &#125;));</span><br></pre></td></tr></table></figure></p><p>这样写会更加的简便一些。</p><h4 id="省略extend"><a href="#省略extend" class="headerlink" title="省略extend"></a>省略extend</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'test'</span>, &#123;</span><br><span class="line">            template: <span class="string">"&lt;p&gt;这是一段文字&lt;/p&gt;"</span></span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>vue中也可以将extend省略掉，来创建组件，这样会更加的方便一些</p><h4 id="在html中书写模板"><a href="#在html中书写模板" class="headerlink" title="在html中书写模板"></a>在html中书写模板</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">test</span>&gt;</span><span class="tag">&lt;/<span class="name">test</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 在html中在template标签中书写模板，然后通过id值或者类名在component引用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"tem"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一段文字<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./../../js/vue.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        Vue.component(<span class="string">'test'</span>, &#123;</span></span><br><span class="line"><span class="javascript">            template: <span class="string">"#tem"</span></span></span><br><span class="line"><span class="undefined">        &#125;);</span></span><br></pre></td></tr></table></figure><p>通过这种方式来创建组件有一个最大的优势就是因为模板中的代码不是在字符串中书写的，而是在html中书写的，所以书写起来会比较的方便，有代码提示。</p><h3 id="创建局部组件"><a href="#创建局部组件" class="headerlink" title="创建局部组件"></a>创建局部组件</h3><p>前面都是创建的全局组件，这里来演示以下如何创建一个局部组件，其实现在我学过的所有的局部的东西都有一个特点就是名称都相比于全局组件会带s后缀，因为局部components这个对象中可以创建很多个的局部组件，而且因为是在一个对象中，所以创建的局部组件也是通过一个对象来定义的.<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">    el: '#app',</span><br><span class="line">    data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">&lt;!-- 这里的components本身也是一个对象的键值对，然后它的值又是一个对象，而这个对象的键就是组件的引用名，值是一个模板对象。 --&gt;</span></span><br><span class="line">                components: &#123;</span><br><span class="line">        // 局部组件一</span><br><span class="line">        test: &#123;</span><br><span class="line">            template: "#tem",</span><br><span class="line">            data() &#123;</span><br><span class="line">                return &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        // 局部组件二</span><br><span class="line">        test2: &#123;</span><br><span class="line">            template: "#tem",</span><br><span class="line">            data() &#123;</span><br><span class="line">                return &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><blockquote><p>要注意的是既然创建的是局部的组件这就以为着它只能在相应的全局组件内有效</p></blockquote><h3 id="要注意的事情"><a href="#要注意的事情" class="headerlink" title="要注意的事情"></a>要注意的事情</h3><ul><li>如果使用 Vue.component 定义全局组件的时候，组件名称使用了 驼峰命名，则在引用组件的时候，需要把 大写的驼峰改为小写的字母，同时，两个单词之前，使用 <code>-</code> 符号连接；如果不使用驼峰,则直接拿名称来使用即可;<ul><li>不论是哪种方式创建出来的组件,组件的 template 属性指向的模板内容,必须有且只能有唯一的一个根元素<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;test&apos;, &#123;</span><br><span class="line">            template: &quot;&lt;p&gt;这是一段文字&lt;/p&gt;&lt;p&gt;这是另一段文字&lt;/p&gt;&quot;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>像是这样就会报错，也很好理解，如果需要多个根元素直接创建多个组件就好了。</p><ul><li>我们创建的组件也可以有自己的属性以及方法，因为我们的vue本身就是组件化开发，但是要注意的一件事情是我们创建的组件的data的写法有要求，必须是函数返回值的形式，像下面这样：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li></ul><p>那为什么要这样呢，如果不这样的话我们给所有组件都用相同名字的data来存放属性，那么当属性的值发生改变的时候，其他的组件的也会受到影响，很显然这不是我们想要的，如果通过函数返回值的这种方式就可以避免这种情况。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>组件在vue中是非常重要的，因为vue就是组建化开发，那么这里就先学习如何创建组件，下一篇介绍组件之间的一些其他知识。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;学习vue也有一段时间了，前面学习了vue中的一些基础的只是，由于期末的原因忙于期末作业就暂停了vue的学习，现在放假了，有时间了就继续学习vue，今天来学习以下vue中的组件，我们都知道其实vue是组件化开发，运用好组件可以大大的提高我们开发的效率。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>jQuery+php实现一个购物车的功能</title>
    <link href="https://q32757468.github.io/2019/06/30/jQuery-php%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%9A%84%E5%8A%9F%E8%83%BD/"/>
    <id>https://q32757468.github.io/2019/06/30/jQuery-php实现一个购物车的功能/</id>
    <published>2019-06-30T10:23:06.000Z</published>
    <updated>2019-07-01T02:24:49.031Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在前面学习jQuery的时候，就学习过ajax如何与后端进行交互，虽然学习过php，但是平时使用的比较少，练的也比较少，Ajax也是，虽然实现动态网站上的各种功能的思路都比较清楚，但是写起来还是比较费劲啊，动不动就报错，特别是这次由于比赛需要，需要在一个静态页面的基础上实现动态的添加购物车的功能，就进行了一次尝试着写，按照我自己的思路，最终经过比较长的时间完成了这一功能，特此来记录一下。<br><a id="more"></a></p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>先来说说实现的思路：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实我觉得思路是非常简单的，无非就是在前端通过添加购物车的按钮发送Ajax请求，然后将需要添加到购物车的商品的信息提交到后台，然后后台再拿到前端发过来的数据，将数据存放到数据表中，然后前端再在购物车页面通过Ajax请求后台，后台将所有数据表中的数据返回前端，然后前端将获取到的数据拼接到页面中，虽然原理非常的简单，但是实现的过程还是不容易啊，不过为了比赛，还是需要更加的熟练。</p><h3 id="这过程中遇到的问题"><a href="#这过程中遇到的问题" class="headerlink" title="这过程中遇到的问题"></a>这过程中遇到的问题</h3><ul><li>第一个问题就是对MySQL的语句不是很熟练，每次写语句的时候都是投机取巧的写，并不是完全手打，而且MySQL的很多命令都忘了，即使没忘的也不是很熟</li><li>第二个问题就是在前端发送请求之前需要拿到一些元素，需要使用到jQuery中的很多筛选元素的方法，这里之前用的也比较少，需要先去查文档才会用，比如像<code>parents()</code>之类的。</li><li>第三个就是php方面对语句不熟。</li></ul><h3 id="最终实现功能的主要代码"><a href="#最终实现功能的主要代码" class="headerlink" title="最终实现功能的主要代码"></a>最终实现功能的主要代码</h3><p>其中很重要的一个也是我想了很久的就是后端究竟要返回什么样的数据，前端又该如何拿到数据。</p><ul><li><p>PHP部分：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include</span> <span class="string">'conn.php'</span>;</span><br><span class="line"><span class="comment">// 通过加这条header语句就可以配合后面的函数将输出的结果转化为json格式</span></span><br><span class="line">header(<span class="string">'Content-Type:application/json; charset=utf-8'</span>);</span><br><span class="line">$res = mysqli_query($conn, <span class="string">'select * from cart'</span>);</span><br><span class="line"><span class="comment">// 将数据先放到一个数组中</span></span><br><span class="line">$data = <span class="keyword">array</span>();</span><br><span class="line"><span class="keyword">while</span> ($row = mysqli_fetch_array($res)) &#123;</span><br><span class="line">    <span class="comment">// 每次循环都将结果存放到这个数组中，由于这里是一个二维表，所以也要用二维数组来存放，一开始没有想明白怎么创建一个键值对的二维数组，折腾了一会就明白了</span></span><br><span class="line">    $data[] = [<span class="string">'name'</span> =&gt; <span class="string">"$row[name]"</span>, <span class="string">'quantity'</span> =&gt; <span class="string">"$row[quantity]"</span>, <span class="string">'price'</span> =&gt; <span class="string">"$row[price]"</span>,];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 然后将数组转化为json格式，这样返回给前端的数据就是一个对象数组了，前端就可以通过jQuery中的``$.each()``方法来对数组进行遍历，然后拿到想要的东西</span></span><br><span class="line"><span class="keyword">echo</span> json_encode($data);</span><br></pre></td></tr></table></figure></li><li><p>前端部分</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> cart_item = $(<span class="string">'.cart_item'</span>);</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            type: <span class="string">'get'</span>,</span><br><span class="line">            url: <span class="string">'./php/cart_item.php'</span>,</span><br><span class="line">            success: <span class="function"><span class="keyword">function</span> (<span class="params">msg</span>) </span>&#123;</span><br><span class="line">                <span class="comment">// 通过循环就可以拿到所有的数据，并且将每条数据都拼接到页面中去</span></span><br><span class="line">                $.each(msg, <span class="function"><span class="keyword">function</span> (<span class="params">index, obj</span>) </span>&#123;</span><br><span class="line">                    <span class="comment">// 这里进行拼接，说实话我觉得拼接真是一件麻烦的事情，不知道有没有更简单的方法</span></span><br><span class="line">                    <span class="keyword">var</span> item = <span class="string">'&lt;tr class="t_body"&gt;&lt;td&gt;&lt;input type="checkbox"&gt;&lt;/td&gt;&lt;td&gt; &lt;img src="'</span> + obj.name + <span class="string">'" alt=""&gt;&lt;/td&gt;&lt;td&gt;shoes&lt;/td&gt;&lt;td class="item_pri"&gt;$2400&lt;/td&gt;&lt;td class="item_num"&gt;&lt;input value="1" type="number"&gt;&lt;/td&gt;&lt;td class="item_total"&gt;2222.00$&lt;/td&gt;&lt;/tr&gt;'</span>;</span><br><span class="line">                    $(<span class="string">'tbody'</span>).prepend(item);</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;,</span><br><span class="line">            error: <span class="function"><span class="keyword">function</span> (<span class="params">xhr</span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(xhr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)();</span><br></pre></td></tr></table></figure></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>感觉上面说了一堆废话，其实就是对Ajax和php还不是很熟练所导致的，写的不是很顺，以后多写应该会有所改观。不过通过这几次的写交互页面，也学到了很多，比如如何在php中返回一个对象（通过数组，然后将数组转化为json），以及前端如何较好的处理后端的数据，还有就是后端的一些逻辑处理也想明白了。以后要多回来看前面写过的代码，</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在前面学习jQuery的时候，就学习过ajax如何与后端进行交互，虽然学习过php，但是平时使用的比较少，练的也比较少，Ajax也是，虽然实现动态网站上的各种功能的思路都比较清楚，但是写起来还是比较费劲啊，动不动就报错，特别是这次由于比赛需要，需要在一个静态页面的基础上实现动态的添加购物车的功能，就进行了一次尝试着写，按照我自己的思路，最终经过比较长的时间完成了这一功能，特此来记录一下。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vue.js的学习（vue中的动画）</title>
    <link href="https://q32757468.github.io/2019/06/20/vue-js%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%88vue%E4%B8%AD%E7%9A%84%E5%8A%A8%E7%94%BB%EF%BC%89/"/>
    <id>https://q32757468.github.io/2019/06/20/vue-js的学习（vue中的动画）/</id>
    <published>2019-06-20T12:28:09.000Z</published>
    <updated>2019-07-03T09:03:33.906Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一开始在使用vue中的动画的时候我没有太明白究竟是个怎么样的机制，以及如何高度的定义一些动画，经过我的尝试，现在终于算是弄明白时怎么一回事了<a href="https://cn.vuejs.org/v2/guide/transitions.html#CSS-%E5%8A%A8%E7%94%BB" target="_blank" rel="noopener">这里是官方文档</a>。<br><a id="more"></a></p></blockquote><h3 id="vue中动画的特点"><a href="#vue中动画的特点" class="headerlink" title="vue中动画的特点"></a>vue中动画的特点</h3><p>vue中的动画主要分为两部分，一是进场动画，二是离场动画，vue中的动画主要是监听了设置动画的元素的显示和隐藏，当元素在页面中被显示的时候就会执行进场动画，当元素被隐藏的时候就会执行离场动画，我们可以通过设置两组类来设置离场动画和进场动画。</p><p><strong>一个简单的小例子</strong><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">    <span class="comment">/* 这两个类一个是动画的起始位置,一个是动画结束的时候的位置 */</span></span></span><br><span class="line"><span class="css">    <span class="selector-class">.dh1-enter</span>,</span></span><br><span class="line"><span class="css">    <span class="selector-class">.dh1-leave-to</span> &#123;</span></span><br><span class="line"><span class="undefined">        transform: translateX(40px);</span></span><br><span class="line"><span class="undefined">        opacity: 0;</span></span><br><span class="line"><span class="undefined">    &#125;  </span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="css">      <span class="comment">/* 这两个类一个是进入时候的动画效果，一个是离开时候的动画效果 */</span></span></span><br><span class="line"><span class="css">    <span class="selector-class">.dh1-enter-active</span>,</span></span><br><span class="line"><span class="css">    <span class="selector-class">.dh1-leave-active</span> &#123;</span></span><br><span class="line"><span class="undefined">        transition: all 1s ease;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- vue中的动画可以分为两部分，一部分是进入的动画，一部分是离开的动画，当元素被隐藏的时候会触发离开的动画，出现的时候会触发进入的动画 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 这是通过这种transition和两个种类来设置动画 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"flag=!flag"</span>&gt;</span>点击切换状态<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"flag2=!flag2"</span>&gt;</span>点击切换状态2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 通过添加appear 可以使动画在渲染到页面的时候就执行一次 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">"dh1"</span> <span class="attr">appear</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-show</span>=<span class="string">"flag"</span>&gt;</span>这是一段话第一段话<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">"dh2"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-show</span>=<span class="string">"flag2"</span> <span class="attr">:class</span>=<span class="string">"&#123;animated:true,bounce:true&#125;"</span>&gt;</span>这是一段话第二段话<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./../../js/vue.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el: <span class="string">'#app'</span>,</span></span><br><span class="line"><span class="undefined">            data() &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">                    flag: <span class="string">'true'</span>,</span></span><br><span class="line"><span class="javascript">                    flag2: <span class="string">'false'</span>,</span></span><br><span class="line"><span class="undefined">                &#125;</span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="undefined">            methods: &#123;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="undefined">        &#125;)</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="单元素过渡"><a href="#单元素过渡" class="headerlink" title="单元素过渡"></a>单元素过渡</h3><ul><li><p>可以看出其实vue中将动画主要分成了两部分</p><ul><li>一部分是入场时的动画，也就是动画从隐藏到显示的这个过程中所执行的动画</li><li>另一部分是离场动画也就是元素从显示到隐藏这个过程中所执行的动画</li></ul></li><li><p>可以通过4个类来分别控制动画，就像上面的例子中的那样</p></li><li><p>也可以通过vue来添加类来引用动画库中的动画</p></li></ul><h3 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h3><p>vue中的钩子函数将进场动画和离场动画进行了细分，包括进场前和执行动画时，以及动画结束后，通过设置钩子函数就可以对动画的各个时机进行详细的设置。<br>可以通过钩子函数来设置只进行进场动画或者离场动画，以及对外部引用的动画进行很好的控制。</p><p>可以通过这个例子看出来：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.ball</span> &#123;</span></span><br><span class="line"><span class="undefined">        width: 30px;</span></span><br><span class="line"><span class="undefined">        height: 30px;</span></span><br><span class="line"><span class="undefined">        background-color: bisque;</span></span><br><span class="line"><span class="undefined">        border-radius: 50%;</span></span><br><span class="line"><span class="undefined">        margin-top: 10px;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 通过钩子函数来实现动画就不再是通过设置样式来实现动画效果，而是通过js来设置样式来实现动画效果 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 也是分为几个阶段，主要是两部分，一是进场动画，一是离场动画 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 进场动画又分为 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 进场前：主要是通过设置style来设置起始时的样式位置之类的 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 进场时：主要通过设置style来设置动画结束时的位置，以及动画属性的设置如动画时常 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 进场后：动画完成后所执行的东西 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 其实钩子函数的原理还是对单元素的过渡做了封装，只不过是可以通过js来控制只进行进场动画或者只进行离场动画 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"flag=!flag"</span>&gt;</span>单击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transition</span> <span class="attr">v-on:before-enter</span>=<span class="string">"beforeEnter"</span> <span class="attr">v-on:enter</span>=<span class="string">"enter"</span> <span class="attr">v-on:after-enter</span>=<span class="string">"afterEnter"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-show</span>=<span class="string">"flag"</span> <span class="attr">class</span>=<span class="string">"ball"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./../../js/vue.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el: <span class="string">'#app'</span>,</span></span><br><span class="line"><span class="undefined">            data() &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">                    flag: <span class="literal">false</span>,</span></span><br><span class="line"><span class="undefined">                &#125;</span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="undefined">            methods: &#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">// 所有的钩子函数都必须传一个el参数，表示操作的原生dom对象</span></span></span><br><span class="line"><span class="undefined">                beforeEnter(el) &#123;</span></span><br><span class="line"><span class="javascript">                    el.style.transform = <span class="string">"translate(0,0)"</span>;</span></span><br><span class="line"><span class="undefined">                &#125;,</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">                enter(el, done) &#123; <span class="comment">//在单纯的使用js钩子函数设置动画时必须传一个done参数来执行完成后的操作，这个done实际上是after-enter所绑定的方法</span></span></span><br><span class="line"><span class="javascript">                    el.offsetWidth; <span class="comment">//这个必须加，不加出bug，没有为什么</span></span></span><br><span class="line"><span class="javascript">                    el.style.transform = <span class="string">"translate(40px,100px)"</span>;</span></span><br><span class="line"><span class="javascript">                    el.style.transition = <span class="string">"all 1s ease"</span>;</span></span><br><span class="line"><span class="undefined">                    done();</span></span><br><span class="line"><span class="undefined">                &#125;,</span></span><br><span class="line"><span class="undefined">                afterEnter(el) &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="comment">// 这里因为只需要重复这个半场动画，这个从隐藏到出现从上到下的过程，所以将元素设置为不显示，下次再单击的时候就又是执行的是从上到下的动画了</span></span></span><br><span class="line"><span class="javascript">                    <span class="keyword">this</span>.flag = !<span class="keyword">this</span>.flag;</span></span><br><span class="line"><span class="undefined">                &#125;</span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="undefined">        &#125;)</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="列表动画"><a href="#列表动画" class="headerlink" title="列表动画"></a>列表动画</h3><p>在前面的所有例子都是设置的单元素动画，不能用于设置列表中的动画，但我们需要设置一个列表动画，让其中的所有元素都有动画效果的时候，我们就可以使用<code>transition-group</code>这个标签来包裹我们想要设置动画的列表。<br>就像下面这个例子这样：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    span &#123;</span></span><br><span class="line"><span class="undefined">        margin: 5px;</span></span><br><span class="line"><span class="css">        <span class="comment">/* 这里要注意一件事情，必须设置为inline-block,不然元素不会从下面出来，或者使用弹性布局也可以 */</span></span></span><br><span class="line"><span class="undefined">        display: inline-block;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.v-enter-active</span>,</span></span><br><span class="line"><span class="css">    <span class="selector-class">.v-leave-active</span> &#123;</span></span><br><span class="line"><span class="undefined">        opacity: 1;</span></span><br><span class="line"><span class="undefined">        transition: all 1s ease;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.v-enter</span>,</span></span><br><span class="line"><span class="css">    <span class="selector-class">.v-leave-to</span> &#123;</span></span><br><span class="line"><span class="undefined">        transform: translateY(30px);</span></span><br><span class="line"><span class="undefined">        opacity: 0;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="css">    <span class="comment">/* 要实现其他元素位移时有动画必须添加下面这个类，并且设置动画 */</span></span></span><br><span class="line"><span class="css">    <span class="selector-class">.v-move</span> &#123;</span></span><br><span class="line"><span class="undefined">        transition: all 1s ease;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="css">    <span class="comment">/* 而且还必须单独给v-leave-active这个类设置绝对定位才可以实现效果 */</span></span></span><br><span class="line"><span class="css">    <span class="selector-class">.v-leave-active</span> &#123;</span></span><br><span class="line"><span class="undefined">        position: absolute;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">style</span>=<span class="string">"margin-left: 10px"</span> @<span class="attr">click</span>=<span class="string">"addnum"</span>&gt;</span>add<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">style</span>=<span class="string">"margin-left: 10px"</span> @<span class="attr">click</span>=<span class="string">"delnum"</span>&gt;</span>del<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transition-group</span> <span class="attr">tag</span>=<span class="string">"div"</span> <span class="attr">:style</span>=<span class="string">"&#123;margin:'10px'&#125;"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 如果要让原来元素再插入的过程中保持位置不变，就需要设置key --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-for</span>=<span class="string">"(item,index) in list"</span> <span class="attr">:key</span>=<span class="string">"item"</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">transition-group</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./../../js/vue.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el: <span class="string">"#app"</span>,</span></span><br><span class="line"><span class="undefined">            data() &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="undefined">                    list: [1, 2, 3, 4, 5, 6, 7, 8, 9],</span></span><br><span class="line"><span class="undefined">                    num: 10,</span></span><br><span class="line"><span class="undefined">                &#125;</span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="undefined">            methods: &#123;</span></span><br><span class="line"><span class="undefined">                randomIndex() &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="comment">// Math.floor()的作用是返回一个小于等于参数的整数</span></span></span><br><span class="line"><span class="javascript">                    <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="keyword">this</span>.list.length)</span></span><br><span class="line"><span class="undefined">                &#125;,</span></span><br><span class="line"><span class="undefined">                addnum() &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="comment">// splice方法还可以用来在指定位置添加元素，第三个参数就是要添加的元素</span></span></span><br><span class="line"><span class="javascript">                    <span class="keyword">this</span>.list.splice(<span class="keyword">this</span>.randomIndex(), <span class="number">0</span>, <span class="keyword">this</span>.num++)</span></span><br><span class="line"><span class="undefined">                &#125;,</span></span><br><span class="line"><span class="undefined">                delnum() &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">this</span>.list.splice(<span class="keyword">this</span>.randomIndex(), <span class="number">1</span>)</span></span><br><span class="line"><span class="undefined">                &#125;</span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="undefined">        &#125;)</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p><ul><li>这里要注意的几件事是：<ul><li>如果要使动画生效，必须将要设置动画的元素设置为块级元素或者行内块级元素，如果是行内元素则不会有动画效果。</li><li>如果要使其他元素在发生位置移动也拥有动画过渡的效果这需要添加一个<code>v-move</code>这个类，当然，这个名称也是一样可以修改的，然后在这个类中设置动画过渡效果，像上面的这个例子这样。</li><li>但是其实只<code>v-move</code>这个类其实是还不够的，还需要在<code>v-leave-active</code>中设置绝对定位，这里要注意的一件事情是，这里必须单独只给这一个类设置，否则也不会有动画效果，一开始的时候我贪图方便就直接在设置active这组动画的时候设置上绝对定位，也就是给两个类都加上了绝对定位，结果发现这样并没有效果，只有单独给一个类设置的时候才有效果。</li></ul></li></ul><h3 id="追加，使用第三方库的动画"><a href="#追加，使用第三方库的动画" class="headerlink" title="追加，使用第三方库的动画"></a>追加，使用第三方库的动画</h3><p>在最刚开始的时候我认为在vue中给元素添加动画必须要用到vue中提供的控制动画的那几个类或者是钩子函数来实现动画，因为刚接触vue，不是特别熟悉，所以我认为如果要使用第三方的库来给元素添加动画的话应该是通过通过钩子函数来直接控制，但是今天看到了一个别人的用法，有一种恍然大悟的感觉，其实可以直接通过下面的这种方式来设置：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"flag=!flag"</span>&gt;</span>单击切换<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transition</span> <span class="attr">appear</span> <span class="attr">:duration</span>=<span class="string">"&#123; enter: 2000, leave: 1000 &#125;"</span> <span class="attr">enter-active-class</span>=<span class="string">"bounceInLeft"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">leave-active-class</span>=<span class="string">"bounceOutRight"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"animated "</span> <span class="attr">v-show</span>=<span class="string">"flag"</span>&gt;</span>这是一段测试文字<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./../../js/vue.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el: <span class="string">"#app"</span>,</span></span><br><span class="line"><span class="undefined">            data() &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">                    flag: <span class="literal">true</span>,</span></span><br><span class="line"><span class="undefined">                &#125;</span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="undefined">            methods: &#123;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="undefined">        &#125;)</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p><blockquote><p>直接通过设置两个<code>active</code>类就可以实现动画的效果了，一个是进场动画，一个是离场动画，可以通过<code>:duration=&quot;2000&quot;</code>来设置动画的时间，可以像这样直接只传一个时间来设置两个动画的时间，也可以像上面的例子一样通过一个对象来设置两个动画的不同时间。</p></blockquote><p>而在此之前我都是想通过钩子函数来给元素添加类来实现动画的效果，很显然不如上面的这种方式方便，当时在遇到比较复杂的情况的时候还是要使用钩子函数。不得不说vue真是一款很好的框架！</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>要熟练设置vue中的动画就必须要理解vue中动画的运作机制，理解进场和离场这两个过程，然后可以通过设置两组类来设置动画的效果，当这种方法无法满足需求的时候就可以通过钩子函数来满足我们的需求。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;一开始在使用vue中的动画的时候我没有太明白究竟是个怎么样的机制，以及如何高度的定义一些动画，经过我的尝试，现在终于算是弄明白时怎么一回事了&lt;a href=&quot;https://cn.vuejs.org/v2/guide/transitions.html#CSS-%E5%8A%A8%E7%94%BB&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里是官方文档&lt;/a&gt;。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vue.js的学习（vue实例的生命周期）</title>
    <link href="https://q32757468.github.io/2019/06/18/vue-js%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%88vue%E5%AE%9E%E4%BE%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%89/"/>
    <id>https://q32757468.github.io/2019/06/18/vue-js的学习（vue实例的生命周期）/</id>
    <published>2019-06-18T10:17:08.000Z</published>
    <updated>2019-06-18T10:26:43.210Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过学习了解vue实例的生命周期对vue的学习十分的有帮助，所以这次来了解学习以下vue中vue实例的生命周期。<br><a id="more"></a></p></blockquote><ul><li>什么是生命周期：从Vue实例创建、运行、到销毁期间，总是伴随着各种各样的事件，这些事件，统称为生命周期！</li><li><a href="https://cn.vuejs.org/v2/api/#选项-生命周期钩子" target="_blank" rel="noopener">生命周期钩子</a>：就是生命周期事件的别名而已；</li><li>生命周期钩子 = 生命周期函数 = 生命周期事件</li><li>主要的生命周期函数分类：<ul><li>创建期间的生命周期函数：<ul><li>beforeCreate：实例刚在内存中被创建出来，此时，还没有初始化好 data 和 methods 属性</li><li>created：实例已经在内存中创建OK，此时 data 和 methods 已经创建OK，此时还没有开始 编译模板</li><li>beforeMount：此时已经完成了模板的编译，但是还没有挂载到页面中</li><li>mounted：此时，已经将编译好的模板，挂载到了页面指定的容器中显示</li></ul></li><li>运行期间的生命周期函数：<ul><li>beforeUpdate：状态更新之前执行此函数， 此时 data 中的状态值是最新的，但是界面上显示的 数据还是旧的，因为此时还没有开始重新渲染DOM节点</li><li>updated：实例更新完毕之后调用此函数，此时 data 中的状态值 和 界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了！</li></ul></li><li>销毁期间的生命周期函数：<ul><li>beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。</li><li>destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</li></ul></li></ul></li></ul><p>可以通过这张图来形象的了解以下生命周期的含义：<br><img src="http://m.qpic.cn/psb?/V131x4904WMIoW/EYaNPTHs3lpnpvXBr.oeMlvn097Pjgbjp37EqCZYl8k!/b/dLgAAAAAAAAA&bo=OAS5BAAAAAADB6M!&rf=viewer_4"></p><p>这次的vue的生命周期的学习就到这里了，通过这张图可以有比较完整的了解。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;通过学习了解vue实例的生命周期对vue的学习十分的有帮助，所以这次来了解学习以下vue中vue实例的生命周期。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vue.js的学习（自定义指令）</title>
    <link href="https://q32757468.github.io/2019/06/18/vue-js%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%88%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%EF%BC%89/"/>
    <id>https://q32757468.github.io/2019/06/18/vue-js的学习（自定义指令）/</id>
    <published>2019-06-18T01:59:41.000Z</published>
    <updated>2019-06-18T02:45:16.130Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在vue中很多时候现有的指令都是不够我们用的，那么vue中是允许我们自定义指令的，那么我们就可以通过自定义指令来实现我们想要的功能。通过 directive 来定义。<br><a id="more"></a></p></blockquote><h3 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span>  <span class="attr">v-focus</span>=<span class="string">'1+1'</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./../../js/vue.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        Vue.directive(<span class="string">'focus'</span>,&#123;</span></span><br><span class="line"><span class="javascript">            inserted:<span class="function"><span class="keyword">function</span>(<span class="params">el,binding</span>)</span>&#123;</span></span><br><span class="line"><span class="undefined">                el.focus();</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(binding.name);</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(binding.value);</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(binding.expression);                </span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el:<span class="string">'#app'</span>,</span></span><br><span class="line"><span class="undefined">        data() &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="undefined">                </span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;,</span></span><br><span class="line"><span class="undefined">        methods: &#123;</span></span><br><span class="line"><span class="undefined">            </span></span><br><span class="line"><span class="undefined">        &#125;,</span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看出这样就通过定义了一个全局指令来使一个文本框自动获得了焦点。</p><h3 id="定义全局指令"><a href="#定义全局指令" class="headerlink" title="定义全局指令"></a>定义全局指令</h3><p>上面的例子就是定义的一个全局指令</p><p>###定义局部指令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">directives: &#123;</span><br><span class="line">  focus: &#123;</span><br><span class="line">    // 指令的定义</span><br><span class="line">    inserted: function (el) &#123;</span><br><span class="line">      el.focus()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>像这样就可以定义一个局部指令，局部指令是通过一个对象来定义。，并且名称后面带有s。</p><h3 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h3><p>在上面的例子中以下代码就是用的<code>inserted</code>这个钩子函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inserted:function(el,binding)&#123;</span><br></pre></td></tr></table></figure></p><p>钩子函数的类别：</p><ul><li>bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。<br>这是在dom树还没有渲染到页面中之前，还在内存中的时候会调用，那么对于大部分js中的行为来说肯定是不会生效的，但对于比如像设置样式这种一直存在的东西来说，渲染到页面之后也还会有效</li></ul><ul><li>inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。<br>当dom元素被插入到页面时触发，对于js中的行为也能触发</li></ul><ul><li><p>update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。</p></li><li><p>componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。</p></li><li><p>unbind：只调用一次，指令与元素解绑时调用。</p></li></ul><h3 id="钩子函数的参数"><a href="#钩子函数的参数" class="headerlink" title="钩子函数的参数"></a>钩子函数的参数</h3><ul><li>el：指令所绑定的元素，可以用来直接操作 DOM 。</li></ul><ul><li>binding：一个对象，包含以下属性：<br>  -name：指令名，不包括 v- 前缀。<br>  -value：指令的绑定值，例如：v-my-directive=”1 + 1” 中，绑定值为 2。<br>  -oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。<br>  -expression：字符串形式的指令表达式。例如 v-my-directive=”1 + 1” 中，表达式为 “1 + 1”。<br>  -arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 “foo”。<br>  -modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。</li><li>vnode：Vue 编译生成的虚拟节点。移步 VNode API 来了解更多详情。</li><li>oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。</li></ul><p>在上面的例子中就演示了这些参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Vue.directive(&apos;focus&apos;,&#123;</span><br><span class="line">    inserted:function(el,binding)&#123;</span><br><span class="line">        el.focus();</span><br><span class="line">        console.log(binding.name); //focus</span><br><span class="line">        console.log(binding.value);//2</span><br><span class="line">        console.log(binding.expression);//1+1                </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在vue中很多时候现有的指令都是不够我们用的，那么vue中是允许我们自定义指令的，那么我们就可以通过自定义指令来实现我们想要的功能。通过 directive 来定义。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
