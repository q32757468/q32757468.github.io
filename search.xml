<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[自动识别输入学工平台验证码]]></title>
    <url>%2F2019%2F12%2F07%2F%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E8%BE%93%E5%85%A5%E5%AD%A6%E5%B7%A5%E5%B9%B3%E5%8F%B0%E9%AA%8C%E8%AF%81%E7%A0%81%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最近登录学校的学工平台的官网的时候发现学校的网站有一定的年份了，包括验证码的机制也是非常的简单，那么也就意味着其实在如今这样简单的验证码机制已经不再安全了，其实不仅仅是我们学校的验证码使用的是比较老的技术，我也发现了其实还有很多的比较小并且比较老的网站使用的都是以前的验证码技术，所以我打算实现一个自动输入验证码的功能，这样配合浏览器的记住密码的功能每次登录就会非常的方便了。 实现思路在开始实现之前可以想看一下我们学校的学工平台的验证码有多么的简单：可以看出这样的验证码是非常的简单的，很简单的就可以通过肉眼就分辨出其中的数字。 那么基于这样的验证码我们需要做到自动识别并且完成输入那么非常的简单了： 识别出验证码中的图像内容 将识别到的内容填充到验证码输入框中 如何实现思路是非常的简单,那么究竟该如何实现呢? 首先我们是通过JS来实现,所以可以通过浏览器插件或者是油猴脚本的形式来向页面当中注入JS 识别图像内容这里我找到了一个JS的图像识别的开源项目,可以通过这个项目来实现图像识别的功能。(项目地址:tesseract.js) 但是在这之后我又遇到了一个问题,通过查看网页源代码可以发现我们学校学工平台中的验证码并不是一般的图像格式,而是一个.html文件,无法保存,虽然不知道是什么原理,但是直接识别肯定是不会成功的,所以需要想办法.&lt;img style=&quot;border: none; display: none;&quot; border=&quot;0&quot; src=&quot;default3.html&quot;&gt; 那么换一种思路只需要将这个.htmldom元素转化为一张真正的图像就可以了，该如何转换呢，这里就必须借助于 html2canvas这个项目了(项目地址),这个工具可以将dom元素转化为canvas图像,从而就可以达到我们的目的。 之后我们就只需要对转化的得到的canvas图像进行图像识别就可以获得到我们想要的验证码了。 最后只需要将验证码填入相应的文本框就完美的实现了自动输入验证码的功能了。 实现代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950(function () &#123; //这里通过使用了promise来更加简便的调用 let H2C = new Promise(function (resolve, reject) &#123; // 引入html2canvas dynamicLoadJS('http://html2canvas.hertzen.com/dist/html2canvas.min.js', function () &#123; resolve("html2canvas加载完毕"); &#125;); &#125;) let Tes = new Promise(function (resolve, reject) &#123; // 引入tesseract dynamicLoadJS('https://unpkg.com/tesseract.js@v2.0.0-beta.1/dist/tesseract.min.js', function () &#123; resolve("tesseract加载完毕"); &#125;); &#125;) Promise.all([H2C, Tes]).then(function (values) &#123; // 将原本的html文件转化为canvas图像 html2canvas(document.querySelector("img[src='default3.html']")).then(canvas =&gt; &#123; document.querySelector("img[src='default3.html']").parentNode.appendChild(canvas); document.querySelector("img[src='default3.html']").style.display = "none"; //对图像进行识别 Tesseract.recognize(canvas.toDataURL()).then(function (result) &#123; let yzm = result.data.text; yzm = yzm.replace(/[^0-9]/ig, ""); console.log(yzm); //将结果注入相应的文本框 document.querySelector("input[maxlength='5']").value = yzm; console.log(values); &#125;) &#125;); &#125;) //这个函数的作用是动态的引入我们需要的那两个js库,并且接收两个参数,第一个参数是路径,第二个参数是一个回调函数,回调函数就是加载完毕后所要执行的内容 function dynamicLoadJS(path, callback) &#123; let temp = document.createElement('script'); temp.setAttribute('type', 'text/javascript'); temp.src = path; temp.onload = temp.onreadystatechange = function () &#123; if (!this.readyState || this.readyState === "loaded" || this.readyState === "complete") &#123; temp.onload = temp.onreadystatechange = null; callback(); this.parentNode.removeChild(this); &#125; &#125;; document.head.appendChild(temp); &#125;&#125;)(); 这样就实现了自动输入验证码的功能,虽然动态加载两个js库需要花费一些时间以及识别的过程需要一些时间,但是还是能够免去手动输入验证码的过程。 总结实现这个功能整体上还是挺简单的，毕竟现在已经有了这么强大的识别技术，这也意味着现在很多网站的验证码已经是如同虚设，需要及时的更新了。 这个小工具写的也不是很好，如果有更好的方案欢迎提出学习。]]></content>
  </entry>
  <entry>
    <title><![CDATA[uniapp实现左右滑动长列表]]></title>
    <url>%2F2019%2F11%2F29%2Funiapp%E5%AE%9E%E7%8E%B0%E5%B7%A6%E5%8F%B3%E6%BB%91%E5%8A%A8%E9%95%BF%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最近在学习uniapp，因为我觉得这是个不错的开发工具，哪怕不用来进行多端开发，只是用来进行微信小程序的开发这也是一个非常不错的开发框架，因为主要的书写规范都是和vue类似的。这次突然想开发一个手机APP，准备仿写一个我常用的一个App，觉得它的左右滑动的长列表做得挺不错的，所以花了点时间仿写了一下。 先来看一下效果这里只是简单的实现了功能，样式不是很好看，不过也可以通过动图看出实现了一个长列表的功能。 主要功能及实现思路首先是实现一个长列表的功能 这里可以分为两部分，一部分是头部，也就是用来点击跳转以及显示当前所在页面组件的头部，另一部分就是主要内容部分，就是我们的页面组件。 这里实现起来非常的简单，我们需要实现想要的效果只需要头部使用scroll-view就可以了，就默认可以滚动了，而主体部分使用swiper组件就可以实现我们想要的长列表的切换功能了。 将头部和主体部分结合起来我们还需要将单独的头部和主体部分结合起来，不然这二者也只是两个毫无关联的组件而已，结合起来需要实现这些功能： 左右滑动主体部分时，头部的激活状态也会跟着改变。这个可以通过swiper组件的change事件来动态的改变头部链接的样式。 点击头部时会跳转到相应的主体部分。并且正确的改变激活状态。这个可以通过给每个链接绑定一个点击事件，通过这个点击事件来动态的改变swiper组件的current属性以达到改变显示哪个页面组件。如果要实现点击没有动画的跳转的话可以在点击的时候将swiper组件的duration动画时长属性设置为0，然后在通过 animationfinish事件在动画结束后将其设置会原来的状态，不过这里要注意的一点是在 uniapp的nvue页面中duration属性无效，所以需要从其他地方入手修改。 自适应的将头部激活的栏目居中，这个可能不是很好理解，大概意思就是当跳转到特别后面的页面组件当中的话，头部也会跟着变化，但是可能会看不到，所以需要将其显示到可视区域的中间。这里可以通过动态的修改scroll-view组件的scroll-left属性来实现，而scroll-left的值则和当前页面组件的index有关。 加载组件考虑到长列表的性能问题，如何加载组件是非常重要的： 需要动态的加载组件，异步加载组件的方式有非常的多种，这里也可以参考官方文档。 当页面组件还未加载时以及正在加载中时需要显示正在加载中以确保用户看到一个整洁美观的页面。默认所有页面都是显示 正在加载 当切换到相应的页面组件则开始加载组件，但是此时依然显示的是 正在加载 直至组件加载完毕才不显示正在加载而是显示相应的组件（我这里是通过setTimeOut来模拟的组件获取数据）。那该如何做到，可以通过子组件 $emit 父组件的方法来实现这样一个功能。 当渲染的页面组件过多时结束一些组件的加载。可以通过一个数组来存储最近打卡的页面组件，(数量就是要缓存的组件的数量)，当每次进入到一个新打开的页面组件后，也就是打开下一个组件之前，就对所有的组件进行遍历，将那些不在缓存列表中的组件通过 v-if 来结束生命周期，这样就达到了优化性能的效果。 关于页面组件的设计我的设计思路是所有页面组件都是同一个页面组件，但是在加载的时候会向其传一个id，子组件接收到这个id就会根据这个id来渲染相应的界面。 功能实现代码这里将代码贴出来：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244&lt;template xlang="wxml"&gt; &lt;view class="content"&gt; &lt;view class="tabCard"&gt; &lt;!-- 使用scroll-view的时候需要注意，需要将样式设置为inline-block以及不换行white-space: nowrap --&gt; &lt;!-- 并且不能使用flex布局 --&gt; &lt;!-- 或者还有一种处理方式就是通过里面再加一个容器来设置flex布局。 --&gt; &lt;scroll-view scroll-x="true" :scroll-left="scrollLeft" scroll-with-animation="true" class="tabCardHead" &gt; &lt;view class="scrollConten" ref="scrollConten" v-for="(item,index) in pageList" :key="item.itemID" &gt; &lt;view class="swichBT" @tap="toPage(index)" :class="&#123;active:item.active&#125;"&gt;&#123;&#123;item.title&#125;&#125;&lt;/view&gt; &lt;/view&gt; &lt;/scroll-view&gt; &lt;view class="tabCardBody"&gt; &lt;swiper @change="swChange" @animationfinish="animationfinish" :current="curIndex" :duration="duration" &gt; &lt;swiper-item :item-id="item.itemID" v-for="(item, index) in pageList" :key="index"&gt; &lt;view class="loading" v-show="item.loadState"&gt;正在加载中&lt;/view&gt; &lt;testListPage class="testListPage" @loadComplete="toggleDisplay" :itemIndex="index" :itemID="item.itemID" v-if="item.load" v-show="!item.loadState" &gt;&lt;/testListPage&gt; &lt;/swiper-item&gt; &lt;/swiper&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt;&lt;/template&gt; &lt;script&gt;// 实现异步加载组件const testListPage = resolve =&gt; &#123; require(["./testListPage"], resolve).then(function(res) &#123; console.log("组件加载成功"); &#125;);&#125;;export default &#123; data() &#123; return &#123; title: "Hello", flag: true, curIndex: 0, cacheList: ["test1"], duration: "500", scrollLeft: "0", //数组对象解释说明： // title表示是哪一栏， // active表示头部是否是激活状态， // load表示是否加载了该组件 //loadState用来控制是否显示正在加载的图片，因为组件加载与加载中的图片有重叠时间，所以需要单独用一个变量来控制 pageList: [ &#123; title: "测试一", itemID: "test1", active: true, load: true, loadState: true &#125;, &#123; title: "测试二", itemID: "test2", active: false, load: false, loadState: true &#125;, &#123; title: "测试三", itemID: "test3", active: false, load: false, loadState: true &#125;, &#123; title: "测试四", itemID: "test4", active: false, load: false, loadState: true &#125;, &#123; title: "测试五", itemID: "test5", active: false, load: false, loadState: true &#125;, &#123; title: "测试六", itemID: "test6", active: false, load: false, loadState: true &#125; ] &#125;; &#125;, methods: &#123; swChange(e) &#123; this.curIndex = e.detail.current; // 切换到页面加载相应组件 this.pageList[e.detail.current].load = true; //将头部设为激活状态 this.pageList.forEach((item, index) =&gt; &#123; item.active = false; &#125;); this.pageList[e.detail.current].active = true; // 控制缓存的组件 //控制被缓存的列表 if (!this.cacheList.includes(e.detail.currentItemId)) &#123; if (this.cacheList.length &lt; 3) &#123; this.cacheList.push(e.detail.currentItemId); &#125; else &#123; this.cacheList.push(e.detail.currentItemId); this.cacheList.shift(); &#125; &#125; // console.log(this.cacheList); //删除不在缓存范围内的组件 this.pageList.forEach((item, index) =&gt; &#123; if (!this.cacheList.includes(item.itemID)) &#123; // console.log(item.itemID); item.load = false; item.loadState = true; &#125; &#125;); // 将头部一直保持居中 // console.log(this.$refs.scrollConten[0].$el.clientWidth); const scrollLeft = (this.curIndex - 2) * this.$refs.scrollConten[0].$el.clientWidth; this.scrollLeft = String(scrollLeft); // console.log(scrollLeft); &#125;, toPage(index) &#123; //切换class状态 this.pageList.forEach((item, index) =&gt; &#123; item.active = false; &#125;); // 切换页面组件 this.pageList[index].active = true; this.curIndex = index; //暂时关闭动画 this.duration = "0"; // console.log(this.duration); &#125;, toggleDisplay(index) &#123; this.pageList[index].loadState = false; &#125;, animationfinish() &#123; this.duration = "500"; &#125; &#125;, components: &#123; testListPage &#125;&#125;;&lt;/script&gt;&lt;style lang="scss" scoped&gt;.active &#123; background-color: orange;&#125;.content &#123; display: flex; flex-direction: column; align-items: center; justify-content: center; position: relative; .testListPage &#123; text-align: center; width: 100%; height: 200rpx; background-color: red; &#125; .tabCardHead &#123; width: 750rpx; white-space: nowrap; display: inline-block; position: absolute; top: 0; left: 0; .scrollConten &#123; width: 160rpx; background-color: aquamarine; display: inline-block; padding: 10rpx 0; .swichBT &#123; text-align: center; font-size: 28rpx; &#125; &#125; &#125; .tabCardBody &#123; /* #ifdef H5 */ margin-top: 70rpx; /* #endif */ swiper &#123; // swiper组件必须设置宽度，不能依靠里面的组件来支撑起来 //并且有默认的高度是300rpx width: 750rpx; height: 400rpx; swiper-item &#123; // width: 750rpx; .loading &#123; text-align: center; width: 100%; height: 200rpx; background-color: antiquewhite; &#125; &#125; &#125; &#125;&#125;&lt;/style&gt; 总结这是我自己思考的实现长列表的一个思路，所以有些地方可能处理的不是很好，有更好的方案欢迎提出。]]></content>
  </entry>
  <entry>
    <title><![CDATA[移动端目前常用的两种适配方案（rem和vw、vh）]]></title>
    <url>%2F2019%2F11%2F23%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9B%AE%E5%89%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%A4%E7%A7%8D%E9%80%82%E9%85%8D%E6%96%B9%E6%A1%88%EF%BC%88rem%E5%92%8Cvw%E3%80%81vh%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PC端的web开发是比较简单的，不用做任何的适配就可以直接开发，但是手机端就不一样了，因为市场上充满着各种品牌型号的手机，所以会存在着许多种不一样的分辨率，那么如何对这么多的分辨率进行适配就是一个问题了，这篇文章主要介绍目前常见的两种移动端适配方案 rem 适配以及 css 新单位 vw、vh。 rem适配在css3 的新单位出现之前，移动端的适配主要都是通过 rem 适配来实现的，em 这个单位想必大家都很熟悉，就是相较于父级字体大小的一个单位，那么 rem 也是相似的， rem 中的 r 代表着 root ，也就意味着不再是相较于父级了 ，而是相较于根级了，也就是 html 了，所以我们才可以通过 rem 来进行移动端的适配。 我们只需要通过 js 来动态的改变 html 的 font-size，就可以做到 rem 在不同的分辨率下也会有一样的表现。我们只需要将 html的 font-size 与屏幕的宽度关联起来就可以实现这样的效果，可以参考这段代码：1234567let htmlDom = document.getElementsByTagName('html')[0];window.addEventListener('resize', (e) =&gt; &#123; //获取视窗宽度 let htmlWidth = document.documentElement.clientWidth || document.body.clientWidth; //假如设计稿的宽度为750px则除7.5，以此类推 htmlDom.style.fontSize = htmlWidth / 7.5 + 'px';//这样处理后就可以得到 1rem=设计稿物理像素100px=50px css像素&#125;) 这里是以设计稿的宽度为 750px(iphone6)为标准来书写的，那明明我们打开控制台看到的 iPhone6的宽度为 375，为什么设计稿是 750 呢，这是因为这个750 是物理像素，而我们看到的 375 则是 css像素，这也就意味着在 iPhone 上 1css像素=2物理像素。 1htmlDom.style.fontSize = htmlWidth / 7.5 + 'px'; 通过这段代码我们就将屏幕的宽度与 font-size 结合在一起了，就可以达到 1rem 在不同屏幕上会有相同的表现了，有些人可能会奇怪为什么这里是 用获取到的宽度除以7.5，其实这个是没关系的，这个比例是多少都可以，只不过在设计稿的宽度为 750px的情况下 这样可以做到 1rem=100物理像素=50css像素，方便我们书写，假如设计稿上 body 的宽度为 750px ，我们只需要在 css 中写body{width:7.5rem}，只需要将设计稿的宽度除以 100 就可以了。 具体可以参考这个演示：(以设计稿为 750px 为例)1234567891011121314151617181920212223242526272829303132333435363738394041424344 &lt;script&gt; let htmlDom = document.getElementsByTagName('html')[0]; window.addEventListener('resize', (e) =&gt; &#123; //获取视窗宽度 let htmlWidth = document.documentElement.clientWidth || document.body.clientWidth; //加入设计稿的宽度为750px则除7.5，以此类推 htmlDom.style.fontSize = htmlWidth / 7.5 + 'px';//这样处理后就可以得到 1rem=设计稿物理像素100px=50px css像素 &#125;) &lt;/script&gt; &lt;link rel="stylesheet" href="css/normalize.css"&gt;&lt;/head&gt;&lt;style&gt; body &#123; font-size: 16px; &#125; .testBox &#123; width: 100%; background-color: bisque; text-align: center; &#125; .left &#123; background-color: beige; width: 4.5rem; height: 10rem; float: left; text-align: center; &#125; .right &#123; background-color: aqua; width: 3rem; height: 10rem; float: right; text-align: center; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class="testBox"&gt;这是一个测试内容&lt;/div&gt; &lt;div class="left"&gt;这是左边的内容&lt;/div&gt; &lt;div class="right"&gt;这是右边的内容&lt;/div&gt;&lt;/body&gt; 效果图：iPhone6 其他手机 可以看出效果良好。 vw和vh虽然 rem 较好的解决了移动端适配的问题，但是却把 css 和 js 耦合在了一起，很显然这个做法并不完美，所以就有了 css3 的视口单位(Viewport units) vw 和vh。 什么是视口？在桌面端，指的是浏览器的可视区域；在移动端，它涉及3个视口：Layout Viewport（布局视口），Visual Viewport（视觉视口），Ideal Viewport（理想视口）。 视口单位中的“视口”，桌面端指的是浏览器的可视区域；移动端指的就是Viewport中的Layout Viewport。 根据CSS3规范，视口单位主要包括以下4个： vw：1vw等于视口宽度的1%。 vh：1vh等于视口高度的1%。 vmin：选取vw和vh中最小的那个。(通常用来处理屏幕旋转) vmax：选取vw和vh中最大的那个。(通常用来处理屏幕旋转) 其实到这里可以看出视口单位也是与百分比相似的单位，但是vh/vw与%区别在于 % 相较的是祖先元素 ，而 vh/vw 相较的是 视口，所以才可以用 vh/vw 来做移动端的适配。 可以配合 sass 函数来将 px 转化为 vh/vw。123456789//iPhone 6(750px)设计稿基准$vm_base: 750; @function vm($px) &#123; @return ($px / 375) * 100vw;&#125; 实现和上面一样的效果：HTML:123456789101112131415&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0,user-scalable=no"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel="stylesheet" href="css/normalize.css"&gt; &lt;link rel="stylesheet" href="./css/vwvh.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="testBox"&gt;这是一个测试内容&lt;/div&gt; &lt;div class="left"&gt;这是左边的内容&lt;/div&gt; &lt;div class="right"&gt;这是右边的内容&lt;/div&gt;&lt;/body&gt; SCSS:123456789101112131415161718192021222324252627282930313233$vm_base: 750;@function vm($px) &#123; @return ($px / $vm_base) * 100vw;&#125;body &#123; font-size: 16px; .testBox &#123; width: 100%; background-color: bisque; text-align: center; &#125; .left &#123; background-color: beige; width: vm(450); height: vm(1000); float: left; text-align: center; &#125; .right &#123; background-color: aqua; width: vm(300); height: vm(1000); float: right; text-align: center; &#125;&#125; iPhone6 其他手机 总结这篇文章主要介绍了目前常见的两种移动端的适配方案，但是很明显，逐渐的vh/vw将会称为主流的适配方案。 文章介绍的比较粗略，若有错误欢迎指出。]]></content>
  </entry>
  <entry>
    <title><![CDATA[理解JS中的作用域链]]></title>
    <url>%2F2019%2F11%2F18%2F%E7%90%86%E8%A7%A3JS%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;承接之前的关于执行环境的理解，这次主要来来讲解一下JS中的作用域链和词法环境，为什么还要讲词法环境呢，因为我觉得如果单独讲作用域链不容易讲清楚，必须要先理解词法环境才能比较好理解作用域链。 在讲这两个概念之前想来看一个简单的例子：1234567891011function foo() &#123; console.log(a);&#125;function bar() &#123; var a = 3; foo();&#125;var a = 2;bar(); 结果是什么大家可以自己先思考一下，等讲完词法环境与作用域链再来详细说说结果以及为什么会是这样的结果。 词法环境 词法环境（Lexical Environments）：词法环境（Lexical Environments）是一种规范类型，用于根据ECMAScript代码的词法嵌套结构来定义标识符与特定变量和函数的关联。 以上是官方对于词法环境的一段解释，可能看起来不是很好理解，但是这其中想表达的意思就是：词法环境是一种规则，这种规则规定了如何来寻找某个变量或者标示符，而这个规则最终规定在寻找某个变量或者标示符的时候是根据代码结构来决定的，这也就意味着词法环境在书写代码的时候就已经确定了。 可能我这样的解释也不是特别好理解，后面还会结合前面的例子来讲。 关于词法环境更详细的知识我这里就不解释了，只要知道以上关于词法环境的概念就好理解作用域链了。 作用域链 作用域链：作用域链，是由当前环境与上层环境的一系列变量对象组成，它保证了当前执行环境对符合访问权限的变量和函数的有序访问。 理解作用域链重点是理解两个关键词，一个是上层环境，一个是变量对象。 作用域链也很好理解，就是一条单线的链子，用来寻找变量用的。 当当前环境找不到相应变量或者标识符时，就会顺着作用域链向上层环境来寻找相应的变量或者是标识符。 可以通过一个简单的例子来理解：12345678var a = 100;function foo() &#123; bar(); function bar() &#123; console.log(a); &#125;&#125;foo();//结果100 当 bar 函数输出 a 时就会顺着作用域链向外面找，而此时 bar 函数执行环境中保存的 作用域链 可以表示为：AO(bar)–&gt;AO(foo)–&gt;VO(global) 作用域链的最前端一定是当前自己执行环境中的变量对象，末尾一定是全局变量对象。因为函数开始执行之后变量对象转化为活动对象，所以这里用AO来表示。 例子分析相信到这里已经对作用域链比较的理解了，那么我们现在再回过头来看一开始的那个例子：1234567891011function foo() &#123; console.log(a);&#125;function bar() &#123; var a = 3; foo();&#125;var a = 2;bar(); 最终的答案是 2 不知道各位有没有想到是这个结果，如果没有想到也正常，那我们一步一步来分析一下为什么会是这个结果： 首先在全局环境中调用了 bar 这个函数，此时就会创建 bar 这个函数的执行环境，并且创建相应的 变量对象 此时这个函数的变量对象中就会保存有 a 这个变量，并且当开始执行函数的时候就会转化为活动对象，并且 a 这个变量可以访问，且值为 3。 接着开始调用 foo 函数，那么这里就要注意很重要的一点了， foo 这个函数会被保存在哪个环境当中，是 bar 函数还是全局函数当中？这里就要用到前面提到的词法环境了，前面有提到词法环境是一个规则并且规定寻找某个变量或者标示符的时候是根据代码结构来决定的，也就是说不管 foo 函数是在哪里被调用的，它始终都是 全局环境中创建的，这一点在代码写好时就已经确定了，这大致就是词法环境的意思。 并且当全局执行环境创建时也会 找到所有的函数声明，所以会将 foo 函数保存进全局的变量对象当中。 当开始执行 foo 函数的时候因为当前环境的变量对象当中并没有 a 这个变量，所以会通过作用域链来找，我们回顾作用域链的概念：是由当前环境与上层环境的一系列变量对象组成, 所以就会沿着作用域链向上层环境寻找 a 这个变量，那么此时我们就很清楚 foo 函数的上层环境是谁了，是全局环境，所以这个过程大致可以这样表示：AO(foo)–&gt;VO(global) 最终找到全局环境变量对象中的 a 为2，所以最后结果为2。 总结相信通过这几个例子大家已经对词法环境和作用域链有一个比较清楚的认识，也对JS的运作机制有了更加清楚的认识。 这些也都是我个人浅显的理解，如有错误欢迎指出。 参考作用域与作用域链彻底搞懂javascript-词法环境(Lexical Environments)]]></content>
  </entry>
  <entry>
    <title><![CDATA[理解JS中的变量对象]]></title>
    <url>%2F2019%2F11%2F17%2F%E7%90%86%E8%A7%A3JS%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之前有提到过JS中的执行环境(执行上下文)是JS中非常重要的一个概念，而前面也提到了执行环境当中主要包含了三部分：变量对象、作用域链、this指向，这里这里就承接前面，来更为详细的介绍一下变量对象究竟是什么。 变量什么时候被的创建变量对象的创建时机非常好理解： 当前函数被调用但还未执行之时变量对象就在当前执行环境中被创建了。 还未执行就意味着并未开始执行当前函数中的代码。 变量对象创建的过程 创建 arguments 对象该对象的属性名是类似数组中的索引的值：’0’、’1’、’2’…..，属性值是传入的实际参数，此外还有 length 属性表示传入的实际参数的个数，所以说函数中的 arguments 是一个伪数组。 找到所有的函数声明找到函数内所有通过 function 关键字声明的函数，并将其保存在变量对象中，属性名是 函数名 ，属性值是函数的引用地址， 同名则后面的覆盖前面的。这就是为什么JS中存在函数提升。 找到所有的变量声明找到函数内所有的变量声明，并且将其保存在变量对象中，属性名是 变量名 ，属性值为 undefined 。这就解释了为什么访问一个未赋值的变量时返回的是undefined 了 ，以及为什么用 var 声明会存在变量提升了。 但是我们都知道 ES6 新增的 let 和 const 是不存在 变量提升的，那么它们会不会被保存进变量对象中呢？ 我们可以通过测试来体会一下，首先是声明但不赋值,在声明后使用： 12let a;console.log(a); 结果：可以看到结果为 undefined ，这也就意味着通过 let 或者是 const 声明的变量也会被保存进变量对象当中。 那么为什么 let 和 const 不支持变量提升呢：同样的测试，这次在声明之前就使用变量： 12console.log(a);let a; 结果：结果为报错’不能在声明之前使用’，这也就是我们场常说的暂时性死区。 最后结论，ES6中的 let 和 const 会存在暂时性死区的问题，不能在声明之前使用，但是一样的会被保存进变量对象当中。 变量对象与活动对象变量对象与活动对象基本其实是一个对象，主要是在不同的时间叫法不同而已： 变量对象是函数被调用但未执行时在创建在执行上下文中的，此时叫做变量对象，此时变量对象中的所有属性都不能够被访问（除了全局执行环境外）。 而活动对象则意味着当前函数开始执行了，此时变量对象就被转化为活动对象了，转化之后所有的属性就可以访问了。 总结理解了变量对象这个概念在使用js的过程中相信会有更清楚的认识，不了解执行环境的小伙伴可以参考我前面的博客。关于执行环境的理解。 参考彻底理解js的执行上下文，以及变量对象]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网页中常见的两种拖拽形式]]></title>
    <url>%2F2019%2F09%2F30%2F%E7%BD%91%E9%A1%B5%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%8B%96%E6%8B%BD%E5%BD%A2%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这次在chrome插件的开发过程中有需求要实现一个拖拽的功能，所以这次来介绍一下网页中的拖拽。在网页中我们经常能见到拖拽功能，大致可以分为两种，一种是通过拖拽来改变dom元素的位置，还有一种则一般是通过拖拽来上传文件，这两种拖拽各有各的应用常见，但是使用的技术还是有挺大的差别的，这篇文章就来介绍一下这两种拖拽方式以及二者之间的区别。 第一种：改变元素的位置这种拖拽的实现思路是通过鼠标的按下与抬起的事件来判断拖拽开始与拖拽结束，而通过鼠标的移动事件来修改元素的位置，从而实现拖拽的效果，思路比较简单，来看看究竟是怎么样实现的。1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;style&gt; .box1 &#123; width: 200px; height: 200px; background-color: bisque; position: absolute; top: 40px; left: 100px; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class="box1"&gt;&lt;/div&gt; &lt;script src="./js/jquery-3.4.1.min.js"&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; const box1 = $('.box1'); // 定义一个变量来判断是否正在拖拽 let isDraging = false; let x, y; box1.mousedown(function (e) &#123; e = e || window.event; // 这里的diffX和diffY实际上指的就是元素中心点到边框的距离 diffX = e.clientX - box1.offset().left; diffY = e.clientY - box1.offset().top; isDraging = true; &#125;) // 将事件绑定在document上防止拖动太快导致反应不过 $(document).mousemove(function (e) &#123; if (isDraging) &#123; e = e || window.event; // 这里新的坐标指的是中心的位置减去中心到边框的距离。 // 因为绝对定位的top和left算的是边框到父级定位元素的距离 let newX = e.clientX - diffX; let newY = e.clientY - diffY; box1.css(&#123; 'top': newY + 'px', 'left': newX + 'px' &#125;) &#125; &#125;) // 同样防止过快触发错误 $(document).mouseup(function () &#123; isDraging = false; &#125;) &#125;) &lt;/script&gt;&lt;/body&gt; 需要注意的地方已经在代码中注释出来了，这里是通过绝对定位的方式来进行修改的，因为需要脱离文档流。 这里是通过jQuery来实现的，只是演示一下原理，貌似通过原生JS来实现还会方便一点。 第二种：HTML拖拽这种方式的拖拽主要是要用到HTML提供的API，因为HTML本身就是支持拖拽上传文件的，但是除了特定的一些文件或者是链接之类的可以拖动之外，其他的元素想要拖动就必须设置其 draggable ：&lt;element draggable=&quot;true | false | auto&quot; &gt;设置为 true 之后就可以随意进行拖动了，但是要注意的是这里的拖动还是和上面提到的第一种的拖动方式是有很大的区别的，这种拖动方式只能拖动到另一个元素中，而不像是第一种方式没有限制。 dragenter 和 dragover 事件的默认行为是拒绝接受任何被拖放的元素,所以要想拖入目的地元素也还必须要先阻止其默认行为，否则也是拖不进去的。 最简单的拖拽例子：123456789101112131415161718192021222324252627282930313233&lt;style&gt; .box1 &#123; width: 200px; height: 200px; background-color: bisque; &#125; .box2 &#123; width: 300px; height: 300px; margin-top: 40px; background-color: aquamarine; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class="box1" draggable="true"&gt;&lt;/div&gt; &lt;div class="box2"&gt;&lt;/div&gt; &lt;script&gt; const box1 = document.querySelector('.box1'); const box2 = document.querySelector('.box2'); box2.ondrop = function (e) &#123; e = e || window.event; e.preventDefault(); e.target.appendChild(box1); &#125; box2.ondragover = function (e) &#123; e.preventDefault(); &#125; &lt;/script&gt;&lt;/body&gt; 这样就实现了最简单的拖拽，可以将一个元素拖拽到另一个元素中。 当然这是最简单的拖拽，完整的拖拽过程应该包括： 被拖拽元素的 dragstart(开始拖拽时触发) 、drag(拖拽过程中反复触发) 、dragend(在拖动操作完成时触发) 拖拽目的地的 dragenter(进入拖拽目的地触发) 、 dragover(在拖拽目的地内触发) 、dragleave(离开拖拽目的地触发) 以及 drop(在目的地内放下触发) 事件 这些事件就组成了一个完整的拖拽过程。可以根据这些事件来自定义拖拽时的表现。 dataTransfer如果需要在拖拽的过程中进行拖拽元素与目的地元素的数据交互就可以通过 dataTransfer 的 setData() 方法设置被拖数据的数据类型和值，然后通过 getData方法来获取相应的值。 还可以通过 dataTransfer 中的 files 属性来获取上传的文件列表从而实现拖拽上传的功能：1234567891011121314151617181920212223242526272829&lt;style&gt; .box2 &#123; width: 300px; height: 300px; margin-top: 40px; background-color: aquamarine; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class="box2"&gt;&lt;/div&gt; &lt;img src="" alt="" class="pre"&gt; &lt;script&gt; const box2 = document.querySelector('.box2'); box2.ondrop = function (e) &#123; e = e || window.event; e.preventDefault(); // 这里要注意的一件事情是直接看 dataTransfer 中的fileList是看不到任何的文件信息的，只有看 dataTransfer.files 才能看到文件信息 console.log(e.dataTransfer.files[0]); let file = e.dataTransfer.files[0]; let URL = window.URL || window.webkitURL; let imgURL = URL.createObjectURL(file); document.querySelector('.pre').setAttribute('src', imgURL); &#125; box2.ondragover = function (e) &#123; e.preventDefault(); &#125; &lt;/script&gt;&lt;/body&gt; 这里是通过 dataTransfer 对象的 files 属性来获取到文件的，并且将其进行预览,我这里所用的将图片进行预览的方式是通过 URL 对象来对其进行url转换的，也可以使用fileReader来实现，具体可以参考我前面的本地通过input:file来上传文件时所用的两种方式，这里。 这样就实现了拖拽上传图片并且预览的功能，可以来看一下效果图：这里没有对样式进行很细致的调整，可以根据自己的情况进行调整。 总结这篇文章介绍了两种常见的拖拽的方式，但是其实这两种方式的差别还是非常的明显的，应用场景差别也很大。 一个主要时通过拖拽来改变元素的位置，而另一个一般都是通过拖拽到指定区域来进行文件的上传，各有各的应用场景。]]></content>
  </entry>
  <entry>
    <title><![CDATA[JS函数节流与函数防抖]]></title>
    <url>%2F2019%2F09%2F22%2FJS%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81%E4%B8%8E%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;函数防抖与函数节流这两个概念可能不是这么经常会遇到，但是在很多场景却会经常遇到，比如说应用于常见的很多的事件，那么究竟什么是函数节流呢，什么又是函数防抖呢，其实这也不是什么复杂的概念，这里就来好好的谈一谈。 概念函数节流 所谓节流，就是指连续触发事件但是在 n 秒中只执行一次函数。 意思其实也是简单明了，就是这个函数在一定的时间内就一定只能执行一次。 函数防抖 所谓防抖，就是指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。 这句话可能一时间不是特别的好理解，但是换句话说，这句话的意思就是说如果连续执行一个函数，那么这个函数只有在最后一次才会生效。 何时需要使用函数节流与函数防抖通常都是应用与各种事件，因为很多事件通常会有非常高的触发频率，例如 resize 、input 、mouseMove 这类事件，通过函数节流与函数防抖就可以很好的限制其频率在我们理想的一个范围之内。 比如函数节流的应用场景： 页面资源滚动加载 高频率的重复点击 防止鼠标滚轮一次滚太多 其实不止这些，任何想要限制频率来减少资源的消耗的函数都可以通过函数节流来实现。 函数防抖的应用场景： resize获取窗口大小 文本框输入验证 很多场景都会用到函数防抖来只触发一次函数。 实现函数节流1234567891011121314151617181920212223242526272829303132function throttle(func, wait, options) &#123; let time, context, args, result; let previous = 0; if (!options) options = &#123;&#125;; let later = function() &#123; previous = options.leading === false ? 0 : new Date().getTime(); time = null; func.apply(context, args); if (!time) context = args = null; &#125;; let throttled = function() &#123; let now = new Date().getTime(); if (!previous &amp;&amp; options.leading === false) previous = now; let remaining = wait - (now - previous); context = this; args = arguments; if (remaining &lt;= 0 || remaining &gt; wait) &#123; if (time) &#123; clearTimeout(time); time = null; &#125; previous = now; func.apply(context, args); if (!time) context = args = null; &#125; else if (!time &amp;&amp; options.trailing !== false) &#123; time = setTimeout(later, remaining); &#125; &#125;; return throttled;&#125; 这个函数节流的功能比较全面，拥有第三个参数 options 为一个对象： leading：false 表示禁用第一次执行 trailing: false 表示禁用停止触发的回调 可以根据情况来配置参数来实现想要的功能。 函数防抖通过 setTimeout 来实现：12345678const _debounce = (func, wait) =&gt; &#123; let timer; return () =&gt; &#123; clearTimeout(timer); timer = setTimeout(func, wait); &#125;;&#125;; 也非常的好理解，在函数执行之前如果又调用了函数则会重新开启定时器。 总结这里介绍了关于函数节流与函数防抖的概念与实现，遇到类似需要的场景的时候就可以快速合理的应用起来以避免不必要的资源消耗。 参考浅析函数防抖与函数节流JavaScript 函数节流（throttle）的实现]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现图片懒加载]]></title>
    <url>%2F2019%2F09%2F22%2F%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图片懒加载是网页中常见的一种简单的技术，可以减轻页面首次加载的压力，是一种常见的页面性能优化的方式，这次就来看看它的究竟是如何实现的。 原理图片懒加载的原理十分的简单，就是页面中的图片并不会一次性全部加载完，而是在我们能看到这张图片的时候这张图片才会进行加载，而在加载这张图片之前，先用一张较小的图片来占位置，真正的图片地址放在自定义属性data-src中，需要加载时就将图片的src换成data-src。而如何判断我们有没有看见图片呢，这个可以通过比较图片距离网页顶部的距离和网页已经滚动的距离加上窗口的高度来实现，这样就实现了图片的懒加载。 实现html:123456789101112131415&lt;div class="main"&gt; &lt;ul class="imgList"&gt; &lt;li&gt;&lt;img src="./images/loading.png" data-src="./images/beach-exotic-holiday-248797.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="./images/loading.png" data-src="./images/blur-calm-waters-dawn-395198.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="./images/loading.png" data-src="./images/close-up-foliage-green-797797.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="./images/loading.png" data-src="./images/cool-wallpaper-dawn-hd-wallpaper-66997.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="./images/loading.png" data-src="./images/crop-cropland-daylight-1447092.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="./images/loading.png" data-src="./images/dark-flash-lightning-1114690.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="./images/loading.png" data-src="./images/daylight-dirt-road-forest-163703.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="./images/loading.png" data-src="./images/flowers-4352530_1280.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="./images/loading.png" data-src="./images/hd-wallpaper-mountain-range-mountains-114979.jpg" alt=""&gt; &lt;/li&gt; &lt;li&gt;&lt;img src="./images/loading.png" data-src="./images/stockvault-autumn-lake135956.jpg" alt=""&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; css:123456789101112.imgList &#123; width: 800px; margin: 0 auto; list-style: none; display: flex; flex-wrap: wrap;&#125;img &#123; width: 400px; height: 200px;&#125; js:123456789101112131415161718192021222324252627282930$(function () &#123; // 进入页面时也需要调用一次 start(); //当页面滚动时触发 $(window).on('scroll', function () &#123;// 滚动时，显示对应图片 start() &#125;) //判断图片是否需要显示 function isShow($node) &#123; return $node.offset().top &lt;= $(window).height() + $(window).scrollTop(); &#125; // 显示图片 function loadImg($img) &#123; $img.attr('src', $img.attr('data-src')); $img.attr('data-isLoaded', 1); &#125; //调用图片懒加载 function start() &#123; $('.imgList img').not('[data-isLoaded]').each(function () &#123; const $node = $(this); if (isShow($node)) &#123; loadImg($node); &#125; &#125;) &#125;&#125;) 总结图片懒加载是一个常见的简单又实用的一个小功能。 这里也可以再通过函数节流来对性能进行一定的优化]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS实现上传图片并且将图片缓存到本地]]></title>
    <url>%2F2019%2F09%2F16%2FJS%E5%AE%9E%E7%8E%B0%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E5%B9%B6%E4%B8%94%E5%B0%86%E5%9B%BE%E7%89%87%E7%BC%93%E5%AD%98%E5%88%B0%E6%9C%AC%E5%9C%B0%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实这篇文章是建立在前面的实现上传图片并且预览的文章之上的，也交代了其实做这些只是为了完成我的chrome插件的开发中的自定义上传图片并且保存下来，当时一开始没有一个满意的思路，不过现在通过搜索一些资料也想到了一个我比较满意的思路，这篇博客就来将这个思路实现一下。 思路我觉得最重要的就是思路，有一个满意的思路开发起来就会顺畅很多，刚开始的时候就是找不到合适的思路所以停了一段时间，现在我把我想到的思路说一下。 就是可以通过 input:file 来进行图片的上传，然后通过 local storage 来缓存上传的图片，这样就只需要上传一次，之后加载local storage中的图片就可以了。 在这之前我一直想不通的就是如何将图片保存下来，后面我看到了实现图片上传预览的这个例子我知道了原来只需要将图片转化为dataURL就可以了，还有一个问题就是该将图片保存在哪，最后觉得是保存在local storage 中是最好的。 之前我的错误思路一直想的都是如何把图片下载到本地，然后每次再加载本地的图片，首先是这样不好实现，其次是如果是这样的话只要图片在文件夹中修改或者移除，那么就会影响到页面的显示。 效果图在看是如何实现之前可以先看一下实现之后的效果图：从图片中可以看出有一个上传图标的上传框，然后下面就是上传的所有的图标，当页面关闭再重新打开也会一直存在，因为图片是从local storage中加载的，除非删除local storage中的数据，所以这样就实现了我想要的效果。 实现思路讲完了，来看一下究竟是怎么样实现的： HTML:123456789101112&lt;div class="uploadBox"&gt; &lt;div class="replaceBox"&gt; &lt;img class="iconPreview" src="" alt=""&gt; + &lt;input type="file" name="" id="uploadBt"&gt; &lt;/div&gt; &lt;input type="text" class="iconTitle" placeholder="图标标题"&gt; &lt;button class="comfir"&gt;确定&lt;/button&gt;&lt;/div&gt;&lt;ul class="list"&gt;&lt;/ul&gt; 这部分就非常的简单了，就两个部分，一个是上传框，一个是图片列表。 CSS:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879.uploadBox &#123; width: 400px; height: 300px; border: 1px solid #000; margin: 0 auto; margin-top: 40px; display: flex; flex-direction: column; align-items: center; &#125; #uploadBt &#123; border: none; position: absolute; width: 100px; height: 100px; opacity: 0; cursor: pointer; &#125; .replaceBox &#123; position: relative; display: flex; align-items: center; justify-content: center; width: 100px; height: 100px; border: 2px dashed #ccc; margin: 0 auto; margin-top: 20px; font-size: 60px; font-weight: 100; color: rgb(107, 94, 94); cursor: pointer; box-sizing: border-box; &#125; .iconTitle &#123; border: none; outline: none; border-bottom: 1px solid #000; text-align: center; margin-top: 20px; &#125; .iconPreview &#123; /* background-color: bisque; */ position: absolute; width: 100px; height: 100px; &#125; .comfir &#123; border: none; outline: none; background-color: cornsilk; border-radius: 2px; padding: 5px 2px; width: 80px; margin-top: 20px; cursor: pointer; &#125; .list &#123; margin: 50px auto; list-style: none; display: flex; width: 1000px; justify-content: center; &#125; .list li &#123; margin: 0 5px; background-color: aquamarine; border-radius: 5px; display: inline-flex; justify-content: center; align-items: center; &#125; css部分不重要，可以说的就是这个上传框样式的实现，因为css修改input:file的样式不是很好修改，所以我这里是通过些一个带样式的框绝对定位到input:file所在的区域，然后二者设置成同样的大小，将带样式的框完全覆盖住上传框，然后将上传框设置为完全透明，就实现了现在的上传框的样式。 JS：最重要的就是js了12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970$(function () &#123; const iconPreview = $('.iconPreview'); const uploadBt = $('#uploadBt'); const iconTitle = $('.iconTitle'); const comfir = $('.comfir'); const list = $('.list'); const imgList = []; let iconDataUrl; //这一部分是实现上预览的，可以参考前面的博客 uploadBt.change(function () &#123; const file = $(this)[0].files[0]; const fr = new FileReader(); fr.onload = function () &#123; iconPreview.attr(&#123; "src": this.result &#125;); iconDataUrl = this.result; // console.log(this.result); &#125; fr.readAsDataURL(file);//将图片作为url读出提交给result &#125;) //单击确定按钮就可以将图片保存进local storage中 comfir.click(function () &#123; //将新添加的图标的信息添加进local storage // localStorage.setItem(iconTitle.val(), iconDataUrl); //还需要将图标的名称以及图标的dataurl都存入一个图标的数组对象当中，然后通过遍历这个数组对象来生成图标的列表。 //可以通过一个函数来实现，函数的参数就是所需要存放的数据 // 通过点击确认按钮调用添加图标的函数 AddToList(iconTitle.val(), iconDataUrl); console.log(imgList); &#125;) //遍历local storage将其转化为一个对象数组 function CreateList() &#123; for (let i = 0; i &lt; localStorage.length; i++) &#123; let title = localStorage.key(i); let url = JSON.parse(localStorage.getItem(title)).url; let createDate = JSON.parse(localStorage.getItem(title)).createDate; imgList.push(&#123; title, url, createDate &#125;); imgList.sort((val1, val2) =&gt; &#123; return val1.createDate - val2.createDate &#125;) &#125; &#125; CreateList(); //通过这个函数将每次新添加的图标添加进local storage、以及对象数组、页面中 function AddToList(title, url) &#123; imgList.push(&#123; 'title': title, 'url': url, &#125;) list.append( `&lt;li&gt;&lt;img src="$&#123;url&#125;" alt=""&gt;&lt;/li&gt;` ) const iconInfoObj = &#123; url, 'createDate': new Date().getTime() &#125; localStorage.setItem(title, JSON.stringify(iconInfoObj)); &#125; //将对象数组中的所有对象添加到页面当中 function AddToHtml() &#123; imgList.forEach(function (item) &#123; list.append( `&lt;li&gt;&lt;img src="$&#123;item.url&#125;" alt=""&gt;&lt;/li&gt;` ) &#125;) &#125; AddToHtml(); &#125;) 需要解释的地方差不多都在注释中标出来了。 还有需要说一下的就是因为不知道local storage中对数据的排序方式是怎么样的，反正不是通过时间来排序的，所以会导致一个问题，最后在页面中生成的图标的列表会和预期的不一样（预期的是先添加的在前面），所以为了解决这个问题就需要通过时间来对生成的对象数组进行排序，就需要记录上传的时间，所以需要用对象来保存，但是在local storage中无法直接存储对象，需要进行转换，取出来的时候也同样需要进行转换，这个是需要注意的一点。 这里只实现了添加的功能，删除的功能就很简单了。 总结开发我的chrome插件也是遇到了挺多的问题的，从样式效果到功能实现，不过也都解决了，也学到了很多的新东西，不错。]]></content>
      <tags>
        <tag>CSS</tag>
        <tag>JS</tag>
        <tag>HTML</tag>
        <tag>chrome插件开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery原理解析]]></title>
    <url>%2F2019%2F09%2F15%2FjQuery%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在刚开始学习jQuery的时候就很配置能写出这样的库的人，虽然我能想到jQuery是通过内部封装了大量的方法来实现函数的扩展的，当时并不了解jQuery究竟是怎样将一个dom对象处理成一个jQuery对象的，又是如何处理其他对象的，直到我阅读了jQuery的源码还有结合别人对jQuery源码的理解我才理解了jQuery的源码的机制，也不得不感叹很多地方是如此的巧妙。所以这篇文章主要讲一下jQuery的核心函数以及一些机制。虽然jQuery已经有些过时了，当时我觉得学习了解这款优秀的项目也是提升自己的一大途径。 jQuery的基本结构理解jQuery源码，可以从jQuery的结构开始，jQuery是采用构造函数模式开发的，jQuery本身就是一个构造函数，是一个类而jQuery中的大部分的方法都是再这个类的原型上的，所以只有jQuery的实例才能使用这些方法或者是属性，而这些我们也可以通过它的源码看出：12345678910(function( window, undefined ) &#123; var jQuery = function( ) &#123; return new jQuery.prototype.init( ); &#125; jQuery.prototype = &#123; constructor: jQuery &#125; jQuery.prototype.init.prototype = jQuery.prototype; window.jQuery = window.$ = jQuery;&#125;)( window ); 这可以说就是jQuery最基本的结构了 首先是最外层是用了匿名的立即执行函数来包裹以防止污染全局，至于为什么要给这个函数传递一个 window 作为参数这是因为方便代码的压缩，形参中的 window 在代码压缩之后可能就不是 window 了，为了能找到正确的window所以可以这样设置。 接下来就是名为 jQuery 的构造函数了，这也是整个 jQuery 中最为核心的一部分了，这个构造函数中包含了jQuery中的一些很重要的方法，这其中就包括创建一个jQuery对象时所用到的 init() 方法,你可能会奇怪为什么创建jQuery对象的会是 init() 方法而不是我们平时所用的 jQuery这个构造函数呢，其实我们通过源码也可以看出，init() 这个方法是 jQuery 构造函数中的一个方法，当我们要通过 jQuery构造函数创建一个 jQuery对象的时候向核心函数传递了需要创建的对象，但是实际上返回的是通过 init() 这个构造函数所创建的实例对象，再修改 init 的原型，虽然这个实例不是jQuery构造函数的实例但却有着一样的原型，而这个实例就是我们俗说的jQuery对象。这样就实现了通过jQuery构造函数中的方法创建了一个jQuery的对象。 最后再将 jQuery 和 $ 注册为全局，这样就实现了jQuery最基本的一个结构，可以在全局中使用jQuery了，我觉得这种方式是很巧妙的， 不看源码的话我是怎么都想不明白究竟是怎么回事，不过这也是可以学习的地方，理解了jQuery的源码是怎么回事，就可以自己尝试着开发一个类似的函数库了。 jQuery构造函数接收不同的数据经过前面代码的了解我们现在知道其实jQuery构造函数接收数据其实真正进行处理的是它里面的 init 方法，因为我们使用过jQuery所以我们知道接收不同的参数，所返回的数据也是不一样的，比如说接收一个选择器返回的就是一个jQuery对象，如果接收的是一个空字符串之类的话返回的也就是一个空的jQuery对象，我们可以来看一下究竟是怎么样返回一个jQuery对象的，可以先看看jQuery的源码：123456789101112131415161718init: function( selector, context, rootjQuery ) &#123; var match, elem; // HANDLE: $(""), $(null), $(undefined), $(false) if ( !selector ) &#123; return this; &#125; // Handle HTML strings if ( typeof selector === "string" ) &#123; if ( selector.charAt(0) === "&lt;" &amp;&amp; selector.charAt( selector.length - 1 ) === "&gt;" &amp;&amp; selector.length &gt;= 3 ) &#123; // Assume that strings that start and end with &lt;&gt; are HTML and skip the regex check match = [ null, selector, null ]; &#125; else &#123; match = rquickExpr.exec( selector ); &#125; &#125; 这是 init 方法中的一小部分的源码，通过这里我们可以看出这是通过if语句判断接收的是什么类型的数据从而返回符合期望的实例对象，知道了这一点我们就很好理解jQuery是如何创建一个jQuery对象的了。 jQuery对象的属性与方法通过前面我们已经可以了解到其实jQuery对象就是通过jQuery构造函数中的 init 方法创建的一个实例，所以就很好理解了，jQuery对象所拥有的属性与方法全都是来自于jQuery构造函数的原型，通过原型机制 init 实例最终会去jQuery构造函数的原型中去找，所以就能找到所需要的属性或是方法，可以通过一张图来更加容易的理解： jQuery对象要调用某个jQuery中的方法或者属性的时候就会这样去找：init实例（jQuery对象）=&gt; init构造函数 =&gt; jQuery.prototype 总结jQuery作为一款比较常用的库，理解学习其原理还是非常有必要的，对于提升自己也是非常有帮助的，可以多看看优秀的项目的源码来提升自己，学习别人的思路。]]></content>
      <tags>
        <tag>JS</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS实现上传图片并且本地预览]]></title>
    <url>%2F2019%2F09%2F15%2FJS%E5%AE%9E%E7%8E%B0%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E5%B9%B6%E4%B8%94%E6%9C%AC%E5%9C%B0%E9%A2%84%E8%A7%88%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前面开发chrome插件还是遇到了挺多的困难的，其中一个就是如何将上传的图片缓存到本地，思路很简单，但是一直不知道该如何实现，现在有了办法了，主要是想通过上传图片然后通过img标签将其显示出来，再通过 localStorage 对其进行储存，这样是一个比较好的方案，我这篇文章所写的图片的预览也就是对第一步的一个实现。 实现思路其实思路还是比较简单的，我们都知道 input file 有一个 files 对象，这个对象中就保存了上传的文件的信息，我们只需要将上传的文件通过一些方法转化为 url ，然后通过 img 标签的 src 来加载它，就可以实现我们想要的功能了，这里主要通过两种不依赖后端的方式来实现。 使用 FileReaderFileReader也是 html5 的一个新的 API ，可以通过它来处理文件： HTML：12&lt;input type="file" class="uploadFile" name="test" id=""&gt;&lt;img src="" alt="" class="preview"&gt; 这里只做演示，所以代码很简单，主要就是一个上传文件的input，然后一个用来显示图片的 img 标签。 JS：12345678910111213$(function () &#123; const uploadFile = $('.uploadFile'); const preview = $('.preview'); uploadFile.change(function () &#123; let file = $(this)[0].files[0]; let fr = new FileReader(); fr.onload = function () &#123; // 通过result属性获取到转化后的url preview.attr(&#123; "src": this.result &#125;); &#125; fr.readAsDataURL(file);//将图片作为url读出提交给result &#125;)&#125;) 使用 window.URLhtml部分的代码是一样的。 JS：1234567891011$(function () &#123; const uploadFile = $('.uploadFile'); const preview = $('.preview'); uploadFile.change(function () &#123; let file = $(this)[0].files[0]; //通过url对象来将图片转化为url let URL = window.URL || window.webkitURL; let imgURL = URL.createObjectURL(file); preview.attr(&#123; "src": imgURL &#125;); &#125;)&#125;) 最后可以来看一下实现之后的效果： 今天新学的一点小知识今天这里又学到一些新东西，就是event.target,这个东西和this有点像，但是又有区别，target指向的dom对象永远不会变化，而this的指向可能会因为冒泡之类的而改变. 总结其实总的来说不管是使用那种方式来实现预览图片其原理都是一样的。 区别就在于 转化为 url 时所用的方法不一样。 还有就是兼容性问题，其实都差不多，老的ie一样还是都不兼容，可能用 FileReader 会好一点。]]></content>
      <tags>
        <tag>CSS</tag>
        <tag>JS</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS实现自定义鼠标右键菜单]]></title>
    <url>%2F2019%2F09%2F12%2FJS%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E9%BC%A0%E6%A0%87%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最近在我开发chrome扩展插件的过程中准备实现通过鼠标右键来打开一个菜单来添加删除导航以及修改背景图片等一系列的功能，这里来记录一下具体是如何实现这样的功能的以及注意实现。 这里通过一个小demo来进行演示，整体还是挺简单的，只要注意一些细节就好了。 先来看一下效果图：这个小的菜单框就是我自定义的鼠标右键菜单，这里没有太多的修饰，样式根据情况进行适当的调整就可以了。 HTML部分代码12345678910&lt;!-- 这个box模拟页面中的一部分 --&gt; &lt;div class="box"&gt;&lt;/div&gt;&lt;!-- 而这个列表就是我们需要的右键菜单了 --&gt; &lt;ul class="list"&gt; &lt;li&gt;菜单一&lt;/li&gt; &lt;li&gt;菜单二&lt;/li&gt; &lt;li&gt;菜单三&lt;/li&gt; &lt;li&gt;菜单四&lt;/li&gt; &lt;/ul&gt; CSS部分12345678910111213141516171819202122&lt;style&gt; * &#123; padding: 0; margin: 0; &#125; .box &#123; width: 400px; height: 400px; border: 1px solid #000; margin: 0 auto; margin-top: 20px; &#125; ul &#123; position: fixed; /* 这个菜单默认是不显示的 */ display: none; list-style: none; border: 1px solid #000; &#125;&lt;/style&gt; css唯一要注意的就是默认这个菜单是不显示的。 JS部分12345678910111213141516171819202122232425262728// 这里用了jQuery来写，不用也是差不多的 &lt;script src="./js/jquery-3.4.1.min.js"&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; const list = $('.list'); const box = $('.box'); // 鼠标右键事件 box.contextmenu(function (e) &#123; // 在return false 之前可以写自己想要的功能的代码 e = e || window.event; // 将菜单的位置设置为鼠标右键时的位置 list.css(&#123; 'top': e.pageY + 'px', 'left': e.pageX + 'px', &#125;); list.show();//将菜单显示出来 //禁用了原本的鼠标右键菜单 return false; &#125;) // 单击网页任意位置使菜单隐藏 $(window).click(function () &#123; list.hide(); &#125;) &#125;) &lt;/script&gt; 在注释中已经把需要注意的地方写出来了，这里在总结一下： contextmenu 事件是鼠标右键的事件 基本的原理就是通过鼠标右键的事件将我们自己定义的右键菜单定位到鼠标指针所在的位置，并且将其显示出来，然后鼠标左键单击时需要将这个菜单进行隐藏。 一定要将逻辑代码写在鼠标右键事件中的 return false之前。 总结鼠标右键自定义菜单本身挺简单的，这里在开发chrome插件的过程中使用到了，所以记录一下。]]></content>
      <categories>
        <category>页面小功能</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>chrome插件开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vuex的基本使用]]></title>
    <url>%2F2019%2F09%2F11%2FVuex%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vuex作为vue全家桶之一，使用vue开发的过程中有着无可替代的作用，可以解决多个组件中传值的问题，并且本身的使用也非常的简单，有着非常强大的作用。我把它理解为一个数据共享中心，所有的组件都共享这里面的数据，并且都可以对其中的数据进行修改。来看看它是如何发挥作用的。 安装首先是安装vuex，可以通过npm来安装vuex，注意，因为是生产所需要的依赖，所以需要-S选项：1npm install vuex -S 当然直接从官网下载然后引用也是可以的。 用法首先需要在项目目录下创建一个名为 store.js 的文件，这个文件就是我们vuex的主要文件，如果是在项目比较大的情况下，可以将这个文件中的各个部分单独拆分成一个文件，然后将所有的文件放在名为store的文件夹内。 store.js来看看store.js这个文件的基本内容及作用：123456789101112131415161718192021222324252627282930313233343536373839404142//正常的引入import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)export default new Vuex.Store(&#123; // 通过state对象来存储数据，然后可以在组件中通过this.$store.state来获取我们想要的数据 state: &#123; count: 1000 &#125;, // getters对象，这个对象和计算属性非常的像，用法也非常的像 getters: &#123; countAdd1(state) &#123; return state.count + 1 &#125; &#125;, //mutations是修改数据的地方，只有这里可以修改修改state中的数据 // 通过mutations就像是注册了一个事件一样，但是并没有将事件应用起来，还需要通过commit来将其进行提交 mutations: &#123; add1(state) &#123;//可以接收第二个参数作为这个函数的额外参数，最好是用一个对象来定义 state.count++ &#125;, redu1(state) &#123; state.count-- &#125; &#125;, // actions可以通过提交mutations来变更状态并且支持异步的操作 //actions接收一个和当前store实例具有相同的方法和属性的 context 对象，所以可以通过 context.commit 来提交一个 mutations actions: &#123; add1(context) &#123;//同样，在分发的时候也可以接收额外的参数 context.commit('add1'); &#125;, redu1(context) &#123; context.commit('redu1'); &#125;, &#125;, &#125;) 通过这样就相当于创建了一个数据的共享中心，然后就可以在各个组件中使用其中的数据了 在组件中使用还是以这个文件为例子，来看看如何使用其中的数据： 在组件中直接使用了state中的数据：store.js：123state: &#123; count: 1000&#125;, APP.vue:1&lt;p&gt;这是count的数值：&#123;&#123;this.$store.state.count&#125;&#125;&lt;/p&gt; 可以看到，成功获取了我们想要的数值。 通过 getters获得计算后的值：store.js：12345getters: &#123; countAdd1(state) &#123; return state.count + 1 &#125;&#125;, c1.vue:1&lt;p&gt;这是getters count+1后的数值：&#123;&#123;this.$store.getters.countAdd1&#125;&#125;&lt;/p&gt; 可以看出成功获取了通过getters计算后的值，并且我这里是在另一个组件中使用的数据，从这里也可以看出vuex管理下的数据共同是十分方便的。 通过 mutations 来修改数据前面的注释中也提到过 mutations 是修改数据的唯一途径，所有要修改state中数据的操作都必须在 mutations完成: store.js：12345678mutations: &#123; add1(state) &#123;//可以接收第二个参数作为这个函数的额外参数，最好是用一个对象来定义 state.count++ &#125;, redu1(state) &#123; state.count-- &#125;&#125;, APP.vue:12&lt;button class="add" @click="add1"&gt;+&lt;/button&gt;&lt;button class="redu" @click="redu1"&gt;-&lt;/button&gt; 12345678methods: &#123; add1() &#123;//可以接收额外的参数，推荐使用对象来传递多个参数 this.$store.commit("add1"); &#125;, redu1() &#123; this.$store.commit("redu1"); &#125;&#125; 可以看出可以通过 mutations 来对state中的数据进行修改，不过要使其生效必须要通过 commit使其生效，可以看出我这里使通过在组件中的methods中通过两个方法来进行提交。 关于mutations要注意的几点： mutations相当于是注册了事件一样，要生效需要提交，然后调用相应的方法 mutations 中不能写异步的任务，这点要十分的注意 mutations 中定义的方法可以接收额外的参数，并且推荐是使用对象来传递额外的多个参数，在通过commit进行提交的时候可以传递相应的参数，我这里没有使用，但是类似与这样： 1this.$store.commit("add1",&#123;count2:999&#125;); action 的使用Action 的作用与 mutations 类似，不过区别就是 Action 提交的是 mutations，而不是直接修改state中的数据，并且最终重要的是在Action 中可以进行异步的操作，这是action的使用：store.js：123456789//actions接收一个和当前store实例具有相同的方法和属性的 context 对象，所以可以通过 context.commit 来提交一个 mutationsactions: &#123; add1(context) &#123;//同样，在分发的时候也可以接收额外的参数 context.commit('add1'); &#125;, redu1(context) &#123; context.commit('redu1'); &#125;,&#125; APP.vue:12&lt;button class="add" @click="add1"&gt;+&lt;/button&gt;&lt;button class="redu" @click="redu1"&gt;-&lt;/button&gt; 12345678methods: &#123; add1() &#123; this.$store.dispatch("add1"); &#125;, redu1() &#123; this.$store.dispatch("redu1"); &#125;&#125; 这里是就没有通过 mutations 的方式来进行提交，而是通过 action 来提交 mutations ，然后通过在组件中分发 action 来实现对数据进行修改 ，这种方式实现的最终效果和上面的 mutations 演示所实现的效果是一样的，不过最大的区别就是在 action中提交 mutations 的时候是可以进行异步操作的。 使用 mutations 和 action 来进行修改数据的区别这里之所以单独提出来将是因为刚开始的时候不太清楚这两个究竟是怎么回事，现在弄明白了，所以单独详细的讲一下： 首先就是使用步骤方面的区别，在 mutations 中定义的方法只需要在组件中通过 commit 提交就可以使用了，如果是使用 action 的话则需要先在 mutations 中定义修改数据的方法，然后在 action 中再定义方法提交 mutations 中的方法，最后需要使用的话则需要在组件中通过 dispatch 来分发 action 中定义的方法使修改生效。 再一个就是定义在 mutations 的方法不能写异步的任务，但是写在 action 中的方法则可以写异步的任务。 这里提一下 commit 和 dispatch 的区别，简单来说 commit是用来提交 mutations 中的方法的， dispatch 是用来提交 action 中的方法的，前者不支持异步，后者支持异步。 在不需要异步任务的情况下直接使用 mutations 和使用 action的结果没有什么区别，主要区别就是在需要异步的情况下，推荐是无论什么情况都使用action来提交。 使用 mapState 、mapGetters 、 mapMutations在官方文档中者三个方法被称为辅助函数，这样理解是没有什么问题的，因为作用其实也就是使我们使用vux更加的简便，拿来看看他们究竟能起到怎么样的作用： 如果我们不使用这些辅助函数，那么我们经常要很繁琐的书写一些代码来使用vuex，就像是这样： 1&lt;p&gt;这是getters count+1后的数值：&#123;&#123;this.$store.getters.countAdd1&#125;&#125;&lt;/p&gt; 可以看出这里通过this.$store.getters这么长的代码来获取数据是非常不方便的一件事情，所以就需要使用辅助函数,辅助函数的使用也是非常的简单，我们一个个来看一下（一样的还是基于前面的例子）。 mapState 辅助函数使用之前需要将其引入：1import &#123; mapState &#125; from "vuex"; 在 computed中使用：123456789101112131415161718computed: &#123; //这里使用了扩展运算符，将mapState返回的对象扩展到computed对象当中，以保证不会影响 computed 原本的使用。 ...mapState(&#123; // 第一种方式，使用箭头函数，通过mapState将state中的count映射为此组件date中的count count: state =&gt; state.count // 更加简便的一种写法，与上面的作用是相同的 // count: "count", // 因为键值都是一样的，所以还可以写的更加的简单 // count, // 为了不改变this的指向，必须用常规函数 // count(state) &#123; // return state.count + this.localCount; // &#125; &#125;)&#125; 这里这几种写法的结果都是一样的，可以根据情况进行选择，这样使用之后的结果都是一样的。 之后就可以像使用data中的数据一样使用原本state中的数据了:1&lt;p&gt;这是count的数值：&#123;&#123;count&#125;&#125;&lt;/p&gt; 当页面中重复使用到同一数据的时候就可以提供很大的便利。 mapState 辅助函数使用之前需要将其引入：1import &#123; mapGetters &#125; from "vuex"; 同样也是在computed中使用，使用起来与 mapState 类似：123computed: &#123; ...mapGetters(["countAdd1"]) //这里是使用的数组的形式，也可以使用对来来进行重命名&#125; 之后使用起来也就更加的简便了：1&lt;p&gt;这是getters count+1后的数值：&#123;&#123;countAdd1&#125;&#125;很棒！&lt;/p&gt; mapMutations 辅助函数当我们在组件中对 mutations 进行提交的时候就可以使用 mapMutations 来进行简化。 同样使用前需进行引入：1import &#123; mapMutations &#125; from 'vuex' 这里引用了官网的例子：1234567891011121314export default &#123; // ... methods: &#123; ...mapMutations([ 'increment', // 将 `this.increment()` 映射为 `this.$store.commit('increment')` // `mapMutations` 也支持载荷： 'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.commit('incrementBy', amount)` ]), ...mapMutations(&#123; add: 'increment' // 将 `this.add()` 映射为 `this.$store.commit('increment')` &#125;) &#125;&#125; 之后我们在组件中使用的时候就会变得更加简便：1&lt;button class="add" @click="increment"&gt;+&lt;/button&gt; 在大量重复使用同一数据的情况下使用辅助函数可以提供便利，所以根据情况合理使用吧！ 总结vuex是一个简单使用的工具，但是功能很强大，可以解决很多的问题，在适当的场景适当使用可以发挥很强作用。]]></content>
      <tags>
        <tag>JS</tag>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sass的简单使用]]></title>
    <url>%2F2019%2F08%2F29%2Fsass%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sass是一门css的扩展性语言，起初在没有使用sass之前，我写css其实并不是一件让人很舒服的过程，因为写的过程经常要写很多重复的代码，父级选择器也要一直复制来复制去，也不是很好维护和管理，直到我认识了sass，第一次听说css扩展语言还是在bootstrap官网，看到说bootstrap4使用sass替代了less，才知道css还有扩展语言这么一回事，特别是当上手开始使用sass之后真的是会让人感觉特别的惊喜，因为写起来太舒服了。 安装虽然中文文档中有安装的教程，但是还是要另外提一下，那个太久了，如果完全按照那个来的话最终是安装不了的。 sass 是基于 ruby 开发的，所以安装 sass 之前需要先安装 ruby，直接到官网下载安装即可（记得添加进PATH）。 通过命令行查看版本，如果出现版本信息则安装成功：12$ ruby -v$ ruby 2.5.5p157 (2019-03-15 revision 67260) [x64-mingw32] 然后是替换gem源，换成速度更快的国内的源：123456$ gem sources --add https://gems.ruby-china.org/ --remove https://rubygems.org/$ gem sources -l*** CURRENT SOURCES ***https://gems.ruby-china.org# 请确保只有 gems.ruby-china.org 与中文文档有区别的也就是这里，中文文档中的国内镜像的地址已经不维护使用了，所以要用新的地址。 然后就可以开始安装使用sass了12$ gem install sass$ gem install compass 具体的使用方法可以参考中文网 ，因为通常都是在编辑器中配合插件使用，我是使用vscode配合Easy Sass插件进行自动编译，所以这里就不做过多的介绍了。 sass中比较常用的一些特性在sass中有非常多的功能与特性，我在这里只介绍一些比较常用的特性，光是使用这些特性就已经能够使书写css样式轻松非常的多了。 嵌套我之前没有接触过css的扩展语言，当我第一次接触到sass的嵌套的时候我就觉得这个太方便了，因为之前写css总要经常性的重复书写父级的选择器，这是很麻烦的一件事情，但是在sass中可以直接嵌套书写： 在css中,我们经常需要重复写父级： 123456.main .left &#123; left: 100px;&#125;.main .right &#123; right: 100px;&#125; 但是在sass中，直接嵌套在其中就可以了： 1234567891011121314151617.main &#123; width: 800px; height: 600px; background-color: antiquewhite; margin: 0 auto; position: relative; .left &#123; @extend .position; left: $bj; &#125; .right &#123; @extend .position; right: $bj; &#125;&#125; 可以看出这样使非常的方便，并且我认为这不仅仅是使我们少写了很多的css重复代码，这还使我们的css结构看起来更加的清晰，子级与父级的关系一目了然，并且因为有了这样清晰的结构，所以在vscode的大纲中的结构也是一目了然，这使得后期维护变得非常的方便，再也不用担心找不到想找的样式的代码在哪里了。我觉得光这一个特性就已经使书写css的过程发生质变了。 这样嵌套生成的是后代选择器，如果要嵌套出子代选择器或者兄弟选择器只需要在前面加上相应的符号就好了：123456789101112.main &#123; width: 800px; height: 600px; background-color: antiquewhite; margin: 0 auto; position: relative; &gt; .left &#123; @extend .position; left: $bj; &#125;&#125; 可以用&amp;替代父级，比如说用到hover的时候：12345.main &#123; :hover &#123; color: aqua; &#125;&#125; 直接这样写是不能如我们所想的那样解析的，需要像这样写，用&amp;代替父级：123456```css.main &#123; &amp;:hover &#123; color: aqua; &#125;&#125; 可以看一下，通过查看大纲就可以很轻松的定位相应css的位置了： 这里再提一下其实不仅仅是选择器可以进行嵌套，其实属性也是可以嵌套的，但是因为可能书写起来不是那么的方便并且使用场景也相对较少所以就不多提了。 变量sass中的变量也是一个能够提升开发维护效率的一个特性，因为我们经常要对很多的选择器设置一样的属性，通常都是通过复制粘贴来实现，这不方便并且不便于维护，当要修改时全部都得改一遍十分的麻烦，通过再sass中使用变量就可以解决这个问题。 变量的使用也是十分的简单，通过$来设置变量名，就像这样：1234567891011$bj:100px;.left &#123; @extend .position; left: $bj;&#125;.right &#123; @extend .position; right: $bj;&#125; 这样只要是用到了变量的地方就都会被变量的属性值替代了，只要修改了变量，所有用到了相应变量的地方也会一起随着变化，所以这会是维护变得极其的简单。 要注意的一点是变量只在定义的相应的区域内有效，超出了范围就没有效果了。 混合器我的理解是混合器更像是大段的变量一样，和变量类似，可以用来设定那些会重复使用的代码片段，并且还可以传递参数用来进行细微的区分。 比如说我这里有两个小块，和一个大块，两个小块在大块中，区别就是一个在左，一个在右，剩下的都一样，这个时候我们就可以使用混合器来复用代码了:1234567891011121314151617181920212223242526272829.main &#123; width: 800px; height: 600px; background-color: antiquewhite; margin: 0 auto; position: relative;//将通用的代码提取出来 @mixin position &#123; position: absolute; top: 50%; transform: translateX(-50%); -webkit-transform: translateX(-50%); -moz-transform: translateX(-50%); -ms-transform: translateX(-50%); -o-transform: translateX(-50%); &#125;//通过@include引入 .left &#123; @include position; left: 100px; &#125; .right &#123; @include position; right: 100px; &#125;&#125; 这样就实现了代码复用，对于这些公用的样式以后直接修改混合器中的内容就可以了 甚至还可以通过使用参数来进一步的简化：12345678910111213141516171819202122232425262728.main &#123; width: 800px; height: 600px; background-color: antiquewhite; margin: 0 auto; position: relative; //可以通过键值对的形式来设置默认参数 @mixin position ($l:unset, $r:unset) &#123; position: absolute; top: 50%; transform: translateX(-50%); -webkit-transform: translateX(-50%); -moz-transform: translateX(-50%); -ms-transform: translateX(-50%); -o-transform: translateX(-50%); left: $l; right: $r; &#125; .left &#123; @include position(100px, unset); &#125; .right &#123; @include position(unset, 100px); &#125;&#125; 可以看出通过参数就可以完成对不一样的地方进行设置。 这里再来说一下混合器的实现原理，原理其实是代码的复制，也就是将混合器中的代码复制到包含这个混合器的选择器中。缺点可能就是编译后的css文件会有比较多的代码。 来看下效果： 继承继承的就是我们理解的那个继承，可以在一个选择其中继承另一个选择器的全部内容（包括与其相关的选择器），继承的作用与用法与混合器有些相似，但是区别在于继承的一定也是一个选择器并非一个单独的代码段，在实现的原理方面，混合器是单纯的复制代码，而继承则是复制选择器，可以将上面的例子通过继承来实现：123456789101112131415161718192021222324252627282930.main &#123; width: 800px; height: 600px; background-color: antiquewhite; margin: 0 auto; position: relative; //定义一个要继承的类，相当于如果我们不使用继承，而使用两个类，那么这个就是基类 .position &#123; position: absolute; top: 50%; transform: translateX(-50%); -webkit-transform: translateX(-50%); -moz-transform: translateX(-50%); -ms-transform: translateX(-50%); -o-transform: translateX(-50%); &#125; $bj:100px; .left &#123; @extend .position; left: $bj; &#125; .right &#123; @extend .position; right: $bj; &#125;&#125; 其实相较于使用混合器，我更喜欢使用继承来实现复用，因为这样编译后的代码更加的少，但是混合器的优势也很明显，可以参数。 你完全可以放心地继承有后代选择器修饰规则的选择器，不管后代选择器多长，但有一个前提就是，不要用后代选择器去继承。 导入样式文件css提供的导入css文件的方式速度比较慢，所以sass中还提供了一种导入sass文件的方式，当然也可以导入css文件只不过这样做的话采用的还是css的那种方式，不过其实现在都是采用打包工具进行开发在页面入口文件中导入不同的样式文件，都不会在css中去导入样式文件，不过还是要简单的提一下。 在sass中可以通过 @import来导入样式sass文件，并且可以不需要添加后缀名，比如1@import "content" 也可以导入部分的sass文件，比如一个sass文件只是需要的部分代码，那么它的文件名就可以以_开头，这样做的话就不会被编译了，导入的时候也可以省略前面的_。 导入css文件的话只需要上css后缀就可以，不过这种方式还是通过css的比较慢的方式来导入：1@import &quot;content2.css&quot; 总结sass有着众多强大的特性，那怕仅使用我这篇文章提到的特性都已经可以大大提升开发效率以及维护的效率了，太好用了，熟练掌握之后就可以愉快的书写样式了！]]></content>
      <tags>
        <tag>CSS</tag>
        <tag>Sass</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack单页面配置与多页面配置以及各方面优化]]></title>
    <url>%2F2019%2F08%2F26%2Fwebpack%E5%8D%95%E9%A1%B5%E9%9D%A2%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%A4%9A%E9%A1%B5%E9%9D%A2%E9%85%8D%E7%BD%AE%E4%BB%A5%E5%8F%8A%E5%90%84%E6%96%B9%E9%9D%A2%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这几天都在琢磨着配置好webpack的多页面配置以及优化，原本只是其实配置过一份简单的版本，但是对webpack其实也不是特别的熟悉，所以这次配置多页面以及优化还是踩了不少坑的，不过总之是配置好了一份自己满意的配置，可以愉快的用webpakc来打包项目了。 webpack单页面配置其实在之前开始学习webpack的时候就已经配置好了一份简单的webpack单页面的配置，但是当时也只是简单的配置，没有考虑到性能的优化之类，所以不是特别的满意，目录结构考虑的也不是很周到，对webpack的理解也非常的浅，然后现在的这份webpack配置就是我目前很理想的配置了。 目录结构可以先来看一下项目最终打包好的目录结构：12345678910111213141516171819202122232425262728293031323334│ package-lock.json│ package.json│ webpack.common.js│ webpack.dev.js│ webpack.prod.js│├─dist│ │ index.34b749f14486ceb6af7a.js│ │ index.html│ │ index9e2d405ad193f7d585f9.css│ ││ └─aseets│ └─images│ 92dcab1797689d6d87ef20dd22c47be6.png│ a7a91ea31281adbf0ea7a3213fdd6f96.png│ b88a75406eaf6c2f133482b0f4b56833.png│ e07b8dbff850e41c69522320b0c5ea87.png│ fbcc569b7c705a3c80d2fa95e3a17226.png│└─src │ index.css │ index.html │ index.js │ index.min.css │ index.scss │ └─aseets ├─fonts └─images 1.png 2.png 3.png 4.png strawberry.png 这个是我个人比较习惯的一个路径，在单页面的时候路径就简单的多了。 配置文件详细信息在之前我是只是用一个配置文件的，可是后来发现开发环境和生产环境的差别确实很大，需要分别配置，这里我是使用了一款叫做webpack-merge的插件，这也是官方文档中使用的插件，需要了解详细的用法的话，也可以前往官方文档进行查看。 这里通过插件将配置文件拆分成三部分，分别是公用配置、开发环境配置、生产环境配置，分别如下： webpack.common.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980const path = require('path');const htmlWebpackPlugin = require('html-webpack-plugin');const MiniCssExtractPlugin = require('mini-css-extract-plugin');//配置信息module.exports = &#123; entry: &#123;// 项目入口文件 index: './src/index.js', &#125;, output: &#123; // 配置输出选项 path: path.resolve(__dirname, 'dist'), // 配置输出的路径 // filename: '[name].js', // 分别配置dev与prod &#125;, module: &#123; noParse: [/jquery/, /react\.min\.js$/], //当webpack打包时忽略这些文件，因为没有采用模块化开发，同时建议通过cdn的方式来引入非模块化的文件 rules: [ // 匹配规则 //匹配图片 &#123; test: /\.(png|jpg|gif)$/, use: ['url-loader?outputPath=aseets/images&amp;limit=8192&amp;name=[contenthash].[ext]&amp;fallback=file-loader'] &#125;, //匹配字体 &#123; test: /\.(ttf|eot|svg|woff|woff2)$/, use: ['file-loader?outputPath=aseets/fonts'] &#125;, // 抽离css并压缩 &#123; test: /\.css$/, use: [MiniCssExtractPlugin.loader, 'fast-css-loader'] &#125;, &#123; test: /\.(sass|scss)$/, use: [MiniCssExtractPlugin.loader, 'fast-css-loader', 'fast-sass-loader'] &#125; ], &#125;, // 通过externals可以检索外部依赖，而不需要本地依赖也能通过 import引用。 externals: &#123; echarts: 'echarts', jquery: 'jQuery', &#125;, //抽出第三方库文件 optimization: &#123; // runtimeChunk: 'single', splitChunks: &#123; cacheGroups: &#123; vendor: &#123; test: /[\\/]node_modules[\\/]/, name: 'vendors', chunks: 'all' &#125; &#125; &#125; &#125;, plugins: [ new htmlWebpackPlugin(&#123; template: path.resolve(__dirname, 'src/index.html'),//圆文件路径 filename: 'index.html'//自动生成的HTML文件的名称 &#125;), // 抽离css new MiniCssExtractPlugin(&#123; filename: '[name][contenthash].css' &#125;), ],&#125; 这里的配置比较简单都是一些常用的配置及插件配置，这里需要注意的一件事就是因为在开发环境中我不需要使用到 [contenthash] 来为入口文件命名，所以output.path这部分我在其他两份配置文件进行了配置。 webpack.dev.js123456789101112131415161718const merge = require('webpack-merge');const common = require('./webpack.common.js');const webpack = require('webpack');//配置信息module.exports = merge(common, &#123; mode: 'development', output: &#123; // 配置输出选项 filename: '[name].js', // 配置输出的文件名 &#125;, plugins: [ new webpack.HotModuleReplacementPlugin(), ], devServer: &#123; hot: true, open: true, &#125;,&#125;) 开发环境需要单独配置的很少，主要就是热更新的配置。 webpack.prod.js1234567891011121314151617181920212223242526272829const merge = require('webpack-merge');const common = require('./webpack.common.js');const &#123; CleanWebpackPlugin &#125; = require("clean-webpack-plugin");const OptimizeCSSAssetsPlugin = require('optimize-css-assets-webpack-plugin');const TerserJSPlugin = require('terser-webpack-plugin');module.exports = merge(common, &#123; mode: 'production', output: &#123; // 配置输出选项 filename: '[name].[contenthash].js', // 配置输出的文件名 &#125;, // 压缩js与css optimization: &#123; minimizer: [ new TerserJSPlugin(&#123; cache: true, parallel: true, &#125;), new OptimizeCSSAssetsPlugin(&#123;&#125;) ], &#125;, plugins: [ new CleanWebpackPlugin(), ],&#125;); 生产环境的配置就相对多一些了，主要就是打包清理的插件以及压缩的插件。 在两个环境的配置文件配置好之后就可以用起来了，这里要注意的是现在这样是不能直接拿来用的，我刚开始就是忽略了这点，想要生效还需要在打包或者通过 dev 预览的时候指定配置文件就行，我是通过pakage.script来指定的，像是这样：1234"scripts": &#123; "start": "webpack-dev-server --config webpack.dev.js", "build": "webpack --config webpack.prod.js"&#125;, 单页面的配置就这样配置好了，我做的优化以及插件相关的问题我会到优化部分再说。 webpack多页面配置上面是单页面的配置，那么我们肯定不会只进行单页面的开发，多页面的开发也是非常常见的，多页面的配置就会相比要复杂一些，因为页面更加的多。 目录结构这是我多页面的页面结构，index.html的位置还是一样的，将其他的所有页面进一个文件夹内，css、js也是同理：123456789101112131415161718192021222324252627282930313233343536373839404142│ package-lock.json│ package.json│ webpack.common.js│ webpack.dev.js│ webpack.prod.js│├─dist│ │ index.html│ ││ ├─pages│ │ page1.html│ │ page2.html│ ││ └─static│ └─js│ index.acb8d4a0a354c09aa1a5.js│ page1.08868399604c484bbd2a.js│ page2.ab4baec0ced2346793dd.js│└─src │ index.html │ ├─aseets │ ├─fonts │ └─images │ bb.png │ cm.png │ ├─pages │ page1.html │ page2.html │ └─static ├─css │ index.scss │ page1.scss │ page2.scss │ └─js index.js page1.js page2.js 以上就是我多页面的配置文件，可以看出单页面与多页面在目录的结构方面差别还是很大的。 配置文件详细信息dev 和 prod因为基本上没有什么太大的变化就合在一起讲一下变化吧： 仔细一看其实没有什么大变化 唯一的变化也就是因为是多页面，所以在使用 devServer 的时候要更改一下默认的打开路径，方便管理其他页面： 123456devServer: &#123; hot: true, open: true, openPage: '/pages', contentBase: 'src',&#125;, webpack.common.js变化比较大的也就是这份common了，其实变化大主要是要修改多页面以及这些入口文件的输出位置。 由于页面的数量不是固定的而且我也不想每次都去修改配置文件，所以我采用了动态获取所有的页面并且将其入口文件进行打包到指定文件夹中，这样进行开发的时候就比较省事了。 这是配置文件：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116const path = require('path');const htmlWebpackPlugin = require('html-webpack-plugin');const MiniCssExtractPlugin = require('mini-css-extract-plugin');const glob = require('glob');// 生成所页面的入口文件function entries() &#123; const jsDir = path.resolve(__dirname, 'src/static/js'); const entryFiles = glob.sync(jsDir + '/*.js'); let map = &#123;&#125;; for (let i = 0; i &lt; entryFiles.length; i++) &#123; let filePath = entryFiles[i]; let filename = filePath.substring(filePath.lastIndexOf('\/') + 1, filePath.lastIndexOf('.')); map[filename] = filePath; &#125; return map;&#125;//生成pages中的所有htmlWebpackPlugin的配置信息let pluginarr = [];let HWP = function () &#123; let conf, filename; const htmlDir = path.resolve(__dirname, 'src/pages'); const htmlFiles = glob.sync(htmlDir + '/*.html'); for (let i = 0; i &lt; htmlFiles.length; i++) &#123; filename = htmlFiles[i].substring(htmlFiles[i].lastIndexOf('\/') + 1, htmlFiles[i].lastIndexOf('.')); conf = &#123; template: path.resolve(__dirname, 'src/pages/' + filename + '.html'),//圆文件路径 filename: path.resolve(__dirname, 'dist/pages/' + filename + '.html'),//自动生成的HTML文件的名称 title: filename, chunks: [filename], &#125; pluginarr.push(new htmlWebpackPlugin(conf)); &#125;&#125;HWP();//配置信息module.exports = &#123; entry: entries(), output: &#123; // 配置输出选项 path: path.resolve(__dirname, 'dist/static/js'), // 配置输出的路径 // filename: '[name].js', // 分别配置dev与prod &#125;, module: &#123; noParse: [/jquery/, /react\.min\.js$/], //当webpack打包时忽略这些文件，因为没有采用模块化开发，同时建议通过cdn的方式来引入非模块化的文件 rules: [ // 匹配规则 //匹配图片 &#123; test: /\.(png|jpg|gif)$/, use: ['url-loader?outputPath=aseets/images&amp;limit=8192&amp;name=[contenthash].[ext]&amp;fallback=file-loader'] &#125;, //匹配字体 &#123; test: /\.(ttf|eot|svg|woff|woff2)$/, use: ['file-loader?outputPath=fonts'] &#125;, // 抽离css并压缩 &#123; test: /\.css$/, use: [MiniCssExtractPlugin.loader, 'fast-css-loader'] &#125;, &#123; test: /\.(sass|scss)$/, use: [MiniCssExtractPlugin.loader, 'fast-css-loader', 'fast-sass-loader'] &#125; ], &#125;, // 通过externals可以检索外部依赖，而不需要本地依赖也能通过 import引用。 externals: &#123; echarts: 'echarts', jquery: 'jQuery', &#125;, //抽出第三方库文件 optimization: &#123; // runtimeChunk: 'single', splitChunks: &#123; cacheGroups: &#123; vendor: &#123; test: /[\\/]node_modules[\\/]/, name: 'vendors', chunks: 'all' &#125; &#125; &#125; &#125;, plugins: [ new htmlWebpackPlugin(&#123; template: path.resolve(__dirname, 'src/index.html'),//圆文件路径 filename: path.resolve(__dirname, 'dist/index.html'),//自动生成的HTML文件的名称 title: 'index', chunks: ['index'], &#125;), ...pluginarr, // 抽离css new MiniCssExtractPlugin(&#123; filename: '[name][contenthash].css' &#125;), ]&#125; 这里说一下我在写这些配置的时候遇到的一些困难： 首先是因为对node.js不了解，所以在参照别人进行动态的获取指定文件夹内的所有文件的文件名的时候遇到了一些困难，然后编写函数的时候也会困难一些，因为不知道那些node中的函数是什么意思，后来把这些不认识的node函数都查了一遍就理解了，从而实现了遍历所有的入口文件，也就是这部分：1234567891011121314function entries() &#123; const jsDir = path.resolve(__dirname, 'src/static/js'); const entryFiles = glob.sync(jsDir + '/*.js'); let map = &#123;&#125;; for (let i = 0; i &lt; entryFiles.length; i++) &#123; let filePath = entryFiles[i]; let filename = filePath.substring(filePath.lastIndexOf('\/') + 1, filePath.lastIndexOf('.')); map[filename] = filePath; &#125; return map;&#125;//然后将函数返回的对象传递给entry就行了。entry: entries(), 动态配置htmlWebpackPlugin也是类似，不过会稍微麻烦一点，原理是一样的。 遇到的第二个比较大的困难就是网上的资料不是特别的齐全与准确，也花费了我比较多的时间首先是因为不了解node，所以不知道还需要先安装glob这个模块才能使用，一开始还以为是自带的不用安装，然后就是参照别人的动态配置htmlWebpackPlugin的函数，然后写了自己的函数，但是花了很多的时间总是的不到我想要的效果，最后发现最坑的是在有一处需要写htmlWebpackPlugin这段代码，我肯定是选择复制一下会更加的方便，结果我从别人的代码里复制，结果复制来的是HtmlWebpackPlugin,可能很多人这样看都没有看出什么问题，我一开始也没意识到问题的严重性，但是又总是报错HtmlWebpackPlugin没有定义，我心里那个气啊，不是定义了吗？怎么就没定义了，知道后来我发现我的代码里面怎么有一个叛徒HtmlWebpackPlugin???，这个开头的字母错了啊，我的天啊，困扰我这么久的竟然是这个问题，我竟然复制的别人的是错了，我真不明白那个老哥的配置是怎么生效的，我崩溃啊，好在问题解决了。 后来又遇到的一个比较严重的问题就是对node中的__dirname理解的不对，这导致我在截取不带后缀的文件名的时候出现了问题，后面意识到了问题，进行了改正。 还有一个不够细心造成的问题，在配置没有完全配置好之前我进行了一次测试性的打包，导致将 index.html 打包进了 src 目录中，这不是问题的重点，重点是，这个文件中注入了三个入口js，所以导致我在后面打包的时候无论怎么修改配置，想尽办法，打包出来的 index.html 都会带有四个入口文件，我实在是没想明白怎么回事，头疼，后面经过排查，最终排查到src下的index.html，最终发现了问题。 webpack优化前面只是展示了一下单页面与多页面的配置，插件具体的作用以及我所作的优化都没有详细进行介绍，这里来专门讲一下我在webpack的打包与代码质量方面所做的优化。我将这些优化分为两部分，一是优化之后提高打包速度，二是优化之后提升用户体验。 提升打包速度缩小webpack打包时的解析范围对于那些非模块化开发的库文件可以通过 module.noParse 字段来将其排除在webpack的解析范围之外。像是jQuery和echarts这种，因为这些本身就是非模块化开发的，所以没必要浪费资源进行解析。我的配置文件是这样设置的：1noParse: [/jquery/, /react\.min\.js$/], 其实除了这样处理可以缩小解析范围，大部分loader也可以通过配置来缩小解析范围。 使用速度跟快的loader部分官方loader有时存在bug的，并且速度也不是最快的，这里我使用了两款关于css的loader，分别时 fast-css-loader 以及 fast-sass-loader ，使用方法基本上和普通版是一样的，详细的使用办法可以看这篇文章 使用happypackwebpack原本的打包过程是单线程的，通过这款插件可以使各loader的打包过程变为多线程的，其实我的配置文件中并没有使用它，因为对 file-loader 和 url-loader 支持的不好，而且我还使用了抽离css的插件导致css-loader也不支持了，也就babel-loader有用了，但是我基本上不写需要balel的代码，用不到，所以就不做过多介绍了。 提升用户体验使用cdn通过将静态资源（除了html文件）存放到cdn中并且开启缓存来对资源的加载进行加速。这里要注意的必须是文件名带上内容计算出的hash，不能能直接使用hash来进行缓存，一定要使用内容计算出的hash，也就是 contenthash 来进行缓存（通过看我的配置文件可以看出我是使用了contenthash），因为如果直接使用hash的话就会导致每次打包的时候所有文件都会重新生成hash，那么这样生成的hash就没有意义了。 非模块化库使用cdn如果没有选择将大部分资源放到cdn中的话，对于那些非模块话开发的库文件，可以通过cdn来将其引入，这样可以减少打包后的体积，并且也可以使这些文件的加载速度变快（这样处理之后其实也就没必要骗用到上面的优化办法了，也看具体情况吧）。 这里再补充一下如果这时还需要通过引入模块的方式来引入这些通过cdn引入的文件的话该怎么办，可以通过 module.externals 来解决，像是我这样：1234externals: &#123; echarts: 'echarts', jquery: 'jQuery',&#125;, 属性名 jquery是表示 import $ from ‘jquery’ 应该排除jquery模块,而属性值jQuery 表示将检索一个 jQuery 来当作全局变量。这样就可以通过引入模块的方式来继续使用这些库了。 抽离css抽离的好处不用注入样式，减少性能开销，可以对样式进行压缩，减少代码大小。 可以通过 mini-css-extract-plugin 插件来实现，可以参考我的配置文件中的关于 mini-css-extract-plugin 插件的配置信息。 抽离之后记得取消使用 style-loader 。 压缩代码我使用的是webpack4.x的版本，已经是默认再生产模式下是自动压缩js与css文件了。 但是这里还是要提一下如何手动配置对js或者是css文件进行压缩，我这里是配置了的，我为什么要配置呢，其实主要是因为我在前面提到了我是使用了 fast-css-loader 的，使用这个的话是默认没有压缩功能的，是的，只有官方的 css-loader才有压缩的功能，那我们手动配置的话只需要使用 OptimizeCSSAssetsPlugin 这个插件，具体的配置方法也可以参考我的配置文件。 还要注意的是如果使用了这个插件进行css代码的压缩，那么js文件的压缩功能会被顶掉，所以我们就还需要安装插件进行js文件的压缩，我这里使用的是 TerserJSPlugin 使用方法参考我的配置文件。也有其他的压缩插件，这里就不介绍了。 当然，如果不使用fast-css-loader就不必要使用额外的压缩插件，具体怎么选择就仁者见仁了。 使用url-loader对于图片的处理来说配置url-loader也有一定的提升，url-loader相较于file-loader来说比较明显的区别就在于可以将图片转化为base64格式的。 这里要注意的是通过base64的转化，图片的大小会增加三分之一左右，但是可以减少一次网络请求，所以设置将多大的图片转化为base64就尤为重要了：1234&#123; test: /\.(png|jpg|gif)$/, use: ['url-loader?outputPath=aseets/images&amp;limit=8192&amp;name=[contenthash].[ext]&amp;fallback=file-loader']&#125;, 我这里设置的是将小于8192比特的图片转化为base64，也可以根据项目情况进行调整。大于这个数值的默认就会调用file-loader来进行处理。 懒加载懒加载就是在用户需要时再按需引入相应的模块，这样可以减少首次加载的时间，合理的使用资源，具体可以看webpack官方文档的简单的例子。 多页面抽离公共代码在webpack4.x中不再需要特别区配置这部分的东西了，因为自带了这方面的插件并且使用默认配置也是足够的，如果要看具体怎么配置的话也可以看官方文档的介绍。 原理就是多页面中会有很多重复用到的代码，比如说第三方库之类的，这类资源基本上不会被修改，所以可以把这些相同的代码抽离出来，当用户第一次请求这些公共部分的文件时，就会被浏览器缓存，当其他页面要使用的时候就不需要再次进行请求了，直接使用缓存就可以了。 总结从网上找各种资料到引用到配置适合自己的配置这个过程还是花了很多的时间的，也踩了很多的坑，但是终究还是配置好了，也让我对webpack有了更多的认识，也更加的发觉了使用webpack的好处，我将会把这两份代码配置放到github中，要使用的时候直接clone下来就好了，特别是再给命令起个别名，用起来就很舒服了。]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试文章]]></title>
    <url>%2F2019%2F08%2F14%2F%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在来测试一下图片。 ### 这是一个新的测试 ### ###]]></content>
      <categories>
        <category>学习笔记</category>
        <category>vue学习记录</category>
      </categories>
      <tags>
        <tag>test</tag>
        <tag>js</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS鼠标滚轮事件]]></title>
    <url>%2F2019%2F08%2F13%2FJS%E9%BC%A0%E6%A0%87%E6%BB%9A%E8%BD%AE%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们经常会有需求需要实现可以通过鼠标滚轮来进行翻页或者是对应用的切换，那么这个时候就需要用到鼠标滚轮事件了，并且大部分时候都需要进行一定的优化以提升用户体验，这也是我在这段时间开发chrome插件时所遇到的一些问题，来看看我是怎么解决的。 基本使用鼠标滚轮事件相较于其他基本的事件使用起来会稍微麻烦那么一点点，我这里采用的jQuery的写法：12345678910111213// 因为firefox浏览器对于鼠标滚轮事件的处理和其他浏览器不太一样，所以这里要注意兼容处理$(document).on('mousewheel DOMMouseScroll', function (e) &#123; e = e || window.event; let delta = e.originalEvent.wheelDelta || e.originalEvent.detail; //后者是对Firefox的兼容 if (delta &gt; 0) &#123; // 这里写滚轮上滚时的代码 console.log('上滚'); &#125; if (delta &lt; 0) &#123; // 这里写滚轮下滚时的代码 console.log('下滚'); &#125;&#125;); 这就是最简单的使用方式了。但是如果我们直接这样使用的话会出现一个问题，那就是当我们快速的滚动多次鼠标滚轮，那么此时就会触发多次的事件，其实这个时候用户体验是很不好的，因为大部分人都会习惯滑鼠标滚轮不止一格，并且有些鼠标也不好控制轻轻的只划一格，那么这个时候就需要进行一定的优化来解决这个问题了。 优化方式一方式一的优化原理就是在一次鼠标滚轮事件之后将滚轮事件与元素解绑，然后用定时器来设置一定时间后再次进行绑定：123456789101112131415function setDiff() &#123; $(document).on('mousewheel DOMMouseScroll', function (e) &#123; e = e || window.event; let delta = e.originalEvent.wheelDelta || e.originalEvent.detail; $(document).off("mousewheel DOMMouseScroll"); if (delta &gt; 0) &#123; //当滑轮向上滚动时 console.log('上滚'); &#125; if (delta &lt; 0) &#123; //当滑轮向下滚动时 console.log('下滚'); &#125; setTimeout(setDiff, 500); &#125;);&#125;setDiff(); 当这样优化之后，无论怎么样的滚动鼠标滚轮，两次滚轮事件之间最少都要间隔 500ms 了。 虽然这样的方式是可行的，但是也存在着极端的情况，加入用户进行了一次超级长的鼠标滚轮，那么就可能触发多次滚轮事件，而我在开发chrome插件的时候预期想要的效果是在一次连续的滚动过程中，无论连续滚动了多长时间，只有第一次滚轮事件会生效，后面的都会无效，因为如果实现这样的效果就无需设置时间来控制事件的触发频率，大大的增加灵活性。后面经过思考与尝试，我还是实现了我的思路。 优化方式二为了实现前面所提到的效果最终我想到可以通过判断两次事件触发的间隔来确定是否要执行事件：12345678910111213141516171819function setDiff() &#123; let preTime = new Date(); $(document).on('mousewheel DOMMouseScroll', function (e) &#123; let diff = (new Date()) - preTime; if (diff &gt; 300) &#123; e = e || window.event; let delta = e.originalEvent.wheelDelta || e.originalEvent.detail; //后者Firefox // $(document).off("mousewheel DOMMouseScroll"); if (delta &gt; 0) &#123; //当滑轮向上滚动时 console.log('上滚'); &#125; if (delta &lt; 0) &#123; //当滑轮向下滚动时 console.log('下滚'); &#125; &#125; preTime = new Date(); &#125;);&#125;setDiff(); 这样优化之后，只要是连续的滚动鼠标滚轮，那么一定只会触发第一次事件，当用户松开滚轮，进行下一次滚动时，间隔时间够长，就又可以触发一次滚轮事件，但是后面连续的所有事件因为间隔时间十分之短，就不会被触发，就达到了我的目的。 总结这也是我第一次使用鼠标的滚轮事件，结合网上的一些内容以及自己的一些思考，最终还是完成了自己的需求，并且对代码进行了简化，虽然花了一些时间，但是肯定是值得的。]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过百度API添加搜索小功能]]></title>
    <url>%2F2019%2F08%2F10%2F%E9%80%9A%E8%BF%87%E7%99%BE%E5%BA%A6API%E6%B7%BB%E5%8A%A0%E6%90%9C%E7%B4%A2%E5%B0%8F%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这两天在开发一个自己的chrome插件，实现自定义新标签页，那么新标签页肯定少不了搜索的功能，因为我比较常用的搜索引擎是百度，所以会跳到百度的搜索结果，并且通过调用API来实现有一个提示的小窗口，原理是挺简单的，但是写的过程中还是遇到一些问题，记录一下。 先来看看效果图做的不是很好看，因为目前只是把功能实现了，样式都还是测试用的。重点来讲讲功能。 实现代码HTML代码12345678910111213&lt;div class="main"&gt; &lt;div class="centerBox"&gt; &lt;div class="log"&gt;&lt;/div&gt; &lt;div class="searchWrap"&gt; &lt;svg class="icon sousuo" aria-hidden="true"&gt; &lt;use xlink:href="#icon-sousuo"&gt;&lt;/use&gt; &lt;/svg&gt; &lt;input type="text" class="searchInput"&gt; &lt;/div&gt; &lt;ul class="searchTips"&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt; JS代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293&lt;script src="./asset/font/iconfont.js"&gt;&lt;/script&gt; &lt;script src="./asset/js/jquery-3.4.1.min.js"&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; // 百度搜索 &#123; // 搜索部分 const searchInput = $('.searchInput'); const searchTips = $('.searchTips'); let tipItems = searchTips.children(); let liList = ``; let query = searchInput.val(); let timer; let tipIndex = -1; searchInput.keyup(function (e) &#123; // 按下回车进行搜索 if (e.keyCode == 13) &#123; query = $(this).val(); window.open(`https://www.baidu.com/s?ie=UTF-8&amp;wd=$&#123;query&#125;`); &#125; &#125;) // 提示部分 searchInput.on('input', function () &#123; tipIndex = -1; let query = searchInput.val(); const url = "https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=" + query + "&amp;cb=?"; $.getJSON(url, function (data) &#123; console.log(data.s); data.s.forEach(item =&gt; &#123; liList += `&lt;li&gt;$&#123;item&#125;&lt;/li&gt;`; &#125;); searchTips.html(liList); liList = ``; tipItems = searchTips.children(); // 单击提示进行搜索 tipItems.each((index, item) =&gt; &#123; $(item).mousedown(function () &#123; window.open(`https://www.baidu.com/s?ie=UTF-8&amp;wd=$&#123;$(this).text()&#125;`); &#125;) &#125;) // 鼠标经过时的变化 tipItems.each((index, item) =&gt; &#123; $(item).hover(function () &#123; searchTips.show(); $(this).addClass('tipCur').siblings().removeClass('tipCur'); &#125;, function () &#123; $(this).removeClass ('tipCur').siblings().removeClass('tipCur'); &#125;) &#125;) // 搜索框失去焦点时隐藏，获得焦点时显示 searchInput.blur(function () &#123; searchTips.hide(); &#125;) searchInput.focus(function () &#123; searchTips.show(); &#125;) &#125;) &#125;) // 通过上下箭头来控制搜索框内容 searchInput.keydown(function (e) &#123; // 方向键下 if (e.keyCode == 40) &#123; tipIndex++; if (tipIndex &gt;= tipItems.length) &#123; tipIndex = 0; &#125; tipItems.eq(tipIndex).addClass('tipCur').siblings().removeClass('tipCur'); searchInput.val(tipItems.eq(tipIndex).text()); &#125; // 方向键上 if (e.keyCode == 38) &#123; // 要阻止方向键上光标跳到文字开头的默认行为，必须要在keydown阶段阻止 e.preventDefault(); tipIndex--; if (tipIndex &lt;= (-1)) &#123; tipIndex = (tipItems.length - 1); &#125; tipItems.eq(tipIndex).addClass('tipCur').siblings().removeClass('tipCur'); searchInput.val(tipItems.eq(tipIndex).text()); &#125; &#125;) &#125; &#125;) &lt;/script&gt; 这里主要讲一下这些功能的实现原理： 使用百度进行跳转搜索通过给百度的url传递 wd 字段的参数就可以跳转到相应的搜索结果，就像我上面写的那样。我这里通过open方法来跳转的目的是为了在新窗口中打开。但是有一点不好的是可能会被浏览器拦截，不过这是我自用的插件所以没影响。 关键字提示窗口这里实现这个提示窗口主要是用到了jsonp向相应的API发起跨域请求（如上面代码所示），然后就可以拿到相应的数据。 单击提示进行搜索这个其实就是在拿到数据并且添加进HTML中后对每条数据进行遍历，绑定一个单击事件，单击进行相应的跳转就可以了。 大部分代码都是很好理解的，这里就不做过多的解释了 CSS代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586* &#123; margin: 0; padding: 0; list-style: none;&#125;html,body &#123; height: 100%;&#125;.icon &#123; width: 1em; height: 1em; vertical-align: -0.15em; fill: currentColor; overflow: hidden;&#125;.icon.sousuo &#123; font-size: 20px; padding: 0 12.5px;&#125;.main &#123; width: 100%; background: url("./asset/images/bg.jpeg") center center / cover no-repeat; /* height: 700px; */ position: relative; height: 100%;&#125;.centerBox &#123; position: absolute; top: 20%; left: 50%; transform: translateX(-50%);&#125;.log &#123; width: 50px; height: 50px; border-radius: 50%; border: 1px solid #fff; background-color: orange; margin: 0 auto; margin-bottom: 20px;&#125;.searchWrap &#123; margin: 0 auto; width: 600px; height: 45px; display: flex; background-color: rgba(255, 255, 255, 0.8); align-items: center; border-radius: 45px;&#125;.searchInput &#123; padding-left: 2px; flex-grow: 1; height: 45px; background-color: rgba(0, 0, 0, 0); outline: none; border: none;&#125;.searchTips &#123; width: 98%; background-color: rgba(255, 255, 255, 0.9); margin: 0 auto; margin-top: 10px; border-radius: 4px; overflow: hidden;&#125;.searchTips li &#123; padding: 8px 0; padding-left: 10px;&#125;.tipCur &#123; background-color: rgba(0, 0, 0, 1);&#125; 样式这里可以讲的一点就是如何使一个dom元素沾满整个屏幕：12345678html,body &#123; height: 100%;&#125; .main &#123; width: 100%; height: 100%;&#125; 主要就是通过这些代码来实现，也非常好理解。 开发过程中我遇到的一些问题以及解决办法click 和 blur 事件的冲突 起初当我基本上完成大部分功能的之后进行测试，发现当点击提示框中的内容的时候竟然没有进行跳转，而是直接执行了失焦事件中的隐藏提示框的代码。我就猜想应该是由于单击的时候会使文本框失焦，并且 blur 会在 click 之前触发，进行一些尝试之后还是没有解决问题，后来百度了一下找到了解决问题的两种办法： 第一种就是通过设置定时器，通过设置setTimeout来使 blur 事件中的代码晚一些执行： 12345searchInput.blur(function () &#123; setTimeout(function () &#123; searchTips.hide(); &#125;, 300)&#125;) 但是这种办法的缺点也很明显，就是延迟的时间要足够长，起码要长到 click 事件的代码执行完毕，我这里测试大概最少300ms,所以在执行 blur 事件的时候能感觉到很明显的延迟，体验并不是很好。 第二种就是使用 mousedown事件来替代 click 事件： 我这里采用的就是这种方式，这种方式就很好的解决了问题，但是也不是没有缺点， mousedown 事件在鼠标按下时就会触发，所以触发次数也就和按下的事件有关系，如果只是快速的按一下那么没有区别，但是按久了就会触发非常多次，所以很多场景下不适用，不过我这里没有关系，因为只要按下去了就打开新窗口不在当前window环境下了，所以没有影响。 这里再来讲一下 mousedown、mouseup、click这三个事件的主要区别及应用场景： click ：在同一元素上 相继触发 mousedown 和 mouseup 才会触发 click ，并且能够通过按下回车来触发。大部分场景下都是使用 click ，因为过程比较完整也不会重复触发。经测试右键不会触发。 mouseup ：释放鼠标时触发。右键可以触发。 mousedown：鼠标按下时触发。不过由于按下就触发的特性，比较的快，所以 mousedown 会在 blur 之前触发，这就是为什么使用 mousedown 可以解决冲突问题。 这里总结一下：一次完整的鼠标单击就是这样一个过程 mousedown &gt; mouseup &gt; click 。 mousedown 和 mouseup 配合可以实现监听鼠标长按。具体怎么使用就看场景需求了。 异步问题当我完成了添加提示框功能之后，想要继续完成鼠标经过提示内容给其添加样式的功能，当我写完之后却发现了问题：我是直接将添加样式的代码放在了和文本框平级，我想这从逻辑上来说应该没有什么问题，但实际上却出现了问题，起初是报错提示框内容中的那个jQuery对象是空的，这就很奇怪了，我明明在每次的 input 事件执行时就给这个jQuery对象赋值了，出现这种情况也就意味着input事件发生在添加样式之后。 经过一段事件的思考我想明白了，主要是忽略了无论是 input 事件还是 Ajax 的请求，这二者都是异步的任务，而添加样式所用的过程是主线程上的同步操作，所以一定会在这两个异步任务之前生效，所以才会导致这种情况的出现，那么解决办法也就很简单了，将添加样式的代码在这两个异步任务之后执行就可以了，所以只需要将代码放进 Ajax 的回调中执行就可以了，那么这样就成功的解决了问题。同理，单击提示进行搜索的那部分代码也是一样的道理。 其后后面也有一部分代码（通过方向键控制要搜索的内容的那部分）涉及到操作提示框内容的jQuery对象，那为什么不会出现这种情况呢，到这里其实也很好理解了，因为这部分的代码也是由事件来触发的，也是异步的，并且是在最后面，所以一定是最后执行的。 关于异步单线程可以参考我的这篇文章:简单理解js单线程异步与事件循环机制 阻止键盘方向键的默认行为在文本框中，键盘的方向键存在着默认行为，比如说是方向键上，这会使光标移动到文本框最前面，我们在搜索的提示框中就可以通过上下键来切换搜索内容，但是同时也会触发默认行为，使光标移动到文本框最前端，这样的结果很明显不是我们想要的。 百度了一下相关的解决办法，就是阻止上箭头的默认行为，但是发现好像不起作用，最后其实发现解决办法是和解决 click 和 blur 冲突问题的办法类似，更换触发事件，将按下的keyup事件修改为keydown事件，然后这时候阻止默认行为就有效了，应该也是触发先后的问题，这样修改之后发生的另一个变化就是按键可以”连发”了,不过这也不算坏处。 总结通过制作这个简单的搜索小功能还是收获挺多的，能够完全理解的话也能进步挺多的，特别是异步问题那里，之前只有其概念，现在运用起来了。]]></content>
      <categories>
        <category>页面小功能</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>chrome插件开发</tag>
        <tag>chrome</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue实现轮播图组件]]></title>
    <url>%2F2019%2F08%2F08%2Fvue%E5%AE%9E%E7%8E%B0%E8%BD%AE%E6%92%AD%E5%9B%BE%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前面已经介绍实现过了常见的一些轮播图，也对其实现原理十分的了解了，那么在vue中要如何实现轮播图呢，其实也不难，因为原理都是一样的，只是实现的形式有所区别。这里就以实现淡入淡出轮播图为例。 原理实现淡入淡出轮播图的原理其实也都是一样的，前面也提到了，就是将要轮播的所有图片都叠在一起，默认只显示第一张，然后通过定时器来控制图片的切换，并且加上淡入淡出的动画效果，在vue中实现起来还要更加的方便。 实现template部分：123456789101112&lt;template id="banner"&gt; &lt;div class="bannerWrap" @mouseover="suspend" @mouseout="autoPlay" @blur="suspend" @focus="autoPlay"&gt; &lt;button class="pre" @click="pre"&gt;PRE&lt;/button&gt; &lt;button class="next" @click="next"&gt;NEXT&lt;/button&gt; &lt;transition-group tag="ul" class="imgList" name="fade"&gt; &lt;li v-show="item.cur" v-for="(item, index) in list" :key="item.src"&gt;&lt;img :src=item.src alt=""&gt;&lt;/li&gt; &lt;/transition-group&gt; &lt;ul class="optionList"&gt; &lt;li v-for="(item, index) in list" :key="item.src" @click="jump(index)"&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt; js部分：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374const vm = new Vue(&#123; el: '#app', components: &#123; banner: &#123; template: '#banner', data() &#123; return &#123; timer: null, index: 0, // 图片的地址以及是否显示 list: [ &#123; 'src': './images/beach-exotic-holiday-248797.jpg', 'cur': true &#125;, &#123; 'src': './images/blur-calm-waters-dawn-395198.jpg', 'cur': false &#125;, &#123; 'src': './images/dark-flash-lightning-1114690.jpg', 'cur': false &#125;, &#123; 'src': './images/mountain-range-mountains-114979.jpg', 'cur': false &#125;, ] &#125; &#125;, methods: &#123; // 定义自动播放函数，通过调用next方法来实现 autoPlay() &#123; clearInterval(this.timer)//还是一样，开启定时器之前需要先清除一下，防止bug this.timer = setInterval(this.next, 2000) &#125;, // 定义切换到下一张图片的方法 next() &#123; this.index++; if (this.index &gt;= this.list.length) &#123; this.index = 0; &#125; this.list.forEach(item =&gt; &#123; item.cur = false; &#125;); this.list[this.index].cur = true; &#125;, // 定义切换到前一张图片的方法 pre() &#123; this.index--; if (this.index &lt;= -1) &#123; this.index = this.list.length - 1; &#125; this.list.forEach(item =&gt; &#123; item.cur = false; &#125;); this.list[this.index].cur = true; console.log(this.index); &#125;, // 暂停的方法 suspend() &#123; clearInterval(this.timer) &#125;, // 点击选项圆点进行跳转的方法 jump(index) &#123; this.index = index; this.list.forEach(item =&gt; &#123; item.cur = false; &#125;); this.list[index].cur = true; &#125; &#125;, mounted() &#123; // 自动播放函数以及失焦暂定获焦开启都需要在mounted阶段设置 this.autoPlay(); // 直接在mounted中写聚焦以及失焦的函数 window.blur = function () &#123; clearInterval(this.timer) &#125; window.focus = function () &#123; autoPlay() &#125; &#125; &#125; &#125;&#125;) 整体的思路和前面使用jQuery写的轮播图的思路是一致的，只不过是换了一种方式。 样式部分：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172 * &#123; margin: 0; padding: 0; list-style: none; &#125; .bannerWrap &#123; width: 800px; margin-left: 400px; margin-top: 20px; position: relative; &#125; .imgList &#123; display: flex; position: relative; width: 800px; height: 400px; &#125; .imgList li &#123; position: absolute; left: 0; &#125; .imgList img &#123; width: 800px; height: 400px; &#125; button &#123; position: absolute; width: 60px; height: 40px; top: 50%; transform: translateY(-50%); z-index: 2; &#125; .pre &#123; left: 50px; &#125; .next &#123; right: 50px; &#125; .optionList &#123; position: absolute; right: 60px; bottom: 40px; display: flex; &#125; .optionList li &#123; margin-left: 5px; border-radius: 50%; width: 20px; height: 20px; border: 1px solid #fff; &#125;/* 实现动画的两组类 */ .fade-enter-active, .fade-leave-active &#123; transition: opacity .5s; &#125; .fade-enter, .fade-leave-to &#123; opacity: 0; &#125; 样式部分要注意的就是实现动画效果的两组类，不能设置错了。 通过以上代码就可以实现一个淡入淡出的轮播图了，非常的简便，代码也相较不使用vue开发要少的多。 总结这次通过vue实现了一个淡入淡出的轮播图组件，原理都是一样的，只不过是使用vue来开发会更加简便。滑动轮播图也是类似的，这里就不演示了。重要的是熟悉vue的开发思路以及开发原理。]]></content>
      <categories>
        <category>页面小功能</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>动画</tag>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[详解使用jQuery实现滑动轮播图]]></title>
    <url>%2F2019%2F08%2F07%2F%E8%AF%A6%E8%A7%A3%E4%BD%BF%E7%94%A8jQuery%E5%AE%9E%E7%8E%B0%E6%BB%91%E5%8A%A8%E8%BD%AE%E6%92%AD%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;网页中的轮播图十分的常见，并且轮播图的动画样式也有很多种，前面已经有介绍过淡入淡出的轮播图了，比较的简单，这次来详细介绍一下滑动轮播图，并且优化了之前的很多细节，一起来看一看。 原理在实现之前先介绍一下滑动轮播图实现的原理，这里分为两种来介绍，常见的滑动轮播图有两种，一种是无限循环滑动的，一种是会往滑回开始位置的，先来讲讲这二者的原理以及区别： 会滑回的通过图片来更好的理解：通过这张图片我们就很好理解了，每次轮播其实就是将三张图片当成一个整体向左移一张图片的宽度实现，当到达最左边或者最右边的时候再通过动画滚回第一张或者是最后一张图片，这是一种比较常见的方式。 无限滑动的也一样通过图片来更好的理解：其实无限滑动的基本原理都是和上面的会滑回的是一样的，最大的区别就在于当到达最左边或者最右边时，这次就不是通过动画来过渡了，而是通过在图片列表的开头添加一张最后的图片以及列表末尾添加一张开头的图片，当轮播到最后一张图片的时候通过修改css样式跳回到第一张图片，由于在末尾添加了一张开头的图片，所以看不出来这个跳转的过程，这样就实现了无限滑动的效果。 实现普通版HTML部分：1234567891011121314&lt;div class="bannerWrap"&gt; &lt;button class="pre"&gt;PRE&lt;/button&gt; &lt;button class="next"&gt;NEXT&lt;/button&gt; &lt;ul class="imgList"&gt; &lt;li&gt;&lt;img src="./images/cool-wallpaper-dawn-hd-wallpaper-66997.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="./images/flowers-4352530_1280.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="./images/hd-wallpaper-mountain-range-mountains-114979.jpg" alt=""&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ul class="optionList"&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; html部分没有什么好讲的，按照结构布局好就可以了。 js部分：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;script src="./js/jquery-3.4.1.min.js"&gt;&lt;/script&gt;&lt;script&gt; $(function () &#123; const bannerWrap = $('.bannerWrap'); const imgList = $('.imgList'); const optionList = $('.optionList'); const preBt = $('.pre'); const nextBt = $('.next'); let timer; const imgWidth = bannerWrap.width(); const len = imgList.children().length; let index = 0; // 自动轮播的函数，通过调用向右滑动的函数来实现轮播 function autoSlide() &#123; timer = setInterval(next, 3000) &#125; autoSlide(); //当鼠标经过轮播图时暂停的函数 function suspend() &#123; bannerWrap.hover(function () &#123; clearInterval(timer) &#125;, function () &#123; // 在每次重新开启定时器之前都需要将定时器清除一遍，防止由于特殊情况定时器并未真正关闭而导致重复开启定时器 clearInterval(timer) autoSlide(); &#125;) &#125; suspend(); // 滑动到下一张的函数 function next() &#123; index = index &gt;= len - 1 ? 0 : index + 1; // 在新的动画开始之前都需要停止一下之前的动画 imgList.stop().animate(&#123; 'marginLeft': -imgWidth * index &#125;) &#125; // 滑动到前一张的函数 function pre() &#123; index = index &lt;= 0 ? (len - 1) : (index - 1);//这里的 index-1 一定要打上括号，否则可能会引发bug imgList.stop().animate(&#123; 'marginLeft': -imgWidth * index &#125;) &#125; nextBt.click(function () &#123; next(); &#125;) preBt.click(function () &#123; pre(); &#125;) // 小圆点跳转的函数 function jump() &#123; for (let i = 0; i &lt; len; i++) &#123; optionList.children().eq(i).click(function () &#123; imgList.stop().animate(&#123; 'marginLeft': -imgWidth * i &#125;) &#125;) &#125; &#125; jump(); //失去焦点以及获得焦点时 $(window).blur(function () &#123; clearInterval(timer) &#125;) $(window).focus(function () &#123; clearInterval(timer) autoSlide(); &#125;) &#125;)&lt;/script&gt; js部分最重要的就是思路，都在注释中有写，应该比较好理解 css部分：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253* &#123; list-style: none; padding: 0; margin: 0;&#125;.bannerWrap &#123; width: 800px; margin-top: 40px; margin-left: 400px; overflow: hidden; position: relative;&#125;.imgList &#123; display: flex;&#125;img &#123; width: 800px; height: 400px;&#125;button &#123; position: absolute; width: 60px; height: 40px; top: 50%; transform: translateY(-50%);&#125;.pre &#123; left: 50px;&#125;.next &#123; right: 50px;&#125;.optionList &#123; position: absolute; right: 60px; bottom: 40px; display: flex;&#125;.optionList li &#123; margin-left: 5px; border-radius: 50%; width: 20px; height: 20px; border: 1px solid #fff;&#125; 也都是一些基本的样式设置，没有什么好讲的。这里相比于以前写的轮播图来说有优化的地方就是这里并没有直接写一个自动轮播的函数，而是通过调用下一站图片的函数来实现自动轮播，这样就减少了重复代码。 无限版html部分的代码和普通版的是一样的就不放出来了 css部分代码就只有一下这一部分和普通版有所区别：1234 .imgList &#123; display: flex; margin-left: -800px;&#125; 区别就是调整 margin-left 以显示真正的第一张图片。 重点就是js部分：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899&lt;script src="./js/jquery-3.4.1.min.js"&gt;&lt;/script&gt;&lt;script&gt; $(function () &#123; const bannerWrap = $('.bannerWrap'); const imgList = $('.imgList'); const optionList = $('.optionList'); const preBt = $('.pre'); const nextBt = $('.next'); let timer; const imgWidth = bannerWrap.width(); let index = 1; //通过js来添加两张图片 imgList.prepend(imgList.children().last().get(0).outerHTML)//一定要写在获取长度之前 imgList.append(imgList.children().get(1).outerHTML)//一定要写在获取长度之前 const len = imgList.children().length; function autoSlide() &#123; timer = setInterval(next, 1000) &#125; autoSlide(); function suspend() &#123; bannerWrap.hover(function () &#123; clearInterval(timer) &#125;, function () &#123; clearInterval(timer) autoSlide(); &#125;) &#125; suspend(); // 滑动到下一张的函数，由于多了两张图片，所以要注意index的值 function next() &#123; index++; // 这里的stop方法要格外注意一下，必须像这样加参数 imgList.stop(false, true).animate(&#123; 'marginLeft': -imgWidth * index &#125;, function () &#123; if (index &gt;= (len - 1)) &#123; index = 1; // 重点就是这个动画执行完毕后的回调，通过这个回调来讲图片重新调回想要的位置以实现无限 imgList.css(&#123; 'marginLeft': -imgWidth &#125;) &#125; &#125;) console.log(index); &#125; // 滑动到前一张的函数，与next函数类似 function pre() &#123; index--; if (index &lt;= (-1)) &#123; index = (len - 2); imgList.css(&#123; 'marginLeft': -imgWidth * (index) &#125;) &#125; imgList.stop(false, true).animate(&#123; 'marginLeft': -imgWidth * index &#125;, function () &#123; if (index &lt;= 0) &#123; index = (len - 2); imgList.css(&#123; 'marginLeft': -imgWidth * (index) &#125;) &#125; &#125;) &#125; nextBt.click(function () &#123; next(); &#125;) preBt.click(function () &#123; pre(); &#125;) // 小圆点跳转的函数，这里由于多了两张图片，所以也要稍微修改一下 function jump() &#123; for (let i = 0; i &lt; len - 2; i++) &#123; optionList.children().eq(i).click(function () &#123; imgList.stop().animate(&#123; 'marginLeft': -imgWidth * (i + 1) &#125;) &#125;) &#125; &#125; jump(); $(window).blur(function () &#123; clearInterval(timer) &#125;) $(window).focus(function () &#123; clearInterval(timer) autoSlide(); &#125;) &#125;)&lt;/script&gt; 与普通版不一样的地方都注释出来了，与普通版思路都是差不多的，区别就在于处理最后一张图片回到第一张（或者相反）的方式上有所区别。 这里再详细讲一下stop()方法为什么要加参数： 如果不加参数的话默认是停止当前动画继续后面的动画，当快速点击下一张图片到最后一张图片通过修改 css 跳回第一张时由于停止了动画就不会执行回调，所以就会持续出现空白。 而通过给stop()方法传递参数就可以解决这一问题，stop(false, true)则表示立即完成当前动画，继续后面动画，这样传递参数以后就不会因为停止了动画而导致不执行回调函数了，进而就解决了问题。 一些要十分注意的问题轮播图思路比较简单，但是在实现过程中要是忽略一些细节就有可能会导致意想不到的结果，这里提出来要十分注意： 在开启新的动画之前一定要调用stop()方法讲之前的动画停止，防止作出不必要的动画。 在开启重新调用自动轮播函数之前一定要先清除一遍定时器，否则可能会导致重复开启定时器。 由于setInterval在后台运行时会自动停止，当重新运行时会一次性将在后台时的全部运行完，所以当重新切回轮播图时会疯狂滑动，为了避免这种情况就需要手动设置在页面失去焦点时暂停定时器，获取焦点时重新开启。 总结前面有写过淡入淡出的轮播图，原理更加的简单，实现起来也更加的简单，这次通过写滑动轮播图来练练手，并且优化了代码，写的过程中也遇到了很多的问题，也都解决了，进而学习到了很多的细节。下次尝试使用vue来写一个轮播图组件。]]></content>
      <tags>
        <tag>JS</tag>
        <tag>jQuery</tag>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用vue来实现选项卡]]></title>
    <url>%2F2019%2F08%2F06%2F%E4%BD%BF%E7%94%A8vue%E6%9D%A5%E5%AE%9E%E7%8E%B0%E9%80%89%E9%A1%B9%E5%8D%A1%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前面有学习过如何使用原生js或者是jQuery来实现选项卡的功能，原理其实都差不多是一样的，那么现在学习过vue，试着来使用vue来实现选项卡的功能，理解vue开发的思路。 原理其实选项卡功能的原理大体上都是一样的，都是通过鼠标经过来添加样式并且删除其他兄弟的样式来实现的，但是我们在使用vue来开发的过程中会有很大不一样的地方就是使用vue并不需要操作元素，只需要关心业务逻辑就好了，所以其实就可以更加简单的实现选项卡的功能。 实现HTML部分1234567891011121314151617 &lt;div id="app"&gt; &lt;tabs&gt;&lt;/tabs&gt; &lt;/div&gt;//定义模板 &lt;template id="tabs"&gt; &lt;div class="wrap"&gt; &lt;ul class="tab_h"&gt; &lt;li v-on:mouseover="toActive(index)" :class="&#123;cur:item.active&#125;" v-for="(item,index) in tabList" :key="index"&gt; &#123;&#123;item.head&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;ul class="tab_b"&gt; &lt;li v-show="item.active" v-for="(item,index) in tabList" :key="index"&gt;&#123;&#123;item.body&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/template&gt; 这里是在html中定义的组件模板，其实这个在哪定义模板不重要，重要的是这上面的思路。 JS部分1234567891011121314151617181920212223242526272829&lt;script src="./../../js/vue.js"&gt;&lt;/script&gt;&lt;script&gt; const vm = new Vue(&#123; el: '#app', components: &#123; tabs: &#123; template: '#tabs', data() &#123; return &#123; //将所有的数据都存放在这个数组中，遍历数组就可以得到所有的数据 tabList: [ &#123; 'head': '选项一', 'body': '这是选项一中的内容', 'active': true &#125;, &#123; 'head': '选项二', 'body': '这是选项二中的内容', 'active': false &#125;, &#123; 'head': '选项三', 'body': '这是选项三中的内容', 'active': false &#125;, &#123; 'head': '选项四', 'body': '这是选项四中的内容', 'active': false &#125;, ] &#125; &#125;, methods: &#123; //定义鼠标经过时的方法 toActive(index) &#123; this.tabList.forEach(item =&gt; item.active = false); this.tabList[index].active = true; &#125; &#125;, &#125; &#125; &#125;)&lt;/script&gt; 可以看出使用vue来实现这样的功能是十分的方便的，不用像原生那样操作dom元素。 CSS部分1234567891011121314151617181920212223242526272829303132333435363738&lt;style&gt; * &#123; margin: 0; padding: 0; list-style: none; &#125; .wrap &#123; margin-left: 400px; margin-top: 20px; &#125; .tab_h, .tab_b &#123; display: flex; width: 800px; &#125; .tab_h li &#123; flex-grow: 1; text-align: center; border: 1px solid black; &#125; .tab_b li &#123; border: 1px solid black; border-collapse: collapse; width: 100%; height: 200px; &#125; .cur &#123; display: block; color: orange; font-weight: bold; &#125;&lt;/style&gt; css部分就不重要了，主要是激活时的样式。 效果 总结在学习vue的过程中我时常会想如何通过vue来实现一些我们平时比较常见的功能，通过原生来实现的思路已经非常清除了，那么如何将将同样的思路转化在vue中实现，那么通过实现这次的选项卡的小例子算是见到了vue的强大简便之处，一样的思路，换了一种实现的方式，但是却会更加的简便，vue确实是一款非常好用的框架，特别是这种思路太让人佩服了。]]></content>
      <tags>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GIT的基本使用]]></title>
    <url>%2F2019%2F07%2F30%2FGIT%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Git是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。在开发中也是经常用到的工具，在了解到GIT之前我就想过有没有什么工具可以方便的进行回退之类的将文件管理起来的工具，直到我慢慢的知道了GIT，并且学会了如何使用它，就知道了其实管理文件起始也挺简单的。这里就介绍以下GIT的常见用法以及命令。 先来了解几个概念这是我觉得比较简单能理解git工作原理的一张图： 这里来解释以下图中所提到的几个概念： 工作区工作区很好理解，其实就是我们项目工作所在的文件夹，这个就被称之为工作区 暂存区暂存区也很好理解，通过名字就知道是暂时存放的文件夹，我们通过相应命令就可以将项目中的文件提交到暂存区当中，当作中间临时存放的区域。而暂存区中的文件等待着被提交到本地仓库中或者被清除。 本地仓库本地仓库就是在暂存区中的文件最终确定要提交，然后会被提交到的场所。这个仓库里面的所有文件都可以被Git管理起来，每个文件的修改，删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻还可以将文件”还原”。 远程仓库远程仓库就是远程存放我们项目文件的地方，可以通过相应命令来讲提交到本地仓库中的文件上传到远程仓库中。 了解完这几个概念之后其实就大致能明白GIT的简单工作流程了，接下来看看具体怎么操作。 GIT常用命令git init这个是使用git的开始，当执行了这个操作就表示这是一个git目录了，目录中会多出来一个隐藏的 .git 文件夹，这个就是git本地仓库。1$ git init 后面可以跟一个目录，在指定目录初始化。 git clone可以将一个远程仓库克隆到本地1$ git clone [url] 这里的url地址推荐使用ssh会更快一些。 git add通过 git add 加上文件名可以将指定文件的修改添加都暂存区。 也可以通过git add .或者是git add -A来将所有的文件修改添加到暂存区，二者区别在于前者不会将文件删除添加到暂存区，后者会。 git status可以通过这个命令来查看当前工作区文件的所有改动 也可以添加 -s 选项来的到简短的结果:1$ git status -s git diff可以通过此命令来查看当前工作区中的文件与本地仓库中的区别，这是在没有添加到暂存区的情况下。 当添加到暂存区后可以这样查看：1$ git diff --cached git commit通过此命令可以将暂存区中的快照添加到本地仓库中。1$ git commit -m &apos;通过-m 选项添加注释&apos; 提交完成之后再用 git status 命令查看则不会有内容 git reset HEAD通过此命令可以撤销暂存区中的快照，如果想取消某文件被添加到暂存区，那么通过此命令就可以使它不被提交到本地仓库，简单来说就是取消暂存。 git reset –hard HEAD^这个命令的作用就是版本回退，每个^ 符号就表示每个 git log中的记录，如果要回退固定次数可以这样写：1git reset --hard HEAD~100 这是回退100次。 也可以通过版本号来回退到固定版本：1git reset --hard 49bdb9c 版本号可以通过git log --oneline来查看 git checkout – file通过此命令可以丢弃工作区中的内容 如果该文件的修改提交到了暂存区就会恢复到暂存区时的样子 如果没有提交到暂存区就会恢复到和版本库一致。 git stash通过此命令可以将当前工作区的工作状态储藏起来，这样就可以方便的切换到其他分支上进行工作。 可以通过查看储藏列表：1git stash list 可以通过git stash apply恢复到最近的储藏，也可以恢复到指定的储藏：1git stash apply stash@&#123;2&#125; 默认只会恢复文件的更改，并不会恢复暂存，如果要恢复暂存则需要添加一个--index选项：1git stash apply --index 可以通过git stash drop@{2}来删除指定储藏，也可以恢复之后立即删除：1git stash pop 如果想要反悔恢复的储藏，可以这样：1git stash show -p stash@&#123;0&#125; | git apply -R 基本命令查看分支：git branch 创建分支：git branch name 切换分支：git checkout name 创建+切换分支：git checkout –b name 合并某分支到当前分支：git merge name 删除分支：git branch –d name 在git中HEAD指向的是当前分支。 解决冲突当同时在两个分支上修改了同一个地方的话，在合并分支的时候就会产生冲突，这个时候就需要手动进行修复修改文件内容，再进行一次提交就可以解决冲突：1git commit -a -m &apos;fix conflicts&apos; 远程仓库管理连接远程仓库有两种方式，一种是直接将远程仓库克隆下来，这个上面已经说过了。 还有一种就是将本地仓库连接到远程仓库：1$ git add origin &lt;url&gt; 通过这种方式就可以将本地仓库与远程仓库相连，还是推荐使用ssh。 这里的 origin只是一个名字以后，代表的是远程仓库在本地使用过程中的一个代号，可以取其他名字。在绑定分支的会用到这个名字： 向远程仓库提交时：1$ git push -u origin master 意思就是将本地的当前分支的内容推到远程的 master 中。获取也是一样的。 忽略提交有时我们会需求并不是所有文件都需要进行追踪提交，比如说开发工具或者是临时文件之类的，那么这个时候我们就可以通过配置 .gitignore 这个文件来配置需要忽略的文件。 在 .gitignore 文件中每一行代表一个忽略规则。 配置语法： 以斜杠“/”开头表示目录； 以星号“*”通配多个字符； 以问号“?”通配单个字符 以方括号“[]”包含单个字符的匹配列表； 以叹号“!”表示不忽略(跟踪)匹配到的文件或目录。 **匹配多级目录，可在开始，中间，结束 忽略规则也存在优先级（由高到低）： 从命令行中读取可用的忽略规则 当前目录定义的规则 父级目录定义的规则，依次地推 $GIT_DIR/info/exclude 文件中定义的规则 core.excludesfile中定义的全局规则 常用规则示例： bin/: 忽略当前路径下的bin文件夹，该文件夹下的所有内容都会被忽略，不忽略 bin 文件 /bin: 忽略根目录下的bin文件 /*.c: 忽略 cat.c，不忽略 build/cat.c debug/*.obj: 忽略 debug/io.obj，不忽略 debug/common/io.obj 和 tools/debug/io.obj **/foo: 忽略/foo, a/foo, a/b/foo等 a/**/b: 忽略a/b, a/x/b, a/x/y/b等 !/bin/run.sh: 不忽略 bin 目录下的 run.sh 文件 *.log: 忽略所有 .log 文件 config.php: 忽略当前路径的 config.php 文件 要注意的一件事情是.gitignore文件只能忽略那些没有被追踪的文件，已经被追踪的文件对于 .gitignore文件来说是无效的。 总结这里介绍了一些GIT常见的也比较简单的用法，平时常用的也不多，其他的知道了解就好了。]]></content>
      <tags>
        <tag>GIT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-js的学习（在webpack中使用vue）]]></title>
    <url>%2F2019%2F07%2F28%2Fvue-js%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9C%A8webpack%E4%B8%AD%E4%BD%BF%E7%94%A8vue%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前面学习过了vue的一些基础的知识，但是都是直接开发，并没有使用webpack这样的打包工具，那么该如何通过webpack来开发一个vue项目呢，并且这样与直接开发有什么不一样的地方呢，就让我们来学习一下。 在项目中安装vue在学习使用webpack之前我们在项目中都是直接使用 script 标签在项目中引入vue所需要的文件，那么现在通过webpack来构建项目的话就应该将所有的依赖都引入到入口文件当中，页面中只会引入一个入口文件。 通过npm来安装vue 先将vue安装进项目： 1npm i vue -S 然后在入口文件中引入vue 1import Vue from &apos;vue&apos; 通过这样简单的安装引入就成功的将vue引入了项目当中 通过 .vue 文件来设置组件当我们执行完上面的引入操作，我们直接在入口文件中写一些相关的vue中的代码的话，会在浏览器的控制台中看见报错信息，意思大概就是我们引入的vue包是runtime的包，不能直接使用组件相关的东西。 那我们要怎么样做呢？要解决这个问题只需要引入完整的vue包文件就好了，有三种方式： 找到 node_modules中的vue项目包，然后修改它的 package.json ，将它提供给外部的入口文件修改为完整的那个： 1&quot;main&quot;: &quot;dist/vue.js&quot;, 在项目的入口文件中修改引入的vue文件： 1import Vue from &apos;vue/dist/vue&apos; 值得注意的一件事情是这里的路径可以将前面的node_modules这个目录省略掉，会自动去这个目录中找我们提供的这个路径。 修改webpack的配置文件，加上以下代码：12345resolve: &#123; alias: &#123; &apos;vue$&apos;: &apos;vue/dist/vue.esm.js&apos; &#125; &#125; 那么任选这三种办法中的其中一种都可以解决前面的问题，但是实际上并不推荐这样去做，因为在webpack中使用vue比较推荐另一种做法，就是使用render函数，通过 render 函数来引入vue组件，而这种组件是单独的以.vue后缀结尾的文件。 安装相关包和进行相关配置 将相应的工具安装进项目 1npm i vue-loader vue-template-compiler -D 在webpack配置文件中配置好相应的匹配规则： 123rules: [ // 匹配规则 &#123; test: /\.vue$/, use: &apos;vue-loader&apos; &#125;,//处理vue文件] 在webpack配置文件中配置好插件相应设置： 1234plugins: [ // 在webpack的4.x的版本中必须引入这个配置 new VueLoaderPlugin()] 通过以上的安装和配置，一个基本的环境就配置好了，接下来来看看如何通过.vue文件来创建组件。 使用render函数新建一个.vue文件，这个文件将会替代页面中一一开始的id为app的元素：1234567891011121314151617181920212223//定义模板&lt;template&gt; &lt;div&gt; 这是一个测试内容 &lt;p v-text="msg"&gt;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;// 定义业务逻辑&lt;script&gt;export default &#123; //通过export default来向外暴露 data() &#123; return &#123; msg: "这是一条消息" &#125;; &#125;&#125;;&lt;/script&gt; //定义样式&lt;style&gt;&lt;/style&gt; 使用render函数引入前面定义的vue文件：123456789101112//先将文件引入页面当中import App from './App.vue'const vm = new Vue(&#123; el: '#app', //再使用render函数使用到引入的组件 render: c =&gt; c(App),//这里是使用了ES6中的箭头函数的语法进行了简写 data: &#123; msg: '这是一个测试内容' &#125;, methods: &#123; &#125;&#125;) 这是render函数的完整写法：123render: function (createElements) &#123; return createElements(App)&#125; 经过这些操作以后页面中原本的 #app 的div块就会被替换为 引入的 App组件，所以要注意的是不要在里面写任何东西，因为会被替换掉。以后需要在其中引入其他的组件就直接在App组件中引入就可以了。 在webpack中使用vue-router前面已经学习过了如何使用vue-router，其实在webpack中使用vue-router的方式还是差不多的，只不过最主要的区别就是引入包和引入各个组件的时候有区别了。 安装1npm i vue-router -S 引入12import Vue from &apos;vue&apos;import VueRouter from &apos;vue-router&apos; 使用vue加载1Vue.use(VueRouter) 一个简单的小例子：除了前面的安装方面的区别之外，其他的几乎没有什么区别了，要是有区别的话也只是在组件的定义方面存在区别，来看一个简单的小例子： 这是网页文件： 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;link rel="icon" href="data:image/ico;base64,aWNv"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 这是入口文件： 123456789101112131415161718192021import Vue from 'vue'import VueRouter from 'vue-router'import App from './App.vue'//如果涉及到很多的路由组件，可以将这些路由组件单独放到一个js文件当中，然后就只要引入这一个js文件就可以引入所有的路由组件。import login from './login.vue'import register from './register.vue'Vue.use(VueRouter)const router = new VueRouter(&#123; routes: [ &#123; path: '/', redirect: '/login' &#125;, &#123; path: '/login', component: login &#125;, &#123; path: '/register', component: register &#125; ]&#125;)const vm = new Vue(&#123; el: '#app', render: c =&gt; c(App), router,&#125;) 这是render的组件： 123456789101112131415161718192021222324//定义模板&lt;template&gt; &lt;div&gt; &lt;router-link to="/login"&gt;登录&lt;/router-link&gt; &lt;router-link to="/register"&gt;注册&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;// 定义业务逻辑&lt;script&gt;export default &#123; //通过export default来向外暴露 data() &#123; return &#123; msg: "这是一条消息" &#125;; &#125;&#125;;&lt;/script&gt; //定义样式&lt;style&gt;&lt;/style&gt; login组件： 123456789101112131415&lt;template&gt; &lt;div&gt; &lt;h1&gt;这是登录组件&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;&#125;;&lt;/script&gt;&lt;style scoped &gt;div &#123; color: beige;&#125;&lt;/style&gt; register组件 123456789101112&lt;template&gt; &lt;div&gt; &lt;h1&gt;这是注册组件&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;&#125;;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 可以看出用法还是和以前差不多，只不过用来一些新东西而已，每个组件都是一个单独的vue文件。 单独的.vue文件前面已经看到了 .vue 是如何使用了，那么现在来详细讲一讲这类文件的一些细节： 可以看出 .vue 文件主要分成三部分，一部分是模板部分，这个是组件的模板，就像是原先直接在html中通过template标签定义模板那样，并且也是一样的用法，只不过是换了一个地方使用。 第二个是script部分，这个是用来处理业务逻辑的部分，其实就是一个vue的实例的对象，只不过需要通过export default将其暴露出去。 第三个部分就是样式部分，这个部分就更好理解了，是用来定义组件的样式的，但是又两点要注意： 可以设置书写样式的语言：123456&lt;style lang=&quot;less&quot;&gt;&lt;/style&gt;&lt;style lang=&quot;sass&quot;&gt;&lt;/style&gt; 可以通过这个lang属性来设置语言，如果不设置默认就是css. 可以设置样式的作用域： 默认是全部生效的作用域，什么意思呢，就是在这种情况下设置的样式会应用到页面中所有符合条件的元素上。 通常情况下会这样设置： 12&lt;style scoped&gt;&lt;/style&gt; 加一个scope属性就只对当前组件有效。 总结看到这里就明白vue的组件化开发的便利之处了，把网页当成若干个组件，方便维护管理，并且有着很高的可复用性，并且本身就是只关心业务逻辑，使得开发简化，佩服佩服。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>VUE学习笔记</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>VUE</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack的基本使用]]></title>
    <url>%2F2019%2F07%2F25%2Fwebpack%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。这是webpack中文文档中的一段话。合理的使用好webpack可以使我们模块化开发以及后期的维护更加的便利，这也是webpack会是现在比较流行的打包工具之一，这篇博客就将介绍webpack的基本用法。 npm的使用如果对于npm还不是特别的熟练或者是了解可以先看一看这一部分的内容，来讲一讲npm的使用，npm是一款基于node.js的包管理工具，我们项目中用到的许多包都可以通过npm来安装到项目中然后加以使用，先来说一说简单的命令： 首先是在项目中使用npm init来生成一个package.json这个配置文件中保存的是项目信息，也可以通过使用npm init -y来快速的生成一个package,但是要注意的一点是如果当前项目所在的文件名称中包含中文，那么就不能快速创建package文件，在手动配置时需要将项目名称命名为非中文的名称，这里简单的介绍npm，就不详细解释package中的内容了。 npm安装模块的基本语法：npm install &lt;Module Name&gt;，其中install可以简写为一个i，如果不加模块名称则安装所有package中保存有信息的包. 可以通过npm uninstall &lt;Module Name&gt;来卸载已经安装模块。 可以通过npm update &lt;Module Name&gt;来更新已经安装模块。 可以使用npm install &lt;Module Name&gt; -g来全局安装模块，没有-g则只是安装在项目中。 可以通过npm install npm -g命令升级npm来保持npm是最新版本。 切换包的仓库，默认的npm的包的仓库是在国外的，所以国内访问的话就会有较大的延迟，所以会导致下载速度较慢，这里提供一种较简单的切换包的仓库的办法：npm i nrm -g安装nrm这样一个工具，然后通过nrm ls可以查看所有支持的包的仓库名称，通过nrm use taobao则可以切换仓库地址，这里就以淘宝镜像为例。这样下载速度就可以有很明显的提升。 npm install &lt;Module Name&gt; -S与npm install &lt;Module Name&gt; -D的区别，首先弄懂这二者之间的区别要先了解到-D是--save的缩写，而 -D是--save-dev的缩写，这二者之间的区别就在于-S会将包的信息保存到package的“dependencies”中，而-D则将保存到“devDependencies”中。而这二者之间的区别就在于如果是“dependencies”中的包是项目发布或者是运行时所依赖的包，而“devDependencies”中的包则是开发时说要用到的包。总的来说就是像jQuery这种在运行时就需要用到的包就需要通过npm install &lt;Module Name&gt; -S来安装，而在开发过程中使用的工具，就像webpack这样的就是使用npm install &lt;Module Name&gt; -D来安装，因为发布运行时并不依赖这些开发工具。 这里在简单介绍一下npxnpx 是在npm中的一种安装工具，在npm 5.2.0的版本的时候就已经开始默认安装了，那么这个工具究竟是干什么的呢。 我们都知道可以全局安装和单独在项目中安装模块，但是只有全局安装时才可以直接使用模块提供的一些命令，如果只是在项目中安装的包则需要在package.json中配置script然后通过npm run-script的形式来执行命令。 那么有了npx就可以不用这么麻烦了，直接通过npx &lt;command&gt;就可以直接执行本地的而非全局中的命令，并且如果项目中没有安装相应的包则会先帮你安装，十分的便利。 这里就介绍一些我平时可能用的比较多的一些命令，其他的就不详细介绍了，开始介绍webpack的使用。 webpack的安装 先在项目文件夹中初始化一下 1npm init -y 在创建两个文件夹dist和src,dist存放打包后的文件，src放源文件。 安装webpack 1$ npm i webpack webpack-cli -D 由于这里使用的webpack只是一个项目的构建工具，所以使用-D的形式来安装，并且由于后面一些插件需要项目本地安装webpack，所以这里就没有使用全局安装。 webpack的初步使用这里通过引入jQuery来简单的使用一下webpack： 在src文件夹中创建两个文件index.html和index.js，并且引入： 1234&lt;body&gt; &lt;div class="test"&gt;这是一段文字&lt;/div&gt; &lt;script src="../dist/bundle.js"&gt;&lt;/script&gt;&lt;/body&gt; 这里以使用jQuery为例，如果我们不使用webpack进行打包，那么我们要使用jQuery就必须在页面中还要引入jQuery，这样会造成二次加载，造成不必要的资源浪费，所以我们可以使用ES6中的引入模块的语法，在index.js中引入jQuery模块。 先安装jQuery，由于时运行时也需要的依赖，所以通过-S的方式来安装。 1$ npm i jquery -S 引入jQuery，并且进行一些操作 12import $ from 'jquery'$('.test').html('这是一段新的文字'); 但是通过上面这些操作是会直接报错的，因为浏览器目前还不支持这样的使用语法。这也是为什么要使用webpack的原因之一，通过webpack就可以将这文件打包，并且将其中的新语法进行转换，从而使得浏览器能够运行。 12$ npx webpack ./src/index.js -o ./dist/bundle.js --mode development(这里也可以配置package中的script来简化操作命令) 此时原来报错的js文件就打包好了，打包好的新的名为bundle.js的文件就存放在dist文件夹中，我们需要在html中引入新的js文件 这里的mode可以不配置，默认时producition模式，后面可以在配置文件中进行配置。 引入好打包好的js文件再次打开网页就可以发现并不会再报错了，并且可以正确的执行相关操作，这样就进行好了一次简单的打包。 webpac配置文件webpack的相关配置都是通过配置webpack.config.js这个文件来实现的，这个文件默认没有，需要自己手动的创建，并且放在项目的根目录中。 我们可以先做一下简单的配置：123456789101112// 导入处理路径的模块var path = require('path');//配置信息module.exports = &#123; entry: path.resolve(__dirname, 'src/index.js'), // 项目入口文件 output: &#123; // 配置输出选项 path: path.resolve(__dirname, 'dist'), // 配置输出的路径 filename: 'bundle.js' // 配置输出的文件名 &#125;, //配置模式：development、production none 三选一 mode: 'development' //开发过程中使用development、发布时使用production。&#125; 通过这样简单的配置我们再次打包时所用的命令就会更加的简单了，因为配置都写在了配置文件中：1$ npx webpack 通过配置好相关的配置文件，就可以在执行命令的时候就不用再加上相应的配置了。 使用插件通过上面的例子我们会发现这样打包其实也是不够便捷的，那么我们可以通过安装插件来使我们的使用更加的便捷。 webpack-dev-server这款插件的作用就是不再需要我们自己手动的去打包，使用了这款插件以后当我们保存代码以后就会进行自动打包，使我们的开发更加的便利。 安装1$ npm i webpack-dev-server -D 使用可以通过$ npx webpack-dev-server来启动服务 配置 首先我们可以通过配置package中的script来简化我们的命令：1234&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;, &quot;dev&quot;: &quot;webpack-dev-server&quot;&#125; 这样设置以后我们就可以通过npm run dev来简化操作了。 我们可以配置webpack-dev-server来更进一步的简化我们的操作，有两种方式： 方式一：修改package.josn中的命令来配置1&quot;dev&quot;: &quot;webpack-dev-server --hot --port 4321 --open --contentBase src&quot; 这里解释一下这些配置都是什么含义： --hot 启用热更新 --port 4321修改端口为4321 --open 自动打开浏览器 --contentBase src默认打开的是src文件夹而不是项目跟路径 方式二：配置webpack.config.js 头部引入webpack包： 1const webpack = require(&apos;webpack&apos;); 在module.exports新增配置信息： 123456devServer: &#123; hot: true, open: true, port: 4321, contentBase: 'src'&#125; 在 plugins 数组中新增： 123plugins: [ new webpack.HotModuleReplacementPlugin()], 问题这样配置好后再继续使用确实是会简便很多，但是启动之后我们还是能够发现一个问题，那就是似乎启动之后的页面并没有得到我们想要的结果，那么问题处在哪里呢，其实这是因为通过webpack-dev-server启动打包的js文件并不是我们手动打包生成的那个js文件，并且原来我们手动打包生成的那个js文件也已经无效了，而通过 webpack-dev-server 打包生成的js文件是存放在内存中的，路径是在项目的根路径中，所以解决这个问题的方法有三种。 修改网页的引用路径： 1&lt;script src="/bundle.js"&gt;&lt;/script&gt; 修改 webpack-dev-server 配置 123devServer: &#123; publicPath: &quot;/dist/&quot;,&#125;, 使用 html-webpack-plugin 插件后面详细介绍这款插件，这里就不做过多介绍。 html-webpack-plugin前面说到了在使用 webpack-dev-server 出现的问题，也提到了这个问题也可以通过 html-webpack-plugin 这款插件来解决，那么来看看如何使用这款插件： 安装1$ npm i html-webpack-plugin -D 配置 导入模块 1const htmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;); 添加到 plugins 数组中 123456plugins: [ new htmlWebpackPlugin(&#123; template: path.resolve(__dirname, &apos;src/index.html&apos;),//源文件路径 filename: &apos;index.html&apos;//自动生成的HTML文件的名称 &#125;)], 配置好以后就可以使用了，那么这款插件是起什么作用的呢，前面提到了 webpack-dev-server 插件会将js文件生成到根路径内存中，那么 html-webpack-plugin 这款插件也是类似的，将html文件生成到内存中，并且会将页面中原本对js的引用失效，换成对内存中在根路径的js文件的引用，刚好也解决了前面插件的问题，同时存放在内存中也能够提高运行速度，并且会在output.path的路径中生成一份由我们命名的html文件，方便管理，并且这个新生成的文件会自动引入入口js文件，所以在源文件中就要把原来对入口文件的引用去掉。 loadersloader 用于对模块的源代码进行转换。当源代码中引入了非js模块的时候就有可能会出现无法打包的情况，这是因为webpack默认是无法处理除了js之外的文件的，那么此时就要用到各种各样的loader来帮助我们处理这些文件或者模块了。 css-loader在一个前端项目中我们除了js之外最长用到的应该就是css文件了，如果直接在入口文件中引入css文件的话在打包的时候就会报错，这是后就需要用相应的loader来处理了。 像是这样直接使用就会报错：123import $ from 'jquery'import './index.css' $('.test').html('这是一段新的文字'); 那么来看看如何使用 css loader： 先是通过$ npm i style-loader css-loader -D来安装两个需要的loader 然后再到配置文件中进行相应的配置： 12345module: &#123; // 用来配置第三方loader模块 rules: [ // 匹配规则 &#123; test: /\.css$/, use: ['style-loader', 'css-loader'] &#125;//处理css文件的规则 ]&#125;, test 就是相应要匹配的文件，这里使用的是正则表达式，表示匹配的是以 .css 结尾的文件。use是一个表示要用什么loader来处理前面 test 匹配的文件。 less-loaderless-loader 与css-loader类似，只不过是用来处理less文件的： 通过npm i less-loader less -D 来安装。 2.设置匹配规则：1&#123; test: /\.less$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;, &apos;less-loader&apos;] &#125;, sass-loadersass-loader 与css-loader类似，只不过是用来处理scss文件的： 通过npm i sass-loader node-sass --D 2.设置匹配规则：1&#123; test: /\.scss$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;, &apos;sass-loader&apos;] &#125; file-loader当我们通过url地址引用一些图片或者是字体图标的时候，webpack默认也是处理不了的，这个时候我们就需要使用到file-loader了： 比如在css中设置背景图片时：123456.test &#123; color: aqua; width: 400px; height: 400px; background: url(./images/1.png);&#125; 使用 file-loader ： 通过$ npm i file-loader -D安装 2.设置匹配规则：12&#123; test: /\.(png|jpg|gif)$/, use: 'file-loader?name=[name].[ext]' &#125;, //匹配图片，并且设置参数图片名称为图片原本名称加上原本后缀名&#123; test: /\.(ttf|eot|svg|woff|woff2)$/, use: 'file-loader' &#125;,//匹配字体 可以像这样设置参数，具体有哪些选项并且有什么作用可以看这里。 其他loader还有其他的一些loader这里就不一一介绍了，在有需要的情况下可以选择安装，这里是官方文档。 总结webpack是一款非常优秀的打包工具，这篇博客的例子非常简单，只演示了单入口单页面的情况，但是我们已经可以看出使用webpack带来的便利了，所有的资源全部被打包在了output.path目录中，也可以通过配置file-loader将图片之类的资源放在单独的子目录中在图片多的情况下方便管理。 最后再讲一下publicPath，这个的作用就是设置文件最终输出时的相对路径前面的路径。]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解JS中的执行环境]]></title>
    <url>%2F2019%2F07%2F21%2F%E7%90%86%E8%A7%A3JS%E4%B8%AD%E7%9A%84%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;执行环境（execution context）也有翻译为执行上下文，这是JS中非常基础但是也非常重要的一个概念，通过理解执行环境我们可以更加了解js的运作机制。这篇文章就来简单理解一下什么是执行环境，以及它究竟是怎么样运作的。 什么是执行环境执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。这是高级编程中的一句话。 说简单点理解，执行环境其实就是一个环境，在这个环境中保存了一些重要的数据。 每个函数都有自己的执行环境，此外还存在一个全局的执行环境，在web浏览器中，该执行环境被认为是window对象（因为所有的属性和方法都是window对象创建的）。 当执行环境中的所有代码执行完毕后，该执行环境就会被销毁，退出执行栈。（全局执行环境直到浏览器关闭才会被销毁） 执行环境与执行栈要理解执行环境我们还需要了解一个概念：执行栈。我们都知道栈是一种LIFO（Last-In-First-Out）的数据结构，也就是后进先出。 通过我前面的关于js事件循环机制的文章现在我们可以知道，当js执行到非异步的函数的时候会立马将该函数推入到执行栈中，那么现在我们可以知道被推入执行栈的是该函数的执行环境,当函数执行完毕就会被弹出，也就是执行环境被销毁，然后根据执行流继续执行后面的代码。 到这里我相信执行环境的基本概念已经有了，也就是在执行某一函数时的环境，当函数执行完毕该环境就会被销毁。 现在我们可以通过一个例子来更加形象的理解执行栈与执行环境：123456789function foo() &#123; console.log(&apos;csznb&apos;); function bar() &#123; console.log(&apos;cszsfyq&apos;); &#125;&#125;function baz() &#123; console.log(&apos;cszfcs&apos;);&#125; 我们可以通过图片方便理解： 通过图片我们就可以很直观的理解执行栈与执行环境了。 在开始执行foo函数之前，执行栈中就只有全局的执行环境， 当执行到foo函数就会把其执行环境推入执行栈中执行其中的代码， 当执行到bar函数则把bar函数的执行环境推入到执行栈中，由于此时这两个函数都还没有执行完毕，所以这两个函数的执行环境都存在于执行栈中， 当执行完bar函数中的代码，bar函数的执行环境就被弹出，foo函数的代码也意味着执行完毕，执行环境也被弹出， 接着开始执行baz函数，将其执行环境推入执行栈中，当执行完函数中的代码则被弹出， 最后只剩下一个全局执行环境，当浏览器关闭，全局执行环境也被销毁。 执行环境中的内容前面也提到了执行环境其实就是一个环境，其中保存了重要的数据，那么究竟保存的是什么数据呢？ 首先执行环境中很重要的一部分就是变量对象，变量对象将包含当前函数中的许多重要信息。 执行环境中还保存了作用域链，当代码在一个环境中执行时，会创建变量对象的一个作用域链。 另外在执行环境中还确定了this的指向。 关于这三者的详细理解这里我就不介绍了，后面会些专门的文章来解释。 总结当执行到一个函数，该函数的执行环境就会被推入执行栈，当这个函数完全执行完毕执行环境就会被弹出执行栈。全局执行环境一开始就存在与执行栈之中，只有当浏览器关闭才会被销毁。 这里只介绍了一些关于执行环境基本的知识，后面还会有更加详细的关于变量对象以及作用域链的理解。]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS原型与原型链以及继承]]></title>
    <url>%2F2019%2F07%2F19%2FJS%E5%8E%9F%E5%9E%8B%E9%93%BE%E4%B8%8E%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在js对象中有一个非常重要的概念，就是原型，通过原型模式创建对象就可以共享特定的属性以及方法，合理的使用就可以减少代码量以及减少资源的消耗。这里提到原型就不得不提一下原型搜索机制：当以读取模式访问一个实例属性时，首先会在实例中搜索该属性。如果没有找到该属性，则会继续搜索实例的原型，这是在没有原型链的情况下，在通过原型链实现继承的情况下，搜索过程就得以沿着原型链继续向上。实际上原型链就是扩展了原型的搜索范围。而原型链的产生主要是通过继承来实现，这就是原型与原型链及继承这三者之间的关系。 原型与原型对象在理解原型链与继承之前需要理解原型与原型对象的概念： 我们都知道，我们创建的每一个函数都拥有一个prototype属性，这个属性的属性值是一个指针，指向一个对象，而这个对象就是原型对象，其中保存了我们定义的所有在原型上的属性或者方法，那么只要是在原型对象当中，那么这个函数的所有实例就可以访问到其中的属性或者方法，所以所这些属性和方法是共享的。 在原型对象当中，有一个属性叫做constructor，这个属性的属性值是一个指针，指向了当初添加了原型的那个函数。 当调用了函数创建了一个实例对象的时候，这个实例内部又还会有一个属性，这个属性是一个指针叫做[[prototype]]，而这个指针就指向了原型对象,对于这个属性的访问没有定义相关的标准，但是在Firefox、chrome、safari中每个实例对象都可以看到一个proto属性，其它浏览器则是完全不可见。 构造函数、原型、原型对象这三者之间的关系可以这样理解（假设有一个Person构造函数并且有相应的原型对象）：通过这张图就可以很直观的看出三者之间的关系了。 值得注意的一点是由于原型中查找相应的值是一次搜索过程，所以一旦修改了原型对象，所发生的改变就会立刻反映出来，实例或者构造函数中原型的值也会立刻跟着变化，无论创建的先后。 正如上面所提到可以修改原型对象，一旦重写了原型对象就会导致constructor的指针发生变化，如果需要则要手动设置constructor. 原型链 ECMAScript中描述了原型链的概念，并将原型链作为实现继承的主要方法。 前面我们已经简单了解过原型的相关知识了，那么原型链其实顾名思义就像一条链条一样，这条链条上全都是各种不同的原型，而我们由前面就可以知道属性的搜索机制是先在当前实例中找，找不到再到原型中找，通过原型链连接许多不同的原型就可以扩大属性的搜索范围，这就是原型链的作用。 这是实现原型链的一种基本模式： 1234567891011121314function Test1() &#123; this.name1 = 'csz1'; Test1.prototype.name2 = 'csz2';&#125;function Test2() &#123; this.name3 = 'csz3'; Test2.prototype.name4 = 'csz4';&#125;Test2.prototype = new Test1();const obj = new Test2();console.log(obj.name1);//通过原型链访问到Test1 csz1console.log(obj.name2);//通过原型链访问到Test2 csz2console.log(obj.name3);//在实例中找到 csz3console.log(obj.name4);//在原型中找到 csz4 可以看出通过手动将Test1构造函数的实例绑定到Test2的原型上形成一条原型链，Test2的实例就可以通过原型链访问到Test1实例中的属性以及原型中的属性。 这条原型链可以简单的像这样表示：obj[[prototype]] =&gt; Test2.prototype =&gt; new Test1() =&gt; Test1.prototype =&gt; Object.prototype 需要注意的一点是在设置原型的时候最好不要通过对象字面量来创建原型方法，这会导致重写原型链，从而致使原型链被切断。 继承 许多OO语言都支持两种继承模式，接口继承与实现继承，ECMAScript则只支持实现继承，并且将原型链作为实现继承的主要方法。 通过上面对原型链的理解，我们也知道如何通过原型链来实现继承（主要就是通过搜索机制）。 主要有六种继承的方式： 一、通过原型链来实现继承 通过上面原型链的例子我们知道可以通过将一个构造函数的实例设置给另一个构造函数的原型通过原型链来实现继承，并且可以看出原型链的作用十分强大。 但是直接通过原型链来实现继承也存在一些问题，我们可以看看下面这个例子： 1234567891011121314151617181920function Test1() &#123; this.name1 = 'csz1'; this.arr = [1, 2, 3, 4, 5, 6]; Test1.prototype.name2 = 'csz2'; Test1.prototype.fn = function () &#123; return 'test1'; &#125;;&#125;function Test2() &#123; this.name3 = 'csz3'; Test2.prototype.name4 = 'csz4';&#125;//将Test的原型设置为Test1的实例，这条语句必须写在Test2外面Test2.prototype = new Test1();Test2.prototype.constructor = Test2;const obj1 = new Test2();const obj2 = new Test2();obj1.arr.push(999);console.log(obj1.arr); //[1, 2, 3, 4, 5, 6, 999]console.log(obj2.arr); //[1, 2, 3, 4, 5, 6, 999] 可以看出当我们通过 obj1 这个实例修改了数组 arr 中的值，结果导致 obj2 中数组 arr 中的值也一起跟着修改了，那么为什么会出现这样的结果呢，其实我们不难发现当我们在执行这条语句的时候Test2.prototype = new Test1();是直接将一个实例设置给了 Test2的原型，这就会导致原本在Test1实例属性中的数组到了Test2中就变成了原型中的数组，那么就相当于在Test2的原型中设置了一个引用类型的属性一样，我们都知道原型对象中的属性相当于是共享的，所以结果可想而知。很明显得不到我们想要的结果。这是其中的一个问题。 还有一个问题则是在创建子类型实例时无法很完美的给超类型传递参数（虽然可以传递，但会影响到所有的实例）。所以实践当中不推荐使用这种方式来实现继承。 二、借用构造函数为了解决上面出现的这些问题，开发人员开始使用一种叫做借用构造函数（constructor stealing）的技术，使用起来也很简单，在子类型构造函数中调用超类型构造函数就可以实现。 可以传递参数：1234567891011121314151617function Test1(money) &#123; this.name1 = 'csz1'; this.money = money; this.arr = [1, 2, 3, 4, 5, 6]; Test1.prototype.name2 = 'csz2'; Test1.prototype.fn = function () &#123; return 'test1'; &#125;;&#125;function Test2() &#123; //借用了Test构造函数，并且可以通过call或者aplly方法来传递参数并改变this指向 Test1.call(this, 1000); this.name3 = 'csz3'; Test2.prototype.name4 = 'csz4';&#125;const obj2 = new Test2();console.log(obj2.money); //1000 通过这个例子可以看出通过借用构造函数可以实现参数的正常传递，获取到相对应的值。 为了确保子类型的属性不被借用来的构造函数重写，应该确保将子类型的属性写在借用来的超类型构造函数之后。 子类型实例间不会相互影响：12345678910111213141516171819function Test1(money) &#123; this.name1 = 'csz1'; this.money = money; this.arr = [1, 2, 3, 4, 5, 6]; Test1.prototype.name2 = 'csz2'; Test1.prototype.fn = function () &#123; return 'test1'; &#125;;&#125;function Test2() &#123; this.name3 = 'csz3'; Test1.call(this, 1000); Test2.prototype.name4 = 'csz4';&#125;const obj1 = new Test2();const obj2 = new Test2();obj1.arr.push(999);console.log(obj1.arr);//1, 2, 3, 4, 5, 6, 999]console.log(obj2.arr);//[1, 2, 3, 4, 5, 6] 可以看出由于借用来的属性全在构造函数当中，不在原型当中，所以不会出现引用类型的数据相互影响的情况。 借用构造函数存在的问题由于借用构造函数借来的属性以及方法全都是在构造函数的实例当中，所以单纯的这种方式就无法访问到超类型的原型上的属性和方法:1234567891011121314151617181920function Test1(money) &#123; this.name1 = 'csz1'; this.money = money; this.arr = [1, 2, 3, 4, 5, 6]; Test1.prototype.name2 = 'csz2'; Test1.prototype.fn = function () &#123; return 'test1'; &#125;;&#125;function Test2() &#123; this.name3 = 'csz3'; Test1.call(this, 1000); Test2.prototype.name4 = 'csz4';&#125;const obj1 = new Test2();const obj2 = new Test2();obj1.arr.push(999);console.log(obj1.arr);//1, 2, 3, 4, 5, 6, 999]console.log(obj2.arr);//[1, 2, 3, 4, 5, 6]console.log(obj2.name2);//undefined 可以看出访问存在于超类型构造函数原型中的属性是访问不到的，所以单纯的借用构造函数也是不推荐使用的。 三、组合继承为了解决前面提到的两种方法的缺点，就出现了组合继承，组合继承简单来说就是将通过原型链来继承和通过借用构造函数来继承这两方法进行组合，互相取长补短，发挥二者的优势，以达到一个较好的继承效果。其实现思路是通过原型链的方式来继承超类型原型上的属性和方法，通过借用构造函数来继承超类型中构造函数上的属性和方法。 来看看具体是怎么实现的：12345678910111213141516171819202122232425function Test1(money) &#123; this.name1 = 'csz1'; this.money = money; this.arr = [1, 2, 3, 4, 5, 6]; Test1.prototype.name2 = 'csz2'; Test1.prototype.fn = function () &#123; return '这是test1'; &#125;;&#125;function Test2() &#123; // 通过借用构造函数来继承实例中的属性和方法 Test1.call(this, 999); this.name3 = 'csz3';&#125;//通过原型链来继承超类型构的原型Test2.prototype = new Test1();Test2.prototype.constructor = Test2;Test2.prototype.name4 = 'csz4';const obj1 = new Test2();const obj2 = new Test2();console.log(obj1.name2);//csz2console.log(obj1.money);//999obj1.arr.push(666);console.log(obj1.arr);// [1, 2, 3, 4, 5, 6, 666]console.log(obj2.arr);// [1, 2, 3, 4, 5, 6] 从结果可以看出使用组合继承成功的集合了原型链继承和借用构造函数继承的优点，同时弥补了二者的缺点，是一种比较实用的继承方式，推荐使用。 组合继承也并不是完全没有缺点，也存在一些小问题，像是要调用两次超类型构造函数，存在资源的浪费，但是问题不大，后面会介绍一种更加完美的继承方式，到时再详细介绍。 四、原型式继承&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原型式继承由道格拉斯·克罗克福德在2006年写了一篇文章，题为Prototypal Inheritance in JavaScript （JavaScript中的原型式继承）中介绍，他介绍了一种实现继承的方法，这种方法并没有使用严格意义上的构造函数。他的想法是借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。为了实现这个目的，他给出了如下函数：12345function object(o) &#123; function F()&#123;&#125; F.prototype = o; return new F(); &#125; 通过这个函数就可以看出其实这个函数的作用就是将一个已有的对象转化为一个中间构造函数的原型对象，最后通过这个函数来返回新的实例，而这个新的实例则是这个在函数中的构造函数的实例，所以新的实例就会将我们传递给函数的这个对象当作原型对象。 从本质上来说，object()函数对传入其的对象进行了一次浅复制。 简单一点理解就是通过这个函数可以返回一个新的对象，返回的所有新对象共享传递给函数的对象作为原型对象。与原型链模式类似，所以在在使用引用类型的数据的时候需要格外注意。 我们可以通过一个例子来理解：1234567891011121314151617function object(o) &#123; function F() &#123; &#125; F.prototype = o; return new F();&#125;obj1 = &#123; name: 'csz1', age: 56, arr: [1, 2, 3, 4, 5, 6, 7]&#125;const obj2 = object(obj1);const obj3 = object(obj1);console.log(obj2.name);//csz1//引用类型的数据会相互影响obj2.arr.push(666);console.log(obj3.arr);//[1, 2, 3, 4, 5, 6, 7, 666]console.log(obj2.arr);//[1, 2, 3, 4, 5, 6, 7, 666] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;克罗克福德主张的这种原型式继承需要有一个对象作为基础，如果有一个现成的对象，需要根据这个对象为原型创建一个新的对象再稍作修改的话，使用这种方式就比较快速便捷。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ECMAScript5中新增了一个Object.creat()方法来规范原型式继承，这个方法接收两个参数，第一个参数是一个需要作为基础的对象，第二个参数是为新对象定义额外属性的对象。 当只传入一个参数时效果与前面的克罗克福德的object函数一样。 第二个参数的格式与可以设置新对象的额外属性，新的属性会覆盖掉作为第一个参数的那个对象的同名属性，使用格式Object.defineproperties()方法一致： 123456789101112obj1 = &#123; name: 'csz1', age: 56, arr: [1, 2, 3, 4, 5, 6, 7]&#125;const obj2 = Object.create(obj1, &#123; //要使用这种格式 name: &#123; value: 'csz2' &#125;&#125;)console.log(obj2.name);//csz2 在需要使用到原型式继承时可以直接使用Object.creat()会更加的便捷。 五、寄生式继承寄生式（parasitic）继承是与原型式继承紧密相关的一种思路，并且同样也是由克罗克福德推而广之的。让我们来看看它是如何工作的：1234567891011121314obj1 = &#123; name: 'csz1', age: 56, arr: [1, 2, 3, 4, 5, 6, 7]&#125;function createAnother(original) &#123; var clone = Object.create(original); clone.sayHi = function () &#123; console.log("hi"); &#125;; return clone;&#125;const obj2 = createAnother(obj1);console.log(obj2.sayHi());//hi &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实可以看出寄生式继承是原型式继承的一种扩展，相当于是把原型式继承的函数以及新对象需要扩充的属性同时封装在一个函数当中。可以在需要使用原型式继承并且需要在内部扩充属性时使用。 注意在使用寄生式继承来为对象添加方法时不能够做到函数复用，这一点类似创建对象时的造函数模式。 六、寄生组合式继承前面提到了比较完美的组合继承也存在着缺陷，两次调用超类型构造函数，并且存在着资源浪费的情况（因为原型是超类型的实例所以会存在着有属性与子类型实例重名的情况，造成不必要的资源浪费），虽然问题不大，但是有一种更加完美的继承方式，也就是寄生组合式继承。 那么 寄生组合式继承是如何解决问题的呢： 首先，还是使用借用构造函数来实现对超类型实例中属性和方法的继承。 其次，使用原型链的混成形式来继承原型中的属性和方法。具体做法原理是使用寄生式继承来继承超类型的原型对象，将结果指定给子类型的原型，并且将constructor重新指会子类型。可以将这一过程封装成一个函数，并设置两个参数，一个是子类型，一个是超类型，如下： 12345function inheritPrototype(obj1, obj2) &#123; var prototype = Object.create(obj2.prototype); //创建原型对象 prototype.constructor = obj1; //将constructor重新指向子类型 obj1.prototype = prototype; //修改子类型的prototype&#125; 使用 寄生组合式继承 来优化前面的组合继承的例子：123456789101112131415161718192021222324function Test1(money) &#123; this.name1 = 'csz1'; this.money = money; this.arr = [1, 2, 3, 4, 5, 6]; Test1.prototype.name2 = 'csz2'; Test1.prototype.fn = function () &#123; return '这是test1'; &#125;;&#125;function Test2() &#123; // 通过借用构造函数来继承实例中的属性和方法 Test1.call(this, 999); this.name3 = 'csz3';&#125;//通过原型链混成形式来继承超类型构的原型inheritPrototype(Test2, Test1);Test2.prototype.name4 = 'csz4';const obj1 = new Test2();const obj2 = new Test2();console.log(obj1.name2);//csz2console.log(obj1.money);//999obj1.arr.push(666);console.log(obj1.arr);// [1, 2, 3, 4, 5, 6, 666]console.log(obj2.arr);// [1, 2, 3, 4, 5, 6] 可以看出依然可以得出一样的理想的结果，但是通过这种形式就不存在着资源浪费的情况，是最完美的一种继承方式。 总结这里着重介绍了继承的几种方式，以及优缺点，理解这六种继承方式是非常有必要的，以后就知道该使用哪种继承方式了，同时也对理解JS这门语言十分有帮助。 参考《JavaScript高级程序设计(第三版)》]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中的高阶函数]]></title>
    <url>%2F2019%2F07%2F16%2FJS%E4%B8%AD%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;函数是一门语言的重要组成部分，并且js中的函数还有很多特别的地方，比如函数是第一公民，那么这次来了解一下什么是高阶函数。 什么是高阶函数高阶函数的概念很简单，指的就是一个函数将另一个函数作为参数，那么这个函数就是高阶函数。一个简单的高阶函数：1234567function sum(x, y, fn) &#123; return fn(x) + fn(y);&#125;function add1(num) &#123; return num += 1;&#125;console.log(sum(2, 3, add1)); 这就是一个简单的高阶函数，将一个函数作为另一个函数的参数。 JS中自带的高阶函数 map/reduce filter sort 。。。还有其他很多的方法都是高阶函数 以上这些我们经常用的方法其实都是高阶函数，因为我们每次在使用时都需要传递一个函数作为参数。 自己写一个Map函数既然我们现在知道了什么是高阶函数，那么我们就可以自己写一个与js中自带的高阶函数类似的高阶函数出来，这里我们自己写一个类似map方法的高阶函数出来： 12345678910111213Array.prototype.myMap = myMap;function myMap(fn) &#123; let arr = []; for (let i = 0; i &lt; this.length; i++) &#123; arr.push(fn(this[i], i)) &#125; return arr;&#125;const arr2 = [1, 23, 3, 45, 6];const res = arr2.myMap(function (item, index) &#123; return item + index;&#125;)console.log(res);//[1, 24, 5, 48, 10] 这样就实现了一个我们自己的map方法，在效果方面与js中自带的方法几乎没有差别，实现js中其他的高阶函数的做法和这个类似。 总结通过了解掌握高阶函数对于理解js中的函数很有帮助，并且学会使用高阶函数在以后的开发中也会很有帮助。]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中的基本包装类型]]></title>
    <url>%2F2019%2F07%2F16%2FJS%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们都知道js中的数据有两大类型，基本数据类型和引用类型，但是我们也知道从逻辑上来说其实基本类型的数据其实并不是对象，也就没有属性和方法，但实际上我们在使用的过程中这些基本类型的数据也是有属性和方法的，其实这主要是依赖于基本包装类型。 理解基本包装类型 那么为什么我们使用的基本类型数据会有方法和属性呢，其实主要是由于基本包装类型的原因，当我们在对基本类型的数据调用一个属性或者方法时其实后台还会有一系列的操作来进行转换，从而能够正确的获取结果，我们可以像下面这样理解： 1234&#123; const str=&apos;这是一个字符串&apos;; const len=str.length;&#125; 通过这样的操作我们可以length这个属性来获取到字符串的长度，并且将这个长度赋值给 len 这个变量。、 +但实际上它在后台的操作可以这样进行理解：12345&#123;const str_ = new String(&apos;这是一个字符串&apos;); //创建基本包装类型的对象，并且自动获取到字符串的值const len=str_.length; //调用基本包装类型对象的属性来获取长度str_=null; //调用结束后销毁对象&#125; 通过上面的例子我们就可以很简单的理解基本包装类型了，基本包装类型就像是一个中转站一样，虽然基本类型的数据不是对象，但是通过后台的操作创建一个基本包装类型对象，所以我们调用基本类型的属性或者是方法实际上调用的是基本包装类型的属性或者方法，当调用完毕后再进行销毁，最终我们看到的结果就像是基本数据类型有属性或者是方法一样。 不能给基本类型数据添加属性或者方法我们可以看出虽然基本类型数据表面上看起来可以调用数据和方法，但是实际上我们也还是不能够给他们添加方法或者是属性，因为他们根本上还是基本类型数据，并且基本包装类型对象在执行完毕后会立即销毁：12345&#123; var str2 = &apos;字符串&apos;; str2.name = &apos;csz&apos;; console.log(str2.name);//报错，不能在字符串上创建&#125; 可以创建基本包装类型对象我们可以通过显示调用Boolean、Number、String来创建基本包装类型对象。123456789101112&#123; const str = new String(&apos;这是一个通过构造函数创建的字符串&apos;); const num = new Number(1234); const res = new Boolean(true); const str2 = new Object(&apos;这是一个通过Object构造函数创建的字符串&apos;); console.log(typeof str);//object console.log(str instanceof String);//true console.log(typeof num);//object console.log(num instanceof Number);//true console.log(typeof str2);//object console.log(str2 instanceof String);//true&#125; 可以看出是可以通过显示的创建基本包装类型对象的，甚至可以直接通过Objct构造函数自动识别来创建，但是并不推荐通过这种方式来创建基本类型数据，因为这样创建的数据通过typeof判断的是一个对象，而不是基本数据类型。 特别是在创建Boolean类型数据时尤为要注意：123456&#123; const res = new Boolean(false); console.log(res &amp;&amp; true);//true const res2 = false; console.log(res2 &amp;&amp; true);//false&#125; 得到这个结果也并不奇怪，因为通过基本包装类型创建的数据实际上是一个对象，当进行比较运算时，对象都是一律按true处理的，所以这里并不能得到我们想要的结果。 所以建议永远不要通过实例化构造函数的形式来创建Boolean类型的数据。 总结基本包装类型很好理解，了解基本包装类型对于对于理解js运作机制也很有帮助，还有就是一些要注意的地方，比如不要不要通过实例化构造函数的形式来创建Boolean类型的数据。]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中sort方法的使用]]></title>
    <url>%2F2019%2F07%2F13%2FJS%E4%B8%ADsort%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们都知道数组有一个用来排序的方法 sort ，这个方法很有用，免去了我们自己排序的方法，并且这个方法在不同种情况下采用的排序算法也不一样，有着不错的性能，这次来了解一下它的具体用法。 直接使用sort方法sort方法可以不传递参数直接使用：1234&#123; const arr = [1, 23, 4, 5, 122, 223]; console.log(arr.sort());//结果：[1, 122, 223, 23, 4, 5]&#125; 可以看出在不传递参数的情况下直接使用sort方法对一个纯数字的数组来说不能得到我们想要的结果。 原因是因为如果不传递参数，那么在执行sort方法的时候会自动调用 toString 方法将数组中的每个元素都转化为字符串，然后再进行排序。 我们都知道字符串之间的比较实际上比较的是它们的unicode码值，所以就会出现上面的这种结果。 接收参数进行排序sort方法可以接受一个函数作为参数：123456789const arr = [1, 2, 3, 3, 52345, 1, 50, 230];compare = (value1, value2) =&gt; &#123; switch (true) &#123; case value1 &lt; value2: return -1; break; case value1 = value2: return 0; break; case value1 &gt; value2: return 1; break; &#125;&#125;console.log(arr.sort(compare));//结果：[1, 1, 2, 3, 3, 50, 230, 52345] 比较函数接收两个参数，如果想要第一个参数位置位于第二个参数之前，那么就需要比较函数的返回值是一个负数 如果想要第一个参数位置位于第二个参数之后，这需要比较函数的返回值是一个正数 如果想要两个参数相等，则需要比较函数的返回值是0； 通过传递一个比较函数作为参数就不会自动的将数组中的元素转化为字符串了，并且通过相应设置就能很轻松的获取到我们想要的结果。 数组中只有数字当数组中只有数字的时候可以将将排序作为sort方法参数的比较函数简化：12345const arr = [1, 2, 3, 3, 52345, 1, 50, 230];compare2 = (value1, value2) =&gt; &#123; return value1 - value2;&#125;console.log(arr.sort(compare2));//结果：[1, 1, 2, 3, 3, 50, 230, 52345] 可以看出简化后的函数十分的简单，但是只能用于对数字进行排序的情况，根据实际情况选择使用。 一个小例子通过sort排序来实现以下我们经常见到的表格中内容的排序： CSS: 1234567891011121314table &#123; border-collapse: collapse; margin: 20px auto;&#125;td,th &#123; border: 1px solid black; padding: 15px;&#125;#name &#123; margin-left: 630px;&#125; HTML: 123456789101112131415&lt;body&gt; &lt;button id="name"&gt;按姓名&lt;/button&gt; &lt;button id="age"&gt;按年龄&lt;/button&gt; &lt;button id="money"&gt;按财富&lt;/button&gt; &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;财富&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;/tbody&gt; &lt;/table&gt; JS: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//一个存放数据的数组let info = [ &#123; 'name': 'csz', 'age': '18', 'money': 99999999999 &#125;, &#123; 'name': 'csz2', 'age': '19', 'money': 9399999999999 &#125;, &#123; 'name': 'csz3', 'age': '17', 'money': 9239999999999 &#125;, &#123; 'name': 'csz4', 'age': '16', 'money': 9935999999999 &#125;, &#123; 'name': 'csz5', 'age': '41', 'money': 99991599399999 &#125;,];//复制一份，保存原始的没有规律的数据let info2 = [...info];//变回最原始的状态byNormal = () =&gt; &#123; info2 = [...info];&#125;;//按照年龄升序byAge = () =&gt; &#123; info2.sort((value1, value2) =&gt; &#123; return parseInt(value1.age) - parseInt(value2.age); &#125;);&#125;;//按照姓名升序byName = () =&gt; &#123; info2 = [...info]; info2.sort();&#125;;//按照财富升序byMoney = () =&gt; &#123; info2.sort((value1, value2) =&gt; &#123; return value1.money - value2.money; &#125;);&#125;;//将数组中的数据渲染到页面中toHtml = (type) =&gt; &#123; switch (type) &#123; case name: byName(); break; case age: byAge(); break; case money: byMoney(); break; default: byNormal(); &#125; let str = ''; for (item of info2) &#123; str += ` &lt;tr&gt; &lt;td&gt;$&#123;item.name&#125;&lt;/td&gt; &lt;td&gt;$&#123;item.age&#125;&lt;/td&gt; &lt;td&gt;$&#123;item.money&#125;&lt;/td&gt; &lt;/tr&gt; ` &#125; document.querySelector('tbody').innerHTML = str;&#125;toHtml();// 为三个按钮分别绑定渲染的功能document.querySelector('#name').onclick = function () &#123; toHtml(name) &#125;;document.querySelector('#age').onclick = function () &#123; toHtml(age) &#125;;document.querySelector('#money').onclick = function () &#123; toHtml(money) &#125;; 这里实现的都是升序，降序的做法更加的简单，只需要将升序结果的数组调用以下reserve方法就可以了。 各浏览器中的实现 Mozilla/Firefox : 归并排序（jsarray.c 源码） V8 ：数组长度小于一定值时用插入排序，其它用快速排序（array.js 源码 第710行） Webkit ：底层实现用了 C++ 库中的 qsort() 方法（JSArray.cpp 源码） 总结今天在看高级编程的时候看到相关知识，然后自己尝试了一下，再分享记录一下，也可以通过各个浏览器的解释器的代码学习一下排序的知识。]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解js中的内存空间与垃圾回收]]></title>
    <url>%2F2019%2F07%2F11%2F%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3js%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;想要更加的了解js就需要对它的运作机制有更加深入的了解，这次来了解以下js的内存空间与垃圾回收机制，通过理解这两个概念对我们的开发十分有帮助。 内存空间我们都知道js中的数据类型有基础数据类型与引用数据类型之分，二者的运作机制也不一样。 基础数据类型与栈内存 我们知道在创建执行上下文时会找到所有变量声明，并且创建VO同时消耗一定的内存空间，当到达执行阶段的时候VO成为AO，所有变量都可以访问。 当变量的值被修改时就会直接在相应栈内存空间对变量的值进行修改。 当复制一个变量会直接在VO中创建这个变量的值的副本，同时占用新的栈内存空间。 引用数据类型与堆内存 而引用类型的数据在创建执行上下文后，到达执行阶段时，变量保存的实际上是对象的引用，保存的也就是堆内存中堆内存的地址。 当复制一个引用类型的值的时候也会在VO中创建一个值的副本，但是区别在于基础类型的值就是栈内存空间中的值，而引用类型的值是一个地址，所以即使复制了一份，其实两个变量引用的是同一个对象。 当复制保存着对象的某个变量时，操作的是对象的引用。但在为对象添加属性时，操作的是实际的对象，所以修改复制的变量，也会影响到被复制的哪一个变量。 垃圾回收机制js有自动的垃圾回收机制，所有通常我们可以不用管垃圾回收这件事，而垃圾回收一般有两个策略。 标记清除标记清除说简单点就像名字这样理解，清除被标记的变量。 垃圾收集器会在运行时给内存中所有的变量都加上标记 然后会去掉环境中的变量，以及环境中引用的变量的标记 删除那些被标记的变量以及他们的值并且回收相应的内存空间 到 2008年为止，IE、Firefox、Opera、Chrome和 Safari的 JavaScript实现使用的都是标记清除式的 垃圾收集策略（或类似的策略），只不过垃圾收集的时间间隔互有不同。 引用计数引用计数就是记录变量的引用次数，当变量每被使用一次，赋值给另一个变量，该变量的引用次数就加以，被赋值的变量被其他变量赋值，该变量引用次数就减一。如果这个变量引用次数为0则在垃圾收集器运作时将其回收。 最早是Netscape使用这种方法，但是因为这种方法存在问题，所以后来被弃用了。 ###垃圾回收与内存空间及其优化 局部变量只在函数执行的过程中存在。而在这个过程中，会为局部变量在栈（或堆）内存上分配相应的空间，以便存储它们的值。然后在函数中使用这些变量，直至函数执行结束。此时，局部变量就没有存在的必要了，因此可以释放它们的内存以供将来使用。在这种情况下，很容易判断变量是否还有存在的要 由于分配给web浏览器的内存空间通常相比桌面应用程序要更加的少，所以要尽可能都优化内存的消耗。 但是全部变量就不一样，全局变量就在那，不知道你什么时候会用它，并不会被回收，所以并不推荐使用过多的全局变量，推荐使用let与const来创建块级变量，减少内存的消耗。 如果使用了全局变量，最好的处理方式就是在这个变量不再使用就将其设置为null以优化内存消耗。 总结通过梳理清楚js中有关内存相关的知识，可以有对js更加深的认识，对开发以及性能会有很大帮助。]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6的使用]]></title>
    <url>%2F2019%2F07%2F10%2FES6%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ES6， 全称 ECMAScript 6.0 ，是 JavaScript 的下一个版本标准，2015.06 发版。ES6 主要是为了解决 ES5 的先天不足，比如 JavaScript 里并没有类的概念，但是目前浏览器的 JavaScript 是 ES5 版本，大多数高版本的浏览器也支持 ES6，不过只实现了 ES6 的部分特性和功能。ES6的发布到现在已经有很长一段时间了，各个浏览器的新版本也都支持ES6的大部分语法，使用ES6能够极大的提高我们开发的效率以及使提高代码的可读性。 使用ES6来书写代码可以很大程度上的提高代码的书写效率，并且使用也相对简便，新的ES6语法涉及的还是挺多的，这里就介绍使用一些比较常见并且实用的ES6语法。 声明关键字 let 与 const在ES5中我们都是只是用 var 关键字来声明变量，但是 var 存在很多的缺陷，比如定义很多全局变量会导致变量名称冲突，全局变量不好回收，导致占用内存过多需要手动释放等等，使用 let 与 const 就可以有效的避免这些问题。 先来看看他们之间的区别： var let const 作用域 全局、函数 代码块 代码块 重新赋值 能 能 不能 变量提升 能 不能 不能 重复声明 能 不能 不能 其实通过这张表格就能很清楚的知道他们之间的区别了 这里的代码块指的是大括号内，也就是{ }，在大括号中定义的变量在大括号外部就无法访问了。 123456&#123; let a = 30; const b = 40;&#125;console.log(a);//报错未定义console.log(b);//报错未定义 不支持变量提升 12345&#123; console.log(a, b);//报错 let a = 100; const b = 10;&#125; const无法重新赋值 12345&#123; const b = 10; b = 100; //报错&#125; 暂时性死区 123456var a = 100;&#123; console.log(a); let a; //报错&#125; ES6 明确规定，代码块内如果存在 let 或者 const，代码块会对这些命令声明的变量从块的开始就形成一个封闭作用域。代码块内，在声明变量 变量 之前使用它会报错。 推荐不要使用 var 关键字了，全部用 let 与 const 代替。 箭头函数ES6为我们提供了箭头函数。 使用箭头函数可以使代码的可读性更强 并且使用箭头函数可以更好的明确this的指向，就不用特别麻烦的去考虑this的指向了 在不使用箭头函数的情况下函数中的this总是指向调用者，就是说谁最后调用了该函数，那么this就指向谁，此时的this指向是动态的。 12345678910111213const name = &apos;csz2&apos;;&#123; const obj = &#123; name: &apos;csz&apos;, foo() &#123; console.log(`$&#123;this.name&#125;fcnb`); //cszfcnb console.log(this); //&#123;name: &quot;csz&quot;, foo: ƒ&#125; &#125; &#125; obj.foo(); //cszfcnb //&#123;name: &quot;csz&quot;, foo: ƒ&#125; const bar = obj.foo; bar(); //csz2fcnb //Window &#123;postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, parent: Window, …&#125;&#125; 但是动态的this函数指向在使用回调函数的时候经常会得不到我们想要的结果 12345678910111213var name = &apos;csz3&apos;;&#123; const obj = &#123; name: &apos;csz&apos;, chara: [&apos;fcyq&apos;], foo() &#123; this.chara.map(function (chara) &#123; console.log(`$&#123;this.name&#125;$&#123;chara&#125;`); &#125;) &#125; &#125; obj.foo(); //结果是 csz3fcyq 此时的this指向了 Window ,很显然这不是我们想要的。&#125; 在使用了箭头函数以后 this 的指向就会变成静态的，即在创建函数时 this 指向谁那么调用时this 也指向谁 12345678910111213var name = &apos;csz3&apos;;&#123; const obj = &#123; name: &apos;csz&apos;, chara: [&apos;fcyq&apos;], foo() &#123; this.chara.map(chara =&gt; &#123; console.log(`$&#123;this.name&#125;$&#123;chara&#125;`); &#125;) &#125; &#125; obj.foo(); //结果是 cszfcyq 这样就解决了上面出现的问题&#125; 所以合理的使用箭头函数可以使开发更加的简便 由于使用了箭头函数之后this的指向是静态的，所以在有些情况下也是不适合使用箭头函数的例如在创建构造函数时，在对象中创建方法时，各种事件的回调等等，这些情况都不适合用回调函数，否则会出现很多意想不到的错误。 解构赋值使用结构赋值可以很轻松的给数组或者是赋值。 数组解构 基本： 12345&#123; const arr = [1, 2, 3, 4, 5, 6]; const [a, b, c] = arr; console.log(a, b, c);//结果1 2 3&#125; 可以使用默认值： 12345&#123; const arr = [1, 2]; const [a, b, c = 30] = arr; console.log(a, b, c);//结果1 2 30&#125; 但结果为 undefined 就会使用默认值。 可以使用剩余运算符12345&#123; const arr = [1, 2, 3, 4, 5, 6]; const [a, b, ...c] = arr; console.log(a, b, c);//结果1 2 (4) [3, 4, 5, 6]&#125; 默认运算符的结果将保存为数组。 对象解构对象结构与数组解构类似，但是也有区别： 基本： 123456789&#123; const obj = &#123; a: 10, b: 20, c: 30 &#125;; const &#123; a, b, c &#125; = obj; console.log(a, b, c);//10 20 30&#125; 重命名由于有时变量名并不一定和对象中的属性名相同，所以可以重命名 123456789&#123; const obj = &#123; a: 10, b: 20, c: 30 &#125;; const &#123; a: A, b: B, c: C &#125; = obj; console.log(A, B, C);//10 20 30&#125; 大部分都与数组解构类似所以不做演示了。 剩余运算符 使用剩余运算符可以一次性的拿到所有的剩余的参数或者是对象、数组中的元素 可以在解构赋值时使用参考本篇博客解构赋值。 可以用获取函数参数： 123456&#123; function foo(...arg) &#123; console.log(arg); &#125; foo(1, 2, 3, 4, 5, 6);//结果(6) [1, 2, 3, 4, 5, 6]&#125; 我们可以看出在获取参数方面和 arguments 有一些相似，都不关心传了多少个参数，想用某个参数直接从数组中调用就可以了但是他们之间还是有很明显的区别的： - 剩余运算符需要进行设置，需要传递一个剩余运算符名称，通过这个名称来获取参数。而``arguments``不用设置，直接使用arguments来调用参数就可以了。 - 剩余运算符是一个真正的数组，可以调用数组的方法。而``arguments``是一个伪数组，不能调用数组的相关方法。 模板字符串 ES6新增了一种字符串的包裹方式，使用`反引号进行包裹。这就是模板字符串。 模板字符串中可以使用变量。通过使用${}包裹变量就可以变量在能够在模板字符串解析,${}内可以是变量也可以是任意表达式。 123456&#123; const a = 10; const b = 20; const str = `a+b=$&#123;a + b&#125;`; console.log(str);//结果a+b=30&#125; 可以看出使用模板是十分的方便，再也不用麻烦的拼接以及检查。 模板字符串顾名思义可以用来定义模板： 1234567891011&#123; const template = ` &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;h1&gt;这是标题&lt;/h1&gt; &lt;p&gt;&lt;span&gt;😊&lt;/span&gt; 这是一段文字描述&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;`; console.log(template); document.querySelector(&apos;body&apos;).innerHTML = template;&#125; 如果在ES5中我们要书写一个模板并且要保持一定的格式是非常麻烦的一件事情，因为涉及到众多双引号有时候还会有单引号，如今在ES6中我们直接使用模板字符串就可以很轻松的定义一个可读性非常强的模板。十分的方便。 扩展运算符扩展运算符 的作用与剩余运算符的作用相反， 剩余运算符 是可以将剩余部分合并成为一个数组，而 扩展运算符 则是可以将可遍历对象进行拆分。 使用非常简单，在需要拆分的可遍历对象前面加...即可： 12345678&#123; const str = &apos;asdfghjkl&apos;; const obj = &#123; a: 10, b: 20, c: 30 &#125;; const arr = [1, 2, 3, 4, 5, 6]; console.log(...str); //a s d f g h j k l console.log(&#123; ...obj &#125;); //&#123;a: 10, b: 20, c: 30&#125; console.log([...arr]); //6) [1, 2, 3, 4, 5, 6]&#125; 用来拼接 12345&#123; const arr = [1, 2, 3, 4, 5, 6]; const arr2 = [...arr, ...arr]; console.log([...arr2]); //(12) [1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6]&#125; 通过扩展运算符就可以十分轻松的对可遍历对象进行拼接或者是对数组或者是对象的深拷贝。 作为参数传递给函数1234567&#123; function sum(...num) &#123; return num.reduce((pre, cur) =&gt; pre + cur); &#125; const nums = [1, 2, 3, 4, 5, 6]; console.log(sum(...nums));&#125; 就像这个求和函数一样，我们要给数组求和，不用关心数组里面有多少元素，直接将数组扩展为函数的参数就可以进行求和了，十分的简单便捷。 新的迭代器js中原来存在的这几种迭代方式都存在一些不方便的地方： for 循环在很多场景下不够简便，并且代码可读性较差 forEach 循环不能够使用 break和continue for in 循环遍历的是遍历对象上的所有可枚举属性，甚至包括原型属性： 12345678&#123; Array.prototype.test2 = &apos;456&apos;; const arr = [1, 2, 3, 4, 5, 6, 7]; arr.test = &apos;123&apos;; for (index in arr) &#123; console.log(arr[index]); &#125;&#125; 可以看出使用for in 循环不仅会把属性遍历出来，连数组原型上的属性都会遍历出来。 所以 for of 循环就产生了： 基本：123456&#123; const arr = [1, 2, 3, 4, 5, 6]; for (num of arr) &#123; console.log(num); //1 2 3 4 5 6 &#125;&#125; for of 循环可以很轻松的遍历数组中的元素。 通过entries()方法同时遍历索引和值： 123456&#123; const arr = [1, 2, 3, 4, 5, 6, 7]; for ([index, item] of arr.entries()) &#123; console.log(`index:$&#123;index&#125;,item:$&#123;item&#125;`); &#125;&#125; 可以使用 break 和 continue 123456789&#123; const arr = [1, 2, 3, 4, 5, 6, 7]; for (num of arr) &#123; console.log(num); if (num == 3) &#123; break; &#125; &#125;&#125; 结果： 1 2 3 通过以上可以看出在原生js中，迭代器中for of 循环是最强大的。 总结ES6为我们提供了一系列的新的功能，可以看出这些功能十分的强大，加以利用可以很大程度的提高我们的开发效率。]]></content>
  </entry>
  <entry>
    <title><![CDATA[理解js单线程异步与事件循环机制]]></title>
    <url>%2F2019%2F07%2F06%2F%E5%85%B3%E4%BA%8Ejs%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%BC%82%E6%AD%A5%E4%B8%8E%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%E7%9A%84%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这几天在学习过程中遇到一些问题，在找相关资料的情况下了解到js单线程和事件循环机制的一些知识，通过看一些大牛的文章，感觉又学习到了很多，对js有了更深的理解，这里来记录一下我学习完之后的一些理解。 js单线程我们都知道js实际上是单线程的，但是很多时候很多操作其实是异步的，那么这是怎么实现的呢，js单线程该如何实现异步。其实虽然js是单线程的，但是浏览器并不是单线程的，浏览器是多线程的。 那么浏览器内核一般都有哪些常驻现成： GUI渲染线程 负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行 注意，GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。 JS引擎线程 也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎） JS引擎线程负责解析Javascript脚本，运行代码。 JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序 同样注意，GUI渲染线程与JS引擎线程是互斥的，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。 事件触发线程 归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助） 当JS引擎执行代码块时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理 注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行） 定时触发器线程 传说中的setInterval与setTimeout所在线程 浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确） 因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行） 注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。 异步http请求线程 在XMLHttpRequest在连接后是通过浏览器新开一个线程请求 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。 再补充一张图：（本文图片来源及上述描述均转自这位大牛） 通过以上可以看出虽然js本身是单线程的，但是浏览器内核中却有这么多的线程协助，那么自然可以实现异步。 事件循环机制既然前面说到js是存在异步任务的，并且浏览器内核中存在这么多的线程，那么js的事件循环机制究竟是怎么样的呢。 js中存在同步任务以及异步任务 同步任务在主线程中执行，形成一个任务栈 （进行最终处理的只有任务栈） 浏览器内核中存在的事件触发线程，这个线程控制一个 任务队列，当这些异步任务（比如像点击事件之类的）产生了结果（那些回调函数之类的），事件触发线程就会将这些结果放到 任务队列当中 那么执行栈与任务队列之间有什么关系呢： 所有的处理最终都是在任务栈中进行的，这是js的主线程。 所有的异步结果也就是任务队列中的任务最终也是要交给任务栈进行处理的。 当主线程空闲的时候就会主动去读取任务队列，并且执行任务队列中的可执行的任务。如此循环 这张图片很形象： 大概理解可以是在主线程中的执行栈的运行过程中会根据页面中的内容会调用到一些异步任务，那么这些异步任务产生的结果就会有事件触发线程之类的线程提交到任务队列，然后当执行栈空闲的时候就会执行这些任务，这样形成一个循环，这就是我理解的事件循环机制。 定时器这里单独说一下定时器，其实我之所以会找这方面的资料也是因为我在使用定时器的时候遇到一些问题没有想明白，那么定时器其实是很特别的，因为定时器有一个独享的线程，就是定时器线程，之所以会有定时器线程是因为定时器需要一个定时的功能，很显然主线程如此的繁忙，交给主线程来定时是不够准确的，那么就由浏览器的一个单独的线程来定时，当达到定时器设定的时间时，定时器线程就会将要处理的特定的结果（也就是定时器的回调）推入到任务队列当中等待主线程执行。 在W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。这里可以看一个例子：123456setTimeout(function () &#123; console.log('这是定时器的内容');&#125;, 10)console.log('这是一句话');console.log('这是另一句话');console.log('这是又是一句话'); 这段代码的执行结果会是什么？1234//这是一句话//这是另一句话//这是又是一句话//这是定时器的内容 这就是这段代码的执行结果，如果在我了解事件循环机制之前我可能会认为因为定时器时10ms之后触发，所以会在最后。 但是这里有一个问题，如果定时器后面的代码量非常多呢，执行的时间很长会怎么样，定时器中的内容还会是最后输出的吗。 但是现在通过事件循环机制我知道，无论后面的代码执行需要再长的时间，定时器的时间再短，也都是定时器最后执行，就是因为事件循环机制，因为只有当主线程空闲的时候才会去执行任务队列中的内容。 关于定时器的使用差别这里有一个问题，是直接使用setInterval还是利用setTimeout模拟，先来说说这二者之间的区别： 在使用setTimeout模拟时，第二次以及之后再次开启的定时器是需要在上一次的setTimeout中的回调执行完毕之后才会再次开启，所以这之间是存在误差的，那么有多少的误差就取决于回调执行的时间。 如果是直接使用setInterval则不会有setTimeout那样的情况，setInterval的定时器开启是非常准时的，不需要等待回调执行完毕就会准时的再次开启，那么这样会产生一些问题，如果上一次的回调还没有执行完下一次就来了怎么办，或者是即使上一次的执行完了，但是用了较多的时间，中间的时间间隔就会变得非常短，导致代码连续运行。 当浏览器最小化的时候setInterval是不执行的，当窗口恢复的时候就会一次性全部执行。 所以最好的解决办法是用setTimeout模拟setInterval或者用requestAnimationFrame。 补充：JS高程中有提到，JS引擎会对setInterval进行优化，如果当前事件队列中有setInterval的回调，不会重复添加。不过，仍然是有很多问题 总结通过看大牛的文章受益颇多，大牛文章的内容我没有全部仔细看完，只琢磨了我现在暂时想知道的东西，等有时间把大牛文章中的东西全部弄明白。 参考撒网要见鱼：从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于for循环中使用setTimeout]]></title>
    <url>%2F2019%2F07%2F05%2F%E5%85%B3%E4%BA%8Efor%E5%BE%AA%E7%8E%AF%E4%B8%AD%E4%BD%BF%E7%94%A8setTimeout%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;今天本来打算学习es6,结果刚开始就遇到一个问题，关于for循环中使用 var 和 使用 let 所带来的差别，我为了详细弄懂其中的原理，就查资料，查到了很多关于这方面的知识，这次就来记录一下。 在for循环中使用setTimeout的问题有时候我们会有这样的需求，就是在for循环中使用到setTimeout，但是不一定能够得到我们想要的结果，看这个例子： 12345for (var i = 0; i &lt; 10; i++) &#123; setTimeout(function () &#123; console.log(i); &#125;, 1000)&#125; 结果是10次10. 其实在这种情况下我想要的情况应该是输出从0-9，而不是十次10。 那么为什么会这样呢，我是这样理解的： 首先 setTimeout 是异步执行的并且先要到任务队列中才会到执行栈中，所以 setTimeout 的回调一定是最后执行的。 在执行回调的时候会先在函数的局部作用域中去找 i 但是很显然是找不到的，然后会去全局作用域中找 i，这时就能找到，但是此时的i已经是10了，所以会输出10次10。 解决这个问题的多种方式使用 let在es6中可以使用let来声明块级变量，并且只在块级作用域中有效。来看看是如何解决这个问题的： 12345for (let i = 0; i &lt; 10; i++) &#123; setTimeout(function () &#123; console.log(i); &#125;, 1000)&#125; 控制台打印结果0-9 可以看出其实使用let很轻松的就将问题解决了，那么这是如何解决的呢？我是这样理解的： 首先 setTimeout 是异步执行的并且先要到任务队列中才会到执行栈中，所以 setTimeout 的回调一定是最后执行的。这些都是不变的。 但是区别在于由于使用了let来声明变量，所以在会在块级作用域中去找i，并且因为在每一次循环时都创建了一个不同的块级作用域（变量i不同），所以能够找到，并且按照顺序将i的值输出出来。 使用闭包通过闭包也可以解决问题： 1234567for (var i = 0; i &lt; 10; i++) &#123; (function (i) &#123; setTimeout(function () &#123; console.log(i); &#125;, 1000) &#125;)(i);&#125; 控制台打印结果0-9 那么闭包是如何解决的呢？这是我的理解： 首先 setTimeout 是异步执行的并且先要到任务队列中才会到执行栈中，所以 setTimeout 的回调一定是最后执行的。这些都是不变的。 +在执行匿名函数的时候形成了闭包，会保持对i的引用，就导致在每次循环的过程中匿名函数的作用域中都会有当前i的值，所以当后面执行回调函数的时候就能够在匿名函数的作用域中找到对应的i的值。 总结这两天一直在看这方面的文章，感觉弄懂了很多这些方面的知识，继续加油。]]></content>
      <tags>
        <tag>JS</tag>
        <tag>ES6</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对于闭包函数的简单理解]]></title>
    <url>%2F2019%2F07%2F05%2F%E5%AF%B9%E4%BA%8E%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0%E7%9A%84%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;闭包是ECMAScript （JavaScript）最强大的特性之一，但用好闭包的前提是必须理解闭包。第一次接触闭包这个概念肯定不好理解，这篇文章来简单介绍理解一下什么是闭包。 什么是闭包 什么是闭包，通过我的理解就是由于js的机制，外部函数无法使用内部函数的变量，但是内部函数可以使用外部函数的变量，当这样一个使用了外部函数的变量的内部函数在包含他的外部函数之外被调用了，那么就形成了闭包。 可以看出要形成闭包至少要这几个条件： 至少两个函数，一个外部部函数，一个嵌套在外部函数里面的内部函数 内部函数中使用了外部函数中的变量 在外部函数以外的地方调用了内部函数 一个简单的闭包函数 1234567891011121314151617function a() &#123; //外部函数中有一个变量 count = 1; //将内部函数返回出去 return function () &#123; //内部函数中使用了外部函数中的变量 count++; console.log(count); &#125;&#125;;//此时b指向的就是内部函数var b = a();//在全局中调用了b所指向的内部函数，所以变量 count 就会一直保存在全局AO中b(); //2//当再次调用的时候就会继续使用全局中没有被回收的变量 count b(); //3b(); //4 闭包的用途可以通过上面的一个简单的闭包函数可以看到，当执行完函数之后，count的值并没有被释放，可以长久的保存并且不会污染全局变量。 闭包的高级用法闭包通常可以配合匿名函数使用： 配合匿名立即执行函数使用就可以很轻松的将一个函数转化为闭包。 123456789101112131415var b; (function () &#123; count = 1; var obj = &#123; a() &#123; count++ console.log(count); &#125; &#125; b = obj; &#125;)(); b.a(); //2 b.a(); //3 b.a(); //4 将最开始的例子改写以下，这样也是一个闭包，虽然没有返回值，但是最终还是通过对象来调用了内部的函数从而使用了外部函数的变量，实际上还是一个闭包。 还有一个闭包的例子参考我的另一篇博客关于for循环中使用setTimeout 如何创建一个闭包 定义外层函数，封装被保护的局部变量。 定义内层函数，执行对外部函数变量的操作。 外层函数返回内层函数的对象，并且外层函数被调用，结果保存在一个全局的变量中。（实际上不一定要返回内部函数，返回内部函数只是使内部函数在全局中被使用的一种方式） 总结通过这次的学习对闭包有了一定的了解，由于闭包不会释放外部函数变量，所以会一直消耗内存，所以闭包的使用有利有弊，合理的使用对开发有帮助的，需要在项目中多多使用，渐渐深入理解。 参考让你分分钟理解 JavaScript 闭包]]></content>
      <tags>
        <tag>JS</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-js的学习（watch、computed的使用）]]></title>
    <url>%2F2019%2F07%2F04%2Fvue-js%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%88watch%E3%80%81computed%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这次来学习以下vue中的两个选项，watch和computed 这两个是用来监听数据的变化的，但是又有区别。以前我监听数据的变化都是通过原生js的 oninput或者是 keyup 事件来判断数据是否发生变化，但是很显然在vue中这样是不够哦高效的，那么在vue中正确使用 watch 和 computed 可以大大的提高我们的开发效率。 watch的使用watch是vue实例中的一个选项，是一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。Vue 实例将会在实例化时调用 $watch()，遍历 watch 对象的每一个属性。 可以像这样使用： 监听文本框数据 123456789101112131415161718192021222324252627282930313233343536373839&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;a&quot;&gt;+ &lt;input type=&quot;text&quot; v-model=&quot;b&quot;&gt;= &lt;input type=&quot;text&quot; v-model=&quot;c&quot;&gt; &lt;/div&gt; &lt;script src=&quot;./../../js/vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue(&#123; el: &quot;#app&quot;, data() &#123; return &#123; a: &apos;&apos;, b: &apos;&apos;, c: &apos;&apos;, &#125; &#125;, methods: &#123; watchAB() &#123; this.c = this.a + &apos;-&apos; + this.b; &#125; &#125;, watch: &#123; // 可以直接写函数，直接写函数的话可以有两个参数，一个是改变之前的值，一个是改变之后的值 // a: function (newVal, oldVal) &#123; // this.c = newVal + &apos;-&apos; + this.b // &#125;, // b: function (newVal, oldVal) &#123; // this.c = this.a + &apos;-&apos; + newVal // &#125;, // 也可以直接调用已经有的方法，但是不能向上面一样有两个参数 a: &quot;watchAB&quot;, b: &quot;watchAB&quot;, &#125;, &#125;) &lt;/script&gt;&lt;/body&gt; 监听路径变化 watch不仅仅能够监听文本框的数据变化，它能够监听到vue中一切数据的变化，十分的强大 例如监听路径的变化：1234567//这里可以不用加this&quot;$route.fullPath&quot;: function (newVal, oldVal) &#123; //这里用path或者是fullPath来判断都可以，但是要注意大小写 if (newVal == &quot;/test&quot;) &#123; alert(&apos;跳转到了test组件&apos;) &#125;&#125; 注意，不应该使用箭头函数来定义 watcher 函数,理由是箭头函数绑定了父级作用域的上下文，所以 this 将不会按照期望指向 Vue 实例 computed的使用同样一个例子我们也可以使用 computed 来完成，我们也可以看出他们之间的区别。 123456789101112131415161718192021222324252627282930313233&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;a&quot;&gt;+ &lt;input type=&quot;text&quot; v-model=&quot;b&quot;&gt;= &lt;input type=&quot;text&quot; v-model=&quot;c&quot;&gt; &lt;/div&gt; &lt;script src=&quot;./../../js/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./../../js/vue-router.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue(&#123; el: &quot;#app&quot;, data() &#123; return &#123; a: &apos;&apos;, b: &apos;&apos;, //这里不再需要对c进行定义 &#125; &#125;, methods: &#123; &#125;, computed: &#123; // 如果在computed中要对某个数据进行监听计算，那么这个数据需要放到computed中来进行定义 c: function () &#123; // 然后还需要将我们需要的结果返回出去 return this.a + &quot;-&quot; + this.b &#125; //并且这个结果还会被缓存，但我们再次调用这个结果的时候并不会再次重新计算，而是单纯的重新调用，除非结果发生了变化。 &#125;, &#125;) &lt;/script&gt;&lt;/body&gt; 总结在vue中虽然也可以使用事件来监听数据的改变，但是在大部分情况下使用vue中的 watch 和 computed 会更加的适合vue并且有更高的效率。在合适的场景正确的使用这两个选项可以很大程度上的提高我们的开发效率，要合理使用。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>VUE学习笔记</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-js的学习（路由的学习与使用）]]></title>
    <url>%2F2019%2F07%2F02%2Fvue-js%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%88%E8%B7%AF%E7%94%B1%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这次来学习vue中的路由，那么什么是前端路由，前端路由就是在单页面中通过url地址的hash来进行单页面的跳转的，而且并不会重新请求页面，这就是前端路由，一般都是通过 # 来实现的。这次来具体学习以下vue-router这个库来实现vue中的路由功能。 如何使用vue-router首先是要引入vue-router包那么，其实引入的方式有很多种，可以直接下载到本地引入，也可以使用npm之类的，具体可以看官方网站的介绍介绍。 创建一个组件构造器这里要注意的是这里创建的不是一个组件，而是一个构造器，虽然路由是在不同的组件之间进行切换，但是这里先是创建构造器，也就是通过Vue.extend来创建构造器，最后通过路由router将构造器注册成为组件。就像下面这样： 123var login=Vue.extend(&#123; template: &apos;&lt;h1&gt;登录组件&lt;/h1&gt;&apos; &#125;); 可以看出这就是我们在学习前面的创建组件的时候的创建构造器的方式，所以这个也可以简写：123var register=&#123; template: &apos;&lt;h1&gt;注册组件&lt;/h1&gt;&apos; &#125;; 直接用一个对象来表示构造器。而构造其中的模板就是我们之后路由组件中的内容。 通过VueRouter来创建路由实例及定义路由规则123456789101112const router = new VueRouter(&#123; //创建一个路由对象 routes: [&#123; //routes的意思就是道路的意思，这个数组里面就放我们所要定义的路由规则 //这个数组里面用对象来表示每个路由规则，两个对象就是两条路由规则 path: '/login', //对象里面的path表示路由的地址 component: login //component表示对应的路由组件 &#125;, &#123; path: '/register', component: register &#125; ],&#125;) 这里要注意的是这里的routes是一个数组，写的时候不要写错了。 挂在到vue实例中在实例中挂载过来路由规则才会生效 1234var vm = new Vue(&#123; el: &apos;#app&apos;, router: router // 使用 router 属性来使用路由规则,可以直接简写成一个router，因为键和值都是一样的。 &#125;); 使用 router-link 来对路由组件进行导航其实可以通过HTML本身自带的 a 标签来设置url地址来设置hash来实现导航跳转的目的，但是在vue-router中也提供了进行导航的方式，并且更加的实用。就是使用 router-link ： 1234&lt;div id=&quot;app&quot;&gt; &lt;router-link to=&quot;/login&quot;&gt;登录&lt;/router-link&gt; &lt;router-link to=&quot;/register&quot;&gt;注册&lt;/router-link&gt;&lt;/div&gt; router-link标签默认在页面上是渲染成 a 标签的，同样，这个也可以通过 tag 属性来进行修改。 使用 router-view 将路由组件挂载到页面中前面都只是创建路由组件，但是创建好了没有放到页面里面去也相当于没有什么用，这里就需要通过 router-view 标签将前面定义过的路由组件放到页面中去。 12&lt;!-- 默认一个 router-view 只会显示一条平级的路由规则 --&gt;&lt;router-view&gt;&lt;/router-view&gt; 要注意的一件事情是一个 router-view 默认只显示当前url地址匹配到的路由组件的内容，如果没有匹配到那么就不会显示出来，比如前面都没有设置根路径的路由那么页面初始的状态下是什么都不会显示的，只有在路由切换到相应的地址的时候才会有显示。 设置路由重定向在很多时候我们需要将一个路由地址可以对应多种路径，比如让上面的页面在根路径下默认显示 login 那么这个时候就需要使用路由重定向来将根路径重定向到 login12345&#123; path: &apos;/&apos;, //这里要注意的是这里redirect后面跟的是重定向的路径 redirect: &apos;/login&apos; &#125; 我们只需要给我们需要重定向的路径添加一条路由规则并且给它重定向到我们想要的路径就可以了。 设置路由链接激活样式有时候我们需要给当前所在位置的 router-link 设置高亮，那么这个时候我们就可以通过给 router-link-active这个类设置样式来实现我们想要的效果，因为我们每次切换路由vue每次都会自动的将这个类放到当前所在的 router-link 上，所以只需要修改这个类的样式就可以了。 1234567&lt;style&gt; .router-link-active &#123; color: red; font-size: 20px; background-color: aqua; &#125;&lt;/style&gt; 可以看出这个样式成功应用上去了。 当然，这个类的名称是可以自定义修改的，我们只需要在创建路由对象的时候设置 linkActiveClass就可以来全局配置这个链接激活状态的类名。就像这样： 123456789101112131415161718const router = new VueRouter(&#123; // 这里设置链接激活的类 linkActiveClass: 'myclass', //设置过后就需要通过修改我们自定义的类来设置链接激活样式了 // 这里设置路由规则 routes: [&#123; path: '/', redirect: '/login' &#125;, &#123; path: '/login', component: login &#125;, &#123; path: '/register', component: register &#125; ],&#125;) 设置路由组件切换动时画效果设置路由组件间的动画切换效果也很简单，只需要将 router-view标签 放进动画的 transition标签里面并且设置动画的两组类（或者直接用第三方的库）就可以了。 123456789101112131415161718&lt;style&gt; .myclass &#123; color: red; font-size: 20px; background-color: aqua; &#125; .v-enter, .v-leave-to &#123; opacity: 0; transform: translateX(150px); &#125; .v-enter-active, .v-leave-active &#123; transition: all 1s ease; &#125;&lt;/style&gt; 123&lt;transition mode="out-in"&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/transition&gt; 通过这样的设置就可以使组件在切换的时候拥有动画效果了。 路由嵌套假如如有组件中还嵌套有路由,那么要实现一层一层的显示路由就要用到路由嵌套，在需要嵌套的路由规则中通过 children 来实现路由嵌套。 首先是在一个路由构造器中嵌套有子路由 123456789101112131415&lt;div id="app"&gt; &lt;router-link to="/login"&gt;登录&lt;/router-link&gt; &lt;router-link to="/register"&gt;注册&lt;/router-link&gt; &lt;transition mode="out-in"&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/transition&gt;&lt;/div&gt;&lt;template id="test"&gt; &lt;div&gt; &lt;h1&gt;这是登录组件&lt;/h1&gt; &lt;router-link to="/login/son"&gt;点这里切换到子组件&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt; 然后是定义了子路由,并且将其嵌套在父级的路由规则中 123456789101112131415161718192021222324252627var son = &#123; template: "&lt;h1&gt;这是嵌套在里面的子组件&lt;/h1&gt;"&#125;const router = new VueRouter(&#123; linkActiveClass: 'myclass', routes: [&#123; path: '/', redirect: '/login' //这里要注意的是这里redirect后面跟的是重定向的路径 &#125;, &#123; path: '/login', component: login, // children是父组件规则中的一个属性的值，并且这是一个数组，这个数组里面放的就是子路由的路径规则，相当于是在一条路由规则里面来定义新的路由规则 children: [ // 这里一样可以写很多条的子路由规则 &#123; path: 'son', //这里使用的相对路径 component: son &#125; ], &#125;, &#123; path: '/register', component: register &#125; ],&#125;) 这里要注意的一点是子路由中的路由规则中的路径使用的是相对路径，并且是相对于父级路由的相对路径，如果使用的是从根路径开始的绝对路径，那么就只会显示子路由中的内容，就不会显示父级路由中的内容。 这里也可以看到效果，当我们切换到子路由，显示了从父级路由开始的路由组件： 路由参数的传递及获取的两种方式我们经常会有需求在url地址中传递参数，那么在vue中拿到参数以及获取参数的方式有两种： 第一种，通过query传递参数的方式像是在学php时用get方式传递数据时使用的方法： 1&lt;router-link to="/login?id=1&amp;name=csz"&gt;登录&lt;/router-link&gt; 获取参数的方法： 首先我们要知道在我们创建的vue实例中有一个$route属性，这个属性中就包含了我们的路由信息，通过展开这个属性，我们可以发现有一个 query 属性，而这个属性是一个对象，包含了我们通过查询字符串所传递的参数，我们就可以通过调用这个对象来拿到我们的参数。 通过这种方式我们可以很轻松的拿到我们想要的参数并且使用它 1&lt;h1&gt;这是登录组件---&#123;&#123;this.$route.query.id&#125;&#125;&lt;/h1&gt; 那么此时当我们切换到登录组件的时候就还会额外显示我们传递的id参数了。 第二种，通过params这种方式与query有很明显的区别： 首先是传递参数的方式有所区别 1&lt;router-link to=&quot;/register/2/csz2&quot;&gt;注册&lt;/router-link&gt; 可以看出这里在url地址上只设置了参数的值，并没有对参数设置名称。 参数的名称还需要在设置路由路径的时候进行设置：1234&#123; path: &apos;/register/:id/:name&apos;, component: register&#125; 通过这种方式也能实现一样的效果，并且拿到参数： 1&lt;h1&gt;这是注册组件---&#123;&#123;this.$route.params.id&#125;&#125;&lt;/h1&gt; 也可以成功拿到我们想要的值。 命名视图在有些场景我们希望同时展示多个视图，也就是多个 &lt;router-view&gt;&lt;/router-view&gt; ，但是默认情况下我们在页面中使用多个 的话也不会显示多个视图，那么这个时候我们就需要通过对视图来进行命名来显示我们想要的视图了。 首先是对视图进行命名1234567&lt;div id="app"&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;div class="wrap"&gt; &lt;router-view name="left"&gt;&lt;/router-view&gt; &lt;router-view name="right"&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/div&gt; 只要对视图进行了命名就可以指定这个视图显示什么路由组件了。 创建构造器以及创建路由实例1234567891011121314151617181920var top1 = &#123; //这里还有一个大问题，一个bug，就是组件构造器的名字不能够使用 top 否则直接会找不到这个构造器从而报错 template: &apos;&lt;h3 class=&quot;top1&quot;&gt;这是上边部分&lt;/h3&gt;&apos;&#125;var left = &#123; template: &apos;&lt;h3 class=&quot;left&quot;&gt;这是左边部分&lt;/h3&gt;&apos;&#125;var right = &#123; template: &apos;&lt;h3 class=&quot;right&quot;&gt;这是右边部分&lt;/h3&gt;&apos;&#125;const router = new VueRouter(&#123; routes: [&#123; path: &apos;/&apos;, components: &#123; //这里使用的是components而不是component default: top1, //没有设置name的默认就是用default right, left, &#125; &#125;]&#125;) 需要在同一级路径显示多个路由组件就需要在配置这条路径的路由规则的时候使用 components 来配置显示的路由组件，这里面是一个对象，是 视图 name:构造器名字 的这种形式，对于没有命名的视图则使用 default 来进行配置。 这里要注意的是这里因为配置的是多个路由组件，所以使用的是 components 而不是前面只显示单个组件时的 component。 这里我发现一个vue中的bug，起初我在定义三个路由组件的构造器的时候使用了 top left right 这三个名字，最后在页面中查看，只显示了后面两个组件，然后控制台报了一个错误，说有一个组件没有定义，然后我猜想是不是定义top的时候哪里写错了，后面发现并不是，后面我只能猜测难道是因为名字的问题？然后我改了一个名字，果真是名字的问题。这里值得注意以下。 总结这是是对vue router学习的一些笔记，有一些问题需要注意 两种方式都可以传递参数并且获取到参数，但是二者有明显的区别，要注意区分，使用哪种方式看个人习惯就好了，我比较习惯于使用query来传递和获取参数。 在命名视图的时候有一个bug，要多注意，以后对组件命名尽量不要使用 top 这个名字来命名。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>VUE学习笔记</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-js的学习（ref的学习）]]></title>
    <url>%2F2019%2F07%2F02%2Fvue-js%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%88ref%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在vue中是不提倡操作dom元素的,但是很多时候还是需要去操作dom元素的,那么这个时候该如何去获取dom元素,并且对他进行操作呢,如果直接通过原生js的各种选择器来操作的话其实也行,用jQuery也可以,但是在vue中都不提倡这样操作,其实我们就可以通过vue中的ref来获取以及操作dom元素. 来看一个简单的例子12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;body&gt; &lt;div id="app"&gt; &lt;div class="test"&gt; &lt;!-- ref就像是一个id一样可以设置在元素身上，也可以设置在组件的引用标签上 --&gt; &lt;!-- 设置在dom元素上那么在vue中拿到的就是dom元素原生对象 --&gt; &lt;h1 ref="test"&gt;这是vue实例中的一句话&lt;/h1&gt; &lt;button @click="myalert"&gt;点击我&lt;/button&gt; &lt;button @click="myalert2"&gt;点击我2&lt;/button&gt; &lt;!-- 如果设置在组件的引用标签上拿到的就是一个vue实例的对象 --&gt; &lt;test ref="test2"&gt;&lt;/test&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src="./../../js/vue.js"&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue(&#123; el: "#app", data() &#123; return &#123; &#125; &#125;, methods: &#123; // 可以成功对一个原生的dom对象进行了操作,输出了它里面的文本 myalert() &#123; alert(this.$refs.test.innerText); &#125;, // 成功的对一个vue实例对象进行了操作，输出了它里面的属性 myalert2() &#123; alert(this.$refs.test2.mgs); &#125; &#125;, components: &#123; test: &#123; template: "&lt;h1&gt;这是一个子组件&lt;/h1&gt;", data() &#123; return &#123; mgs: '这是子组件中的一句话', &#125; &#125;, &#125; &#125;, &#125;) &lt;/script&gt;&lt;/body&gt; 通过以上例子我们就可以看出: 通过在标签上设置ref来注册$refs对象 注册在组件引用标签上与注册在dom元素上是有差别的,如果是注册在组件上那么拿到的就是一个组件实例,如果注册在dom元素上拿到的就是一个原生的dom对象. 可以通过给子组件注册ref来获取到子组件中的属性以及方法并进行操作. 通过在控制台中的查看我们也可以看出$refs是一个对象,里面保存了注册了ref的dom对象或者组件实例. 注意是通过this.$refs来使用,s不能漏了,因为里面可以保存许多的内容. 总结ref的使用比较简单,但是感觉作用很强大,以后开发要灵活运用.]]></content>
      <categories>
        <category>学习笔记</category>
        <category>VUE学习笔记</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue.js的学习（向子组件传递属性以及方法）]]></title>
    <url>%2F2019%2F07%2F01%2Fvue-js%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%90%91%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BC%A0%E9%80%92%E5%B1%9E%E6%80%A7%E4%BB%A5%E5%8F%8A%E6%96%B9%E6%B3%95%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前面学习了创建组件的几种方式，那么这次来学习以下父组件如何向子组件传递属性以及方法，，因为父组件只能使用父组件中的值和方法，子组件也是一样，那么有时子组件就需要用到父组件的方法该如何做呢，我发现虽然父组件无法获取到子组件内部的东西，但是子组件和父组件其实是有交叉的地方的，也就是在页面中引用子组件的那个标签，那么vue中就是通过这个标签作为中间桥梁来给子组件传递属性的，那么来试一试。 向子组件传递属性向子组件传递属性值主要给组件的引用标签绑定一个中间值来实现，下面是一个例子：12345678910111213141516171819202122232425262728293031&lt;body&gt; &lt;div id="app"&gt; &lt;!-- 创建好一个子组件 --&gt; &lt;!-- 我们可以通过test这个桥梁来传递父组件的属性，这个属性只需要绑定在这个标签上面就好了 --&gt; &lt;test :pmsg='msg'&gt;&lt;/test&gt; &lt;/div&gt; &lt;template id="test"&gt; &lt;div&gt; &lt;h2&gt;我是子组件---&#123;&#123;pmsg&#125;&#125;&lt;/h2&gt; &lt;/div&gt; &lt;/template&gt; &lt;script src="./../../js/vue.js"&gt;&lt;/script&gt; &lt;script&gt; Vue.component('test', &#123; template: '#test', data() &#123; return &#123;&#125; &#125;, // 然后通过props来拿到绑定的属性 props: ['pmsg'], //注意props是一个只读不可写的数组 &#125;) var vm = new Vue(&#123; el: "#app", data() &#123; return &#123; msg: '这是父组件中的一句话', &#125; &#125;, &#125;) &lt;/script&gt;&lt;/body&gt; 要注意的一件事情是props是一个只读不可写的数组 可以看出子组件成功拿到了父组件的变量并且将其渲染到页面中。 子组件触发父组件的方法子组件既然可以获取到父组件的属性，那么也可以触发到父组件的方法，触发的方式与获取父组件的属性的方式类似。下面看演示：12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;body&gt; &lt;div id="app"&gt; &lt;!-- 创建好一个子组件 --&gt; &lt;!-- 我们可以通过test这个桥梁来传递父组件的方法，这个属性只方法绑定在这个标签上面就好了 --&gt; &lt;test @sonalert="myalert"&gt;&lt;/test&gt; &lt;/div&gt; &lt;template id="test"&gt; &lt;div&gt; &lt;h2&gt;&lt;button @click="myclick"&gt;单击我&lt;/button&gt;&lt;/h2&gt; &lt;/div&gt; &lt;/template&gt; &lt;script src="./../../js/vue.js"&gt;&lt;/script&gt; &lt;script&gt; Vue.component('test', &#123; template: '#test', data() &#123; return &#123; msg: '这是子组件中的一句话', &#125; &#125;, methods: &#123; myclick() &#123; // emit英文的意思就是触发的意思，这里就可以通过emit来触发前面绑定过的方法，并且后面的参数是作为要触发的方法的参数 this.$emit('sonalert', this.msg) &#125; &#125;, &#125;) var vm = new Vue(&#123; el: "#app", data() &#123; return &#123; msg: '这是父组件中的一句话', &#125; &#125;, methods: &#123; myalert(str) &#123; // 最终执行出来的结果这里的this.msg使父组件中的 alert(this.msg + str); &#125; &#125;, &#125;) &lt;/script&gt;&lt;/body&gt; 可以看出传递方法的方式与传递属性的方式类似，都是将要传递的东西绑定在引用标签上，只不过绑定方法是用@来绑定，调用的方法也有区别，是用this.$emit(&#39;sonalert&#39;, this.msg)这种方式来触发。 这里还有值得一提的是可以通过 $on方法来监听自定义事件的触发。 还有要注意的两点是 通过上面的例子我们也可以看出，虽然这个传递过来的方法是在子组件中执行的，但是实际的执行者是父组件，相当于是通过让子组件来使父组件执行它自己的方法。 可以通过这种方式来给父组件传递参数，通过上面的例子我们也可以看出，我们在子组件中触发父组件的方法的时候传递了参数，而在方法执行的时候也把子组件传递的参数当作方法的参数执行了。 总结灵活运用好父子组件之间传值或者传递方法对开发有很大的帮助，这也是我必须学习的，通过这一些的小demo也算是把这俩搞清楚了。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>VUE学习笔记</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue.js的学习（创建组件的三种方式以及一些问题）]]></title>
    <url>%2F2019%2F07%2F01%2Fvue-js%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%88%9B%E5%BB%BA%E7%BB%84%E4%BB%B6%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;学习vue也有一段时间了，前面学习了vue中的一些基础的只是，由于期末的原因忙于期末作业就暂停了vue的学习，现在放假了，有时间了就继续学习vue，今天来学习以下vue中的组件，我们都知道其实vue是组件化开发，运用好组件可以大大的提高我们开发的效率。 创建组件的三种方式使用extend来创建组件vue中的extend可以创建一个组件构造器，注意这个创建的不是组件，而是组件构造器，还要通过component注册之后才是组件实例，下面是演示：12345var ext = Vue.extend(&#123; template: "&lt;p&gt;这是一段文字&lt;/p&gt;" &#125;)//component方法有两个参数，第一个参数就是将来我们组件在html中的标签名，就是我们要以什么标签名去将组件应用到网页中，第二个参数就是一个构造器，这个构造器中的template就是我们的组件的模板。Vue.component('test', ext); 也可以直接这样写：123Vue.component('test', Vue.extend(&#123; template: "&lt;p&gt;这是一段文字&lt;/p&gt;" &#125;)); 这样写会更加的简便一些。 省略extend123Vue.component('test', &#123; template: "&lt;p&gt;这是一段文字&lt;/p&gt;" &#125;); vue中也可以将extend省略掉，来创建组件，这样会更加的方便一些 在html中书写模板123456789101112131415&lt;div id="app"&gt; &lt;test&gt;&lt;/test&gt; &lt;/div&gt; &lt;!-- 在html中在template标签中书写模板，然后通过id值或者类名在component引用 --&gt; &lt;template id="tem"&gt; &lt;div&gt; &lt;p&gt;这是一段文字&lt;/p&gt; &lt;/div&gt; &lt;/template&gt; &lt;script src="./../../js/vue.js"&gt;&lt;/script&gt; &lt;script&gt; Vue.component('test', &#123; template: "#tem" &#125;); 通过这种方式来创建组件有一个最大的优势就是因为模板中的代码不是在字符串中书写的，而是在html中书写的，所以书写起来会比较的方便，有代码提示。 创建局部组件前面都是创建的全局组件，这里来演示以下如何创建一个局部组件，其实现在我学过的所有的局部的东西都有一个特点就是名称都相比于全局组件会带s后缀，因为局部components这个对象中可以创建很多个的局部组件，而且因为是在一个对象中，所以创建的局部组件也是通过一个对象来定义的.1234567891011121314151617181920212223242526272829303132var vm = new Vue(&#123; el: '#app', data() &#123; return &#123; &#125; &#125;, methods: &#123; &#125;, &lt;!-- 这里的components本身也是一个对象的键值对，然后它的值又是一个对象，而这个对象的键就是组件的引用名，值是一个模板对象。 --&gt; components: &#123; // 局部组件一 test: &#123; template: "#tem", data() &#123; return &#123; &#125; &#125;, &#125;, // 局部组件二 test2: &#123; template: "#tem", data() &#123; return &#123; &#125; &#125;, &#125;, &#125;&#125;) 要注意的是既然创建的是局部的组件这就以为着它只能在相应的全局组件内有效 要注意的事情 如果使用 Vue.component 定义全局组件的时候，组件名称使用了 驼峰命名，则在引用组件的时候，需要把 大写的驼峰改为小写的字母，同时，两个单词之前，使用 - 符号连接；如果不使用驼峰,则直接拿名称来使用即可; 不论是哪种方式创建出来的组件,组件的 template 属性指向的模板内容,必须有且只能有唯一的一个根元素123Vue.component(&apos;test&apos;, &#123; template: &quot;&lt;p&gt;这是一段文字&lt;/p&gt;&lt;p&gt;这是另一段文字&lt;/p&gt;&quot; &#125;); 像是这样就会报错，也很好理解，如果需要多个根元素直接创建多个组件就好了。 我们创建的组件也可以有自己的属性以及方法，因为我们的vue本身就是组件化开发，但是要注意的一件事情是我们创建的组件的data的写法有要求，必须是函数返回值的形式，像下面这样：12345data() &#123; return &#123; &#125;&#125;, 那为什么要这样呢，如果不这样的话我们给所有组件都用相同名字的data来存放属性，那么当属性的值发生改变的时候，其他的组件的也会受到影响，很显然这不是我们想要的，如果通过函数返回值的这种方式就可以避免这种情况。 总结组件在vue中是非常重要的，因为vue就是组建化开发，那么这里就先学习如何创建组件，下一篇介绍组件之间的一些其他知识。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>VUE学习笔记</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery+php实现一个购物车的功能]]></title>
    <url>%2F2019%2F06%2F30%2FjQuery-php%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%9A%84%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在前面学习jQuery的时候，就学习过ajax如何与后端进行交互，虽然学习过php，但是平时使用的比较少，练的也比较少，Ajax也是，虽然实现动态网站上的各种功能的思路都比较清楚，但是写起来还是比较费劲啊，动不动就报错，特别是这次由于比赛需要，需要在一个静态页面的基础上实现动态的添加购物车的功能，就进行了一次尝试着写，按照我自己的思路，最终经过比较长的时间完成了这一功能，特此来记录一下。 思路先来说说实现的思路：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实我觉得思路是非常简单的，无非就是在前端通过添加购物车的按钮发送Ajax请求，然后将需要添加到购物车的商品的信息提交到后台，然后后台再拿到前端发过来的数据，将数据存放到数据表中，然后前端再在购物车页面通过Ajax请求后台，后台将所有数据表中的数据返回前端，然后前端将获取到的数据拼接到页面中，虽然原理非常的简单，但是实现的过程还是不容易啊，不过为了比赛，还是需要更加的熟练。 这过程中遇到的问题 第一个问题就是对MySQL的语句不是很熟练，每次写语句的时候都是投机取巧的写，并不是完全手打，而且MySQL的很多命令都忘了，即使没忘的也不是很熟 第二个问题就是在前端发送请求之前需要拿到一些元素，需要使用到jQuery中的很多筛选元素的方法，这里之前用的也比较少，需要先去查文档才会用，比如像parents()之类的。 第三个就是php方面对语句不熟。 最终实现功能的主要代码其中很重要的一个也是我想了很久的就是后端究竟要返回什么样的数据，前端又该如何拿到数据。 PHP部分： 12345678910111213&lt;?phpinclude 'conn.php';// 通过加这条header语句就可以配合后面的函数将输出的结果转化为json格式header('Content-Type:application/json; charset=utf-8');$res = mysqli_query($conn, 'select * from cart');// 将数据先放到一个数组中$data = array();while ($row = mysqli_fetch_array($res)) &#123; // 每次循环都将结果存放到这个数组中，由于这里是一个二维表，所以也要用二维数组来存放，一开始没有想明白怎么创建一个键值对的二维数组，折腾了一会就明白了 $data[] = ['name' =&gt; "$row[name]", 'quantity' =&gt; "$row[quantity]", 'price' =&gt; "$row[price]",];&#125;// 然后将数组转化为json格式，这样返回给前端的数据就是一个对象数组了，前端就可以通过jQuery中的``$.each()``方法来对数组进行遍历，然后拿到想要的东西echo json_encode($data); 前端部分 123456789101112131415161718(function () &#123; var cart_item = $('.cart_item'); $.ajax(&#123; type: 'get', url: './php/cart_item.php', success: function (msg) &#123; // 通过循环就可以拿到所有的数据，并且将每条数据都拼接到页面中去 $.each(msg, function (index, obj) &#123; // 这里进行拼接，说实话我觉得拼接真是一件麻烦的事情，不知道有没有更简单的方法 var item = '&lt;tr class="t_body"&gt;&lt;td&gt;&lt;input type="checkbox"&gt;&lt;/td&gt;&lt;td&gt; &lt;img src="' + obj.name + '" alt=""&gt;&lt;/td&gt;&lt;td&gt;shoes&lt;/td&gt;&lt;td class="item_pri"&gt;$2400&lt;/td&gt;&lt;td class="item_num"&gt;&lt;input value="1" type="number"&gt;&lt;/td&gt;&lt;td class="item_total"&gt;2222.00$&lt;/td&gt;&lt;/tr&gt;'; $('tbody').prepend(item); &#125;) &#125;, error: function (xhr) &#123; console.log(xhr); &#125; &#125;) &#125;)(); 总结感觉上面说了一堆废话，其实就是对Ajax和php还不是很熟练所导致的，写的不是很顺，以后多写应该会有所改观。不过通过这几次的写交互页面，也学到了很多，比如如何在php中返回一个对象（通过数组，然后将数组转化为json），以及前端如何较好的处理后端的数据，还有就是后端的一些逻辑处理也想明白了。以后要多回来看前面写过的代码，]]></content>
      <tags>
        <tag>JS</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue.js的学习（vue中的动画）]]></title>
    <url>%2F2019%2F06%2F20%2Fvue-js%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%88vue%E4%B8%AD%E7%9A%84%E5%8A%A8%E7%94%BB%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一开始在使用vue中的动画的时候我没有太明白究竟是个怎么样的机制，以及如何高度的定义一些动画，经过我的尝试，现在终于算是弄明白时怎么一回事了这里是官方文档。 vue中动画的特点vue中的动画主要分为两部分，一是进场动画，二是离场动画，vue中的动画主要是监听了设置动画的元素的显示和隐藏，当元素在页面中被显示的时候就会执行进场动画，当元素被隐藏的时候就会执行离场动画，我们可以通过设置两组类来设置离场动画和进场动画。 一个简单的小例子12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;style&gt; /* 这两个类一个是动画的起始位置,一个是动画结束的时候的位置 */ .dh1-enter, .dh1-leave-to &#123; transform: translateX(40px); opacity: 0; &#125; /* 这两个类一个是进入时候的动画效果，一个是离开时候的动画效果 */ .dh1-enter-active, .dh1-leave-active &#123; transition: all 1s ease; &#125;&lt;/style&gt;&lt;body&gt; &lt;!-- vue中的动画可以分为两部分，一部分是进入的动画，一部分是离开的动画，当元素被隐藏的时候会触发离开的动画，出现的时候会触发进入的动画 --&gt; &lt;div id="app"&gt; &lt;!-- 这是通过这种transition和两个种类来设置动画 --&gt; &lt;button @click="flag=!flag"&gt;点击切换状态&lt;/button&gt; &lt;button @click="flag2=!flag2"&gt;点击切换状态2&lt;/button&gt; &lt;!-- 通过添加appear 可以使动画在渲染到页面的时候就执行一次 --&gt; &lt;transition name="dh1" appear&gt; &lt;p v-show="flag"&gt;这是一段话第一段话&lt;/p&gt; &lt;/transition&gt; &lt;transition name="dh2"&gt; &lt;p v-show="flag2" :class="&#123;animated:true,bounce:true&#125;"&gt;这是一段话第二段话&lt;/p&gt; &lt;/transition&gt; &lt;/div&gt; &lt;script src="./../../js/vue.js"&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#app', data() &#123; return &#123; flag: 'true', flag2: 'false', &#125; &#125;, methods: &#123; &#125;, &#125;) &lt;/script&gt;&lt;/body&gt; 单元素过渡 可以看出其实vue中将动画主要分成了两部分 一部分是入场时的动画，也就是动画从隐藏到显示的这个过程中所执行的动画 另一部分是离场动画也就是元素从显示到隐藏这个过程中所执行的动画 可以通过4个类来分别控制动画，就像上面的例子中的那样 也可以通过vue来添加类来引用动画库中的动画 钩子函数vue中的钩子函数将进场动画和离场动画进行了细分，包括进场前和执行动画时，以及动画结束后，通过设置钩子函数就可以对动画的各个时机进行详细的设置。可以通过钩子函数来设置只进行进场动画或者离场动画，以及对外部引用的动画进行很好的控制。 可以通过这个例子看出来：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;style&gt; .ball &#123; width: 30px; height: 30px; background-color: bisque; border-radius: 50%; margin-top: 10px; &#125;&lt;/style&gt;&lt;body&gt; &lt;!-- 通过钩子函数来实现动画就不再是通过设置样式来实现动画效果，而是通过js来设置样式来实现动画效果 --&gt; &lt;!-- 也是分为几个阶段，主要是两部分，一是进场动画，一是离场动画 --&gt; &lt;!-- 进场动画又分为 --&gt; &lt;!-- 进场前：主要是通过设置style来设置起始时的样式位置之类的 --&gt; &lt;!-- 进场时：主要通过设置style来设置动画结束时的位置，以及动画属性的设置如动画时常 --&gt; &lt;!-- 进场后：动画完成后所执行的东西 --&gt; &lt;!-- 其实钩子函数的原理还是对单元素的过渡做了封装，只不过是可以通过js来控制只进行进场动画或者只进行离场动画 --&gt; &lt;div id="app"&gt; &lt;button @click="flag=!flag"&gt;单击&lt;/button&gt; &lt;transition v-on:before-enter="beforeEnter" v-on:enter="enter" v-on:after-enter="afterEnter"&gt; &lt;div v-show="flag" class="ball"&gt;&lt;/div&gt; &lt;/transition&gt; &lt;/div&gt; &lt;script src="./../../js/vue.js"&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#app', data() &#123; return &#123; flag: false, &#125; &#125;, methods: &#123; // 所有的钩子函数都必须传一个el参数，表示操作的原生dom对象 beforeEnter(el) &#123; el.style.transform = "translate(0,0)"; &#125;, enter(el, done) &#123; //在单纯的使用js钩子函数设置动画时必须传一个done参数来执行完成后的操作，这个done实际上是after-enter所绑定的方法 el.offsetWidth; //这个必须加，不加出bug，没有为什么 el.style.transform = "translate(40px,100px)"; el.style.transition = "all 1s ease"; done(); &#125;, afterEnter(el) &#123; // 这里因为只需要重复这个半场动画，这个从隐藏到出现从上到下的过程，所以将元素设置为不显示，下次再单击的时候就又是执行的是从上到下的动画了 this.flag = !this.flag; &#125; &#125;, &#125;) &lt;/script&gt;&lt;/body&gt; 列表动画在前面的所有例子都是设置的单元素动画，不能用于设置列表中的动画，但我们需要设置一个列表动画，让其中的所有元素都有动画效果的时候，我们就可以使用transition-group这个标签来包裹我们想要设置动画的列表。就像下面这个例子这样：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;style&gt; span &#123; margin: 5px; /* 这里要注意一件事情，必须设置为inline-block,不然元素不会从下面出来，或者使用弹性布局也可以 */ display: inline-block; &#125; .v-enter-active, .v-leave-active &#123; opacity: 1; transition: all 1s ease; &#125; .v-enter, .v-leave-to &#123; transform: translateY(30px); opacity: 0; &#125; /* 要实现其他元素位移时有动画必须添加下面这个类，并且设置动画 */ .v-move &#123; transition: all 1s ease; &#125; /* 而且还必须单独给v-leave-active这个类设置绝对定位才可以实现效果 */ .v-leave-active &#123; position: absolute; &#125;&lt;/style&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;button style="margin-left: 10px" @click="addnum"&gt;add&lt;/button&gt; &lt;button style="margin-left: 10px" @click="delnum"&gt;del&lt;/button&gt; &lt;transition-group tag="div" :style="&#123;margin:'10px'&#125;"&gt; &lt;!-- 如果要让原来元素再插入的过程中保持位置不变，就需要设置key --&gt; &lt;span v-for="(item,index) in list" :key="item"&gt;&#123;&#123;item&#125;&#125;&lt;/span&gt; &lt;/transition-group&gt; &lt;/div&gt; &lt;script src="./../../js/vue.js"&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue(&#123; el: "#app", data() &#123; return &#123; list: [1, 2, 3, 4, 5, 6, 7, 8, 9], num: 10, &#125; &#125;, methods: &#123; randomIndex() &#123; // Math.floor()的作用是返回一个小于等于参数的整数 return Math.floor(Math.random() * this.list.length) &#125;, addnum() &#123; // splice方法还可以用来在指定位置添加元素，第三个参数就是要添加的元素 this.list.splice(this.randomIndex(), 0, this.num++) &#125;, delnum() &#123; this.list.splice(this.randomIndex(), 1) &#125; &#125;, &#125;) &lt;/script&gt;&lt;/body&gt; 这里要注意的几件事是： 如果要使动画生效，必须将要设置动画的元素设置为块级元素或者行内块级元素，如果是行内元素则不会有动画效果。 如果要使其他元素在发生位置移动也拥有动画过渡的效果这需要添加一个v-move这个类，当然，这个名称也是一样可以修改的，然后在这个类中设置动画过渡效果，像上面的这个例子这样。 但是其实只v-move这个类其实是还不够的，还需要在v-leave-active中设置绝对定位，这里要注意的一件事情是，这里必须单独只给这一个类设置，否则也不会有动画效果，一开始的时候我贪图方便就直接在设置active这组动画的时候设置上绝对定位，也就是给两个类都加上了绝对定位，结果发现这样并没有效果，只有单独给一个类设置的时候才有效果。 追加，使用第三方库的动画在最刚开始的时候我认为在vue中给元素添加动画必须要用到vue中提供的控制动画的那几个类或者是钩子函数来实现动画，因为刚接触vue，不是特别熟悉，所以我认为如果要使用第三方的库来给元素添加动画的话应该是通过通过钩子函数来直接控制，但是今天看到了一个别人的用法，有一种恍然大悟的感觉，其实可以直接通过下面的这种方式来设置：123456789101112131415161718192021222324&lt;body&gt; &lt;div id="app"&gt; &lt;button @click="flag=!flag"&gt;单击切换&lt;/button&gt; &lt;transition appear :duration="&#123; enter: 2000, leave: 1000 &#125;" enter-active-class="bounceInLeft" leave-active-class="bounceOutRight"&gt; &lt;p class="animated " v-show="flag"&gt;这是一段测试文字&lt;/p&gt; &lt;/transition&gt; &lt;/div&gt; &lt;script src="./../../js/vue.js"&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue(&#123; el: "#app", data() &#123; return &#123; flag: true, &#125; &#125;, methods: &#123; &#125;, &#125;) &lt;/script&gt;&lt;/body&gt; 直接通过设置两个active类就可以实现动画的效果了，一个是进场动画，一个是离场动画，可以通过:duration=&quot;2000&quot;来设置动画的时间，可以像这样直接只传一个时间来设置两个动画的时间，也可以像上面的例子一样通过一个对象来设置两个动画的不同时间。 而在此之前我都是想通过钩子函数来给元素添加类来实现动画的效果，很显然不如上面的这种方式方便，当时在遇到比较复杂的情况的时候还是要使用钩子函数。不得不说vue真是一款很好的框架！ 总结要熟练设置vue中的动画就必须要理解vue中动画的运作机制，理解进场和离场这两个过程，然后可以通过设置两组类来设置动画的效果，当这种方法无法满足需求的时候就可以通过钩子函数来满足我们的需求。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>VUE学习笔记</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>动画</tag>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue.js的学习（vue实例的生命周期）]]></title>
    <url>%2F2019%2F06%2F18%2Fvue-js%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%88vue%E5%AE%9E%E4%BE%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过学习了解vue实例的生命周期对vue的学习十分的有帮助，所以这次来了解学习以下vue中vue实例的生命周期。 什么是生命周期：从Vue实例创建、运行、到销毁期间，总是伴随着各种各样的事件，这些事件，统称为生命周期！ 生命周期钩子：就是生命周期事件的别名而已； 生命周期钩子 = 生命周期函数 = 生命周期事件 主要的生命周期函数分类： 创建期间的生命周期函数： beforeCreate：实例刚在内存中被创建出来，此时，还没有初始化好 data 和 methods 属性 created：实例已经在内存中创建OK，此时 data 和 methods 已经创建OK，此时还没有开始 编译模板 beforeMount：此时已经完成了模板的编译，但是还没有挂载到页面中 mounted：此时，已经将编译好的模板，挂载到了页面指定的容器中显示 运行期间的生命周期函数： beforeUpdate：状态更新之前执行此函数， 此时 data 中的状态值是最新的，但是界面上显示的 数据还是旧的，因为此时还没有开始重新渲染DOM节点 updated：实例更新完毕之后调用此函数，此时 data 中的状态值 和 界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了！ 销毁期间的生命周期函数： beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。 destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 可以通过这张图来形象的了解以下生命周期的含义： 这次的vue的生命周期的学习就到这里了，通过这张图可以有比较完整的了解。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>VUE学习笔记</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue.js的学习（自定义指令）]]></title>
    <url>%2F2019%2F06%2F18%2Fvue-js%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%88%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在vue中很多时候现有的指令都是不够我们用的，那么vue中是允许我们自定义指令的，那么我们就可以通过自定义指令来实现我们想要的功能。通过 directive 来定义。 一个简单的例子123456789101112131415161718192021222324252627282930&lt;body&gt; &lt;div id="app"&gt; &lt;input type="text" v-focus='1+1'&gt; &lt;/div&gt; &lt;script src="./../../js/vue.js"&gt;&lt;/script&gt; &lt;script&gt; Vue.directive('focus',&#123; inserted:function(el,binding)&#123; el.focus(); console.log(binding.name); console.log(binding.value); console.log(binding.expression); &#125; &#125;); var vm = new Vue(&#123; el:'#app', data() &#123; return &#123; &#125; &#125;, methods: &#123; &#125;, &#125;) &lt;/script&gt;&lt;/body&gt; 可以看出这样就通过定义了一个全局指令来使一个文本框自动获得了焦点。 定义全局指令上面的例子就是定义的一个全局指令 ###定义局部指令12345678directives: &#123; focus: &#123; // 指令的定义 inserted: function (el) &#123; el.focus() &#125; &#125;&#125; 像这样就可以定义一个局部指令，局部指令是通过一个对象来定义。，并且名称后面带有s。 钩子函数在上面的例子中以下代码就是用的inserted这个钩子函数1inserted:function(el,binding)&#123; 钩子函数的类别： bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。这是在dom树还没有渲染到页面中之前，还在内存中的时候会调用，那么对于大部分js中的行为来说肯定是不会生效的，但对于比如像设置样式这种一直存在的东西来说，渲染到页面之后也还会有效 inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。当dom元素被插入到页面时触发，对于js中的行为也能触发 update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。 componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。 unbind：只调用一次，指令与元素解绑时调用。 钩子函数的参数 el：指令所绑定的元素，可以用来直接操作 DOM 。 binding：一个对象，包含以下属性： -name：指令名，不包括 v- 前缀。 -value：指令的绑定值，例如：v-my-directive=”1 + 1” 中，绑定值为 2。 -oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。 -expression：字符串形式的指令表达式。例如 v-my-directive=”1 + 1” 中，表达式为 “1 + 1”。 -arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 “foo”。 -modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。 vnode：Vue 编译生成的虚拟节点。移步 VNode API 来了解更多详情。 oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。 在上面的例子中就演示了这些参数：12345678Vue.directive(&apos;focus&apos;,&#123; inserted:function(el,binding)&#123; el.focus(); console.log(binding.name); //focus console.log(binding.value);//2 console.log(binding.expression);//1+1 &#125;&#125;);]]></content>
      <categories>
        <category>学习笔记</category>
        <category>VUE学习笔记</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-js的学习（按键修饰符及自定义按键修饰符）]]></title>
    <url>%2F2019%2F06%2F18%2Fvue%E4%B8%AD%E7%9A%84%E9%94%AE%E7%9B%98%E4%BF%AE%E9%A5%B0%E7%AC%A6%E4%BB%A5%E5%8F%8A%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%AE%E7%9B%98%E4%BF%AE%E9%A5%B0%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在vue中可以通过键盘修饰符来控制元素在按下相应按键时的动作。vue中提供了部分内置的键盘修饰符按键码的别名，但是不是很多，那么在vue中也是可以自定义的。 案件修饰符的使用在监听键盘事件时，我们经常需要检查详细的按键。Vue 允许为 v-on 在监听键盘事件时添加按键修饰符：1&lt;input v-on:keyup.enter=&quot;test()&quot;&gt; 可以通过按键码来实现1&lt;input v-on:keyup.13=&quot;test()&quot;&gt; enter键的按键码就是13，所以等同于上面那个例子。 vue中自带的别名 .enter .tab .delete (捕获“删除”和“退格”键) .esc .space .up .down .left .right 自定义案件修饰符可以通过这样的方式来自定义按键修饰符：12Vue.config.keyCodes.f2 = 113; 然后就可以通过按下f2来触发了。 系统修饰符 .ctrl .alt .shift .meta 通过系统修饰符可以控制系统按键与其他事件的组合：1&lt;input type=&quot;text&quot; @keyup.13.ctrl=&quot;test()&quot; &gt; 以上代码就需要同时按回车以及control键才能触发。 鼠标按钮修饰符2.2.0 新增 .left .right .middle 像是这样：1&lt;input type=&quot;text&quot; @click.left=&quot;test()&quot; &gt;]]></content>
      <categories>
        <category>学习笔记</category>
        <category>VUE学习笔记</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue.js的学习（七）过滤器filter的使用]]></title>
    <url>%2F2019%2F06%2F17%2Fvue-js%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%83%EF%BC%89%E8%BF%87%E6%BB%A4%E5%99%A8filter%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;filter过滤器可以用来格式化数据，只能用在插值表达式或者v-model之类的组件上面。分为全局过滤器和私有过滤器，在定义的方法上稍有区别。 定义全局过滤器Vue.js 允许你自定义过滤器，可被用于一些常见的文本格式化。过滤器可以用在两个地方：双花括号插值和 v-bind 表达式 (后者从 2.1.0+ 开始支持)。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符号指示：1&lt;td&gt;&#123;&#123;item.time | dateformat&#125;&#125;&lt;/td&gt; 12345678910Vue.filter('dateformat',function(date)&#123; var dt=new Date(date); var y=dt.getFullYear(); var m=dt.getMonth()+1; var d=dt.getDate(); var h=dt.getHours(); var min=dt.getMinutes(); var s=dt.getSeconds(); return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;h&#125;:$&#123;min&#125;:$&#123;s&#125;`; &#125;); 过滤器可以串联：1&#123;&#123; message | filterA | filterB &#125;&#125; 在这个例子中，filterA 被定义为接收单个参数的过滤器函数，表达式 message 的值将作为参数传入到函数中。然后继续调用同样被定义为接收单个参数的过滤器函数 filterB，将 filterA 的结果传递到 filterB 中。 过滤器是 JavaScript 函数，因此可以接收参数：1&lt;td&gt;&#123;&#123;item.time | dateformat(&apos;yyyy-mm-dd&apos;)&#125;&#125;&lt;/td&gt; 1234567891011121314Vue.filter('dateformat',function(date,agr='')&#123;//最好给参数设置一个默认值，防止出现bug var dt=new Date(date); var y=dt.getFullYear(); var m=dt.getMonth()+1; var d=dt.getDate(); var h=dt.getHours(); var min=dt.getMinutes(); var s=dt.getSeconds(); if(agr=='yyyy-mm-dd')&#123; return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;`; &#125; else return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;h&#125;:$&#123;min&#125;:$&#123;s&#125;`; &#125;); 定义私有过滤器123456789101112131415filters:&#123; dateformat(date,agr='')&#123; var y=dt.getFullYear(); var m=(dt.getMonth()+1).toString().padStart(2,'0'); var d=dt.getDate().toString().padStart(2,'0'); var h=dt.getHours().toString().padStart(2,'0'); var min=dt.getMinutes().toString().padStart(2,'0'); var s=dt.getSeconds().toString().padStart(2,'0'); if(agr=='yyyy-mm-dd')&#123; return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;`; &#125; else return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;h&#125;:$&#123;min&#125;:$&#123;s&#125;`; &#125;&#125;, 通过一个对象来设置，整体与全局设置的方法差不多。 学习到的一些知识 可以通过`${y}-${m}-${d} ${h}:${min}:${s}`像这样的方式来格式化数据，${}为占位符。 可以通过padStart(len, str)与padEnd(len, str)这两个方法来补全字符串，但是要注意只能补全字符串，所以通常需要先通过tostring()方法转化为字符串 根据给定长度自动在字符串的前面补充想补充的字符串（只返回修改后的字符串，不修改原字符串） len 给定的长度，转换后 str 想补充的字符串类似这样：1var s=dt.getSeconds().toString().padStart(2,&apos;0&apos;); 总结通过定义filter可以很方便的来格式化数据，这里还有一个小细节，就是带s的就是私有的，不带s的就是全局的。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>VUE学习笔记</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过vue来做一个可以简单操作的页面]]></title>
    <url>%2F2019%2F06%2F17%2F%E9%80%9A%E8%BF%87vue%E6%9D%A5%E5%81%9A%E4%B8%80%E4%B8%AA%E5%8F%AF%E4%BB%A5%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C%E7%9A%84%E9%A1%B5%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;经过学习了vue的一些简单基本的东西，现在讲前面学过的这些东西简单的引用一下，做一个可以简单操作页面元素的页面，同时来熟悉vue的操作。 代码和效果图html:1234567891011121314151617181920212223242526272829303132333435363738394041&lt;div id="app"&gt; &lt;div class="container"&gt; &lt;div class="card"&gt; &lt;div class="card-header"&gt; 相关操作 &lt;/div&gt; &lt;div class="card-body"&gt; &lt;!-- 给表单添加v-model来实现数据的双向绑定 --&gt; &lt;form class="form-inline"&gt; &lt;label for=""&gt;id：&lt;/label&gt; &lt;input class="form-control mr-md-2 " type="text" name="" v-model="id"&gt; &lt;label for=""&gt;name：&lt;/label&gt; &lt;input class="form-control" type="text" name="" v-model="name"&gt; &lt;button class="btn btn-primary ml-md-1 mr-md-3" type="button" @click='add'&gt;添加&lt;/button&gt; &lt;!-- 实现搜索功能 --&gt; &lt;label for=""&gt;输入关键字进行搜索：&lt;/label&gt; &lt;input class="form-control" type="text" name=""&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;table class="table table-light mt-5 table-bordered table-striped"&gt; &lt;thead class="thead-light"&gt; &lt;tr&gt; &lt;th&gt;Id&lt;/th&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Time&lt;/th&gt; &lt;th&gt;opration&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;!-- 通过v-for的循环来将我们的数据来渲染到页面中 --&gt; &lt;tr v-for="(item) in info" :key="item.id"&gt; &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.time&#125;&#125;&lt;/td&gt; &lt;td&gt;&lt;a href="" @click.prevent='rm(item.id)'&gt;删除&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt; js:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 var vm = new Vue(&#123; el: '#app', data() &#123; return &#123; id: '', name: '', time: '', keywords:'', // 将我们页面中的数据放在这俩面 info: [&#123; id: '1', name: 'aaa', time: new Date() &#125;, &#123; id: '2', name: 'bbb', time: new Date() &#125;, ], &#125; &#125;, methods: &#123; // 通过自己构建函数来控制添加和删除 add() &#123;//这是添加的函数 this.info.push(&#123; id: this.id, name: this.name, time: new Date(), &#125;); this.id = this.name = ''; &#125;, rm(id) &#123;//这是删除的函数，我用了两种写法 // this.info.forEach((item,index) =&gt; &#123; // if(id=item.id)&#123; // this.info.splice(index,1) // return ; // &#125; // &#125;); // 这一种代码会更简便一些 this.info.splice(this.info.findIndex(item =&gt; &#123; return item.id == id; &#125;), 1); &#125;, searchList(keywords)&#123; return this.info.filter(item =&gt; &#123; return item.name.includes(keywords); &#125;) &#125; &#125;,&#125;) 最后的效果图： 通过页面上的增加和删除就可以实现页面的修改 实现原理在vue中更看重于业务逻辑，所以很多方面的工作我们不需要去关心，也不需要去操作dom对象就可以轻松的修改页面上的内容 我们通过v-for的循环将我们的数据渲染到页面中 我们通过v-model数据双向绑定来将用户在页面中输入的数据放到我们存放数据的地方，因为vue的特性，只要数据有更新，那么页面就会跟着一起更新，这是十分方便的一件事情 再通过数组的一些操作方法将我们想要删除的数据进行删除，那么页面中相应的内容也会被删除。 搜索功能是通过v-model数据的双向绑定来拿到用户需要搜索的数据，然后通过filter()这个方法来设置条件进行过滤，然后返回一个新的数组，过滤的条件可以通过inclues来设置。 学习到的一些知识正如我上一篇博客介绍的那样，在特定的情况下使用filter之类的方法会更加的便捷，这次在写搜索的那个函数的时候我就用到了filter这个方法，使代码更加的精简，这里可以使用foreach，但这会有更加多的代码量，所以我没有这么做。 我遇到的一些坑与问题 第一个花费时间比较久的地方是当我完成了数据的添加的这个功能之后发现了一个问题就是当我向页面中添加完数据之后，我再修改输入框中的数据，已经渲染在页面之中的数据也会跟着一起修改，很显然这不是我想要的效果，后面发现是我将一个带着变量的对象直接push到数组当中，而不是在单击事件的时候通过变量创建一个新的对象再push进去。也就是说应该需要一个中间的变量来将一个会实时变化的变量变成一个固定的变量。 第二个问题就是在使用findIndex方法的时候将return item.id == id写成了return item.id = id 导致在操作的时候出现了问题 总结这次写这些东西让我对vue有了更加清晰的概念，并且也用了一些以前没有用过的方法来使代码更加的简单，同时要记住写代码犯的一些错误，要记住在进行比较的时候判断是否相等要用==，千万不能永成赋值符号=]]></content>
      <tags>
        <tag>JS</tag>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js中的some、find、findindex、includes、filter的使用]]></title>
    <url>%2F2019%2F06%2F17%2Fjs%E4%B8%AD%E7%9A%84some%E3%80%81find%E3%80%81findindex%E3%80%81includes%E3%80%81filter%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最近在学习中学习到一些以前接触的比较少的一些方法，其中很多是es6新增的方法，这次就来对所有的这些方法来进行一个探究，看看这些方法究竟是什么作用。 类似于foreach的方法为什么把这类方法归到一起讲，因为我在使用的过程中发现其实这些方法的用法和参数其实都是一样的，底层应该都是和foreach差不多，差别只是在于返回的东西不一样，那么再来看看这些方法的差别以及用法。 语法 array.方法名(function(currentValue, index, arr),thisValue) 参数 参数 描述 function(currentValue, index,arr) 必需。数组每个元素需要执行的函数。函数参数: 参数 描述 currentValue 必需。当前元素 index 可选。当前元素的索引值 arr 可选。当前元素所属的数组对象 thisValue 可选。 传递给函数的值一般用 "this" 值。如果这个参数为空， "undefined" 会传递给 "this" 值 以上是这些方法共同的基本的语法以及参数 那么再来看看这些方法的不同点 forEach()forEach() 方法用于调用数组的每个元素，并将元素传递给回调函数。 注意: forEach() 对于空数组是不会执行回调函数的。 也就是说 forEach() 这个方法是没有任何限制的，回调函数最终返回的值是完全由自己决定的，也就是说其实后面介绍到的所有的方法其实也都可以通过forEach()来实现相同的功能，只不过要自己写更多的代码量。forEach()可以通过return来提前退出循环，同时返回相应的值 map()map() 方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。 map() 方法按照原始数组元素顺序依次处理元素。 注意： map() 不会对空数组进行检测。 注意： map() 不会改变原始数组。 map和foreach很像，差别就在于map所得到的所有符合条件的结果都会通过一个数组来返回。在我们需要将结果放到一个数组中的时候直接使用map就会更加的方便。在map()中return无论如何都会返回一个数组，可以通过return来对原数组进行操作返回一个新数组12345678 var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]; console.log(arr.map(item =&gt; &#123; return true; //[[true, true, true, true, true, true, true, true, true]]&#125;)); console.log(arr.map(item =&gt; &#123; return item*2; //[2, 4, 6, 8, 10, 12, 14, 16, 18]&#125;)); some()some() 方法用于检测数组中的元素是否满足指定条件（函数提供）。 some() 方法会依次执行数组的每个元素： 如果有一个元素满足条件，则表达式返回true , 剩余的元素不会再执行检测。 如果没有满足条件的元素，则返回false。注意： some() 不会对空数组进行检测。 注意： some() 不会改变原始数组。 也就是说some并不一定会遍历完数组中全部的元素，当遍历到由符合条件的元素时就会返回true并终止，否则返回false，所以也就可以通过利用此特性来对数组中特定一部分的元素进行操作。 123456var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];console.log(arr.some(item =&gt; &#123; // 通过some可以对数组中符合要求的之前的元素进行操作 console.log(item); return item &gt; 5; //可以通过return来设置返回值的条件&#125;)); 还有一个相对的方法叫做 every() ,条件时数组中所有的元素都满足条件。 find()find() 方法返回通过测试（函数内判断）的数组的第一个元素的值。 find() 方法为数组中的每个元素都调用一次函数执行： 当数组中的元素在测试条件时返回 true 时, find() 返回符合条件的元素，之后的值不会再调用执行函数。 如果没有符合条件的元素返回 undefined注意: find() 对于空数组，函数是不会执行的。 注意: find() 并没有改变数组的原始值。 123456var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];console.log(arr.find(item =&gt; &#123; // 通过find也可以对数组中符合要求的之前的元素进行操作 console.log(item); return item&gt;5;&#125;)); findIndex()findIndex() 方法返回传入一个测试条件（函数）符合条件的数组第一个元素位置。 findIndex() 方法为数组中的每个元素都调用一次函数执行： 当数组中的元素在测试条件时返回 true 时, findIndex() 返回符合条件的元素的索引位置，之后的值不会再调用执行函数。 如果没有符合条件的元素返回 -1注意: findIndex() 对于空数组，函数是不会执行的。 注意: findIndex() 并没有改变数组的原始值。 与find方法类似，区别只在于这个方法返回的时元素在数组中的索引。 12345var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];console.log(arr.findIndex(item =&gt; &#123; console.log(item); return item&gt;5; &#125;)); filter()filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。 注意： filter() 不会对空数组进行检测。 注意： filter() 不会改变原始数组。 这个方法与map方法类似，map方法没有返回的条件，而这个方法可以直接通过rerun来设置过滤条件。1234var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];console.log(arr.filter(item =&gt; &#123; return item &gt;2&#125;)); includes()这个方法是es6中新增的一个方法，可以用来判断一个数组或者是字符串中是否包含某一元素，如果是返回 true，否则false。 语法arr.includes(searchElement)arr.includes(searchElement, fromIndex) 参数searchElement 必须。需要查找的元素值。fromIndex 可选。从该索引处开始查找 searchElement。如果为负值，则按升序从 array.length + fromIndex 的索引开始搜索。默认为 0。 12var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];console.log(arr.includes(5)); //true 总结以前只是对这些方法有了解，但是了解的不是很多，也会使用foreach这样的方法，但是现在知道了这么多方法，就应该在适当的情况下用相应的方法来减少代码量和工作量。]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue.js的学习（六）v-if和v-show]]></title>
    <url>%2F2019%2F06%2F16%2Fvue-js%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AD%EF%BC%89v-if%E5%92%8Cv-show%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这次来学习vue中隐藏元素的两种方法，一种是v-if，另一种是v-show，同时明白二者之间的区别，一件分别适用于哪种情况。 示例1234567891011121314151617181920212223242526272829&lt;body&gt; &lt;div id="app"&gt; &lt;!-- 通过两种方式都可以实现元素的隐藏，但是我们从控制台检查元素就可以看出二者之间的区别 --&gt; &lt;button @click="flag=!flag"&gt;点击显示/不显示&lt;/button&gt; &lt;p v-if="flag"&gt; 这是用v-if控制的元素 &lt;/p&gt; &lt;p v-show="flag"&gt; 这是用v-show控制的元素 &lt;/p&gt; &lt;/div&gt; &lt;script src="./../../js/vue.js"&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#app', data() &#123; return &#123; flag:true, &#125; &#125;, methods: &#123; toggle ()&#123; this.flag=!this.flag; &#125; &#125;, &#125;) &lt;/script&gt;&lt;/body&gt; 通过以上代码，我们在页面中单击切换按钮就可以隐藏或者显示两个分别被v-if和v-show控制的元素。 二者之间的区别 通过检查元素我们可以清除的看到，当我们将元素进行隐藏的时候，v-if是将元素进行删除，而v-show是将元素的display设置为none，从而将元素隐藏。 那么我们什么时候用v-if什么时候用v-show呢 因为v-if是将元素进行添加和删除，所以在进行这个过程的时候会比较消耗资源，所以不推荐在频繁要触发v-if的时候使用 而v-show是设置元素的display，那么无论元素一开始是否显示在页面上都需要创建元素，所以在渲染页面的时候会相较于v-if更加占用资源，所以不推荐在很少需要用到v-show来进行切换的时候使用。 学到的一些新东西当我们需要频繁的在两种状态之间进行切换的时候我们可以使用下面这种方法来控制1flag:true, 1this.flag=!this.flag; 就不需要像以前的思路那样设置一个数字的循环，然后判断是否能被2整除来进行两种状态之间的切换。 当函数的代码连非常的小的时候我们就可以直接在调用的时候写，像下面这样：1&lt;button @click=&quot;flag=!flag&quot;&gt;点击显示/不显示&lt;/button&gt; 总结二者之间的区别在于渲染的方式不一样，在切换不频繁的情况下使用v-if，在切换频繁的情况下使用v-show]]></content>
      <categories>
        <category>学习笔记</category>
        <category>VUE学习笔记</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue.js的学习（五）v-for 和key]]></title>
    <url>%2F2019%2F06%2F16%2Fvue-js%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89v-for%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这次学习一下vue中的循环v-for和key,以及通过他们来遍历数组以及遍历对象并且将他们渲染到页面中. v-for的使用12345678910111213141516171819202122232425262728293031&lt;body&gt;&lt;div id="app"&gt; &lt;!-- 遍历数组 --&gt; &lt;p v-for="(item, index) in arr"&gt; 数组中的值是:&#123;&#123;item&#125;&#125;---索引是:&#123;&#123;index&#125;&#125; &lt;/p&gt; &lt;br&gt; &lt;!-- 遍历对象 --&gt; &lt;p v-for="(item, key, index) in obj "&gt; &#123;&#123;key&#125;&#125;---&#123;&#123;item&#125;&#125;---索引是:&#123;&#123;index&#125;&#125; &lt;/p&gt;&lt;/div&gt; &lt;script src="./../../js/vue.js"&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue(&#123; el:'#app', data() &#123; return &#123; arr:[1,2,3,4,5,6], obj:&#123; name:'zs', age:18, gender:'男' &#125; &#125; &#125;, &#125;) &lt;/script&gt;&lt;/body&gt; 可以看出v-for的使用非常的简单 在遍历数组的时候传递两个参数，那么第一个参数就是数组里面的值，第二个参数就是索引 123&lt;p v-for=&quot;(item, index) in arr&quot;&gt; 数组中的值是:&#123;&#123;item&#125;&#125;---索引是:&#123;&#123;index&#125;&#125; &lt;/p&gt; 遍历对象的时候，传递两个参数，那么第一个参数是对象键值对中的值，第二个参数是对象中的键，如果有第三个参数那么第三个参数就是索引 123&lt;p v-for=&quot;(item, key, index) in obj &quot;&gt; &#123;&#123;key&#125;&#125;---&#123;&#123;item&#125;&#125;---索引是:&#123;&#123;index&#125;&#125;&lt;/p&gt; key的使用在遍历的时候可以不加key1&lt;p v-for=&quot;(item, index) in items&quot;&gt;&lt;/p&gt; 也可以加key1&lt;p v-for=&quot;(item, index) in items&quot; :key=&quot;index&quot;&gt;&lt;/p&gt; 那么二者之间有什么区别呢，在我上面的例子中没有什么区别， 具体的区别可以参考 这个帖子 。解释的十分形象 注意：key最好是唯一标识符1&lt;p v-for=&quot;(item, index) in items&quot; :key=&quot;index&quot;&gt;&lt;/p&gt; 并且最好不要像这样设置，因为在排序的时候索引也是跟着一起在变化的，那像这样设置了基本上也等于没设置。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>VUE学习笔记</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue.js的学习（四）添加样式]]></title>
    <url>%2F2019%2F06%2F16%2Fvue-js%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89%E6%B7%BB%E5%8A%A0%E6%A0%B7%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这次学习了通过vue来给元素添加样式,前面我们已经学习过了给元素绑定属性,我们就可以通过这种方法来给元素添加样式.主要通过两种方法,一种是给元素绑定class,一种是给元素绑定style. 先看页面代码:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;style&gt;.big&#123; font-size: 40px;&#125;.color&#123; color: red;&#125;.thin&#123; font-weight: 200;&#125;&lt;/style&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;!-- 第一种添加样式类 ,注意要加引号--&gt; &lt;p :class="['big','thin']"&gt;这是一段测试文字&lt;/p&gt; &lt;!-- 第二种 数组中嵌套对象，通过对象来控制是否引用相应的类 ,在对象中可以省略引号，除非有 - --&gt; &lt;p :class="['big',&#123;thin:true,color:flag&#125;]"&gt;这是一段测试文字&lt;/p&gt; &lt;!-- 第三种，直接使用对象 --&gt; &lt;p :class="&#123;thin:true,big:flag&#125;"&gt;这是一段测试文字&lt;/p&gt; &lt;!-- 也可以直接在变量中写对象,直接调用变量 --&gt; &lt;p :class="mclass"&gt;这是一段测试文字&lt;/p&gt; &lt;!-- 通过绑定style来添加样式 --&gt; &lt;p :style="&#123;color:'red','font-size':'40px'&#125;"&gt;这是一段测试文字&lt;/p&gt; &lt;p :style="mstyle"&gt;这是一段测试文字&lt;/p&gt; &lt;p :style="[mstyle,mstyle2]"&gt;这是一段测试文字&lt;/p&gt; &lt;/div&gt; &lt;script src="./../../js/vue.js"&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue(&#123; el:'#app', data:&#123; flag:true, mclass:&#123; thin:true, color:true, big:true, &#125;, mstyle:&#123; color:'red', 'font-size':'40px', 'font-weight':200, &#125; &#125;, methods: &#123; &#125;, &#125;) &lt;/script&gt;&lt;/body&gt; 绑定class来添加样式通过数组通过给元素绑定class来添加样式:1&lt;p :class=&quot;[&apos;big&apos;,&apos;thin&apos;]&quot;&gt;这是一段测试文字&lt;/p&gt; 给通过给class绑定一个数组来添加class样式 注意,数组里面的元素都需要加上引号 通过数组中嵌套对象1&lt;p :class=&quot;[&apos;big&apos;,&#123;thin:true,color:flag&#125;]&quot;&gt;这是一段测试文字&lt;/p&gt; 通过对象来添加class需要通过true或者是false来控制是否绑定相应class类 这里可以直接给true或者是false也可以通过变量来传递true或者是false,比如这里通过了一个变量flag 通过对象既然可以通过数组中嵌套对象,那么就可以直接使用对象来绑定class1&lt;p :class=&quot;&#123;thin:true,big:flag&#125;&quot;&gt;这是一段测试文字&lt;/p&gt; 直接通过对象来绑定class也可以将对象设置在一个变量中,通过直接绑定这个变量也可以实现.1&lt;p :class=&quot;mclass&quot;&gt;这是一段测试文字&lt;/p&gt; 在对象中的键值对中的键可以加引号也可以不加引号,但是名字中有-就必须要加引号. 绑定style来添加样式 通过对象来设置: 1&lt;p :style=&quot;&#123;color:&apos;red&apos;,&apos;font-size&apos;:&apos;40px&apos;&#125;&quot;&gt;这是一段测试文字&lt;/p&gt; 将对象设置到变量通过变量来设置 1&lt;p :style=&quot;mstyle&quot;&gt;这是一段测试文字&lt;/p&gt; 通过数组来同时设置多个变量 1&lt;p :style=&quot;[mstyle,mstyle2]&quot;&gt;这是一段测试文字&lt;/p&gt; 来看看设置之后的效果可以看到全部都生效了 总结以上就是在vue中设置样式的一些方法]]></content>
      <categories>
        <category>学习笔记</category>
        <category>VUE学习笔记</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>JS</tag>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue.js的学习（三）数据的双向绑定]]></title>
    <url>%2F2019%2F06%2F16%2Fvue-js%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这次来学习vue中的双向数据绑定的一种方法，使用v-model来进行数据的双向绑定，并通过其来实现一个超级简单的计算器。 v-model通过v-model可以实现数据的双向绑定，我们前面学习过的v-text以及v-html都只能是实现数据的单项绑定，就是将M绑定到V，有时候需要实现数据的双向绑定，这个时候就需要用到v-model来实现，基本的用法：1&lt;input v-model="n1" type="text"&gt; 指的注意的一件事情就是v-model只对表单有效，对其他元素无效，因为其他元素无法双向修改数据，只有表单可以做到用户可以修改其中的数据。 通过v-model来实现一个简单的计算器12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;body&gt; &lt;div id="app"&gt; &lt;input v-model="n1" type="text"&gt; &lt;select v-model="sign" name="" id=""&gt; &lt;option value="+"&gt;+&lt;/option&gt; &lt;option value="-"&gt;-&lt;/option&gt; &lt;option value="*"&gt;*&lt;/option&gt; &lt;option value="/"&gt;/&lt;/option&gt; &lt;/select&gt; &lt;input v-model="n2" type="text"&gt; &lt;button @click="compute"&gt;=&lt;/button&gt; &lt;input v-model="res" type="text"&gt; &lt;/div&gt; &lt;script src="./../../js/vue.js"&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue(&#123; el:'#app', data:&#123; n1:0, n2:0, sign:'+', res:0, &#125;, methods: &#123; compute () &#123; // 这是一种方法，使用switch来判断条件 switch (this.sign)&#123; case "+" : this.res= parseFloat(this.n1) + parseFloat(this.n2); break; case "-" : this.res= parseFloat(this.n1) - parseFloat(this.n2); break; case "*" : this.res= parseFloat(this.n1) * parseFloat(this.n2); break; case "/" : this.res= parseFloat(this.n1) / parseFloat(this.n2); break; &#125; // 还有一种投机取巧的办法，但是不推荐使用 // var str=this.n1+this.sign+this.n2; // this.res=eval(str); &#125; &#125;, &#125;) &lt;/script&gt;&lt;/body&gt; 写的时候要注意不要把this给忘了。 通过两种方法都能成功实现了一个简单的计算器。 但是要注意的一件事情是尽量不要使用第二种方法，因为第二种方法中使用的eval()函数会将字符串解析成代码，所以其实这是很不安全的一件事情，坏人就有机可乘可以搞破坏。 总结这次学习的是vue中的v-model,使用这个方法可以十分轻松的实现数据的双向绑定。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>VUE学习笔记</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue.js的学习（二）事件修饰符]]></title>
    <url>%2F2019%2F06%2F16%2Fvue-js%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这次的笔记来学些一下vue中的事件修饰符，通过事件修饰符可是实现一些简单的功能，比如阻止冒泡之类的。 一下是一段运用了事件修饰符的代码：12345678910111213141516171819202122232425262728293031323334&lt;style&gt;div&#123; padding: 50px;&#125;&lt;/style&gt;&lt;body&gt; &lt;div @click='outerclick' id="app" style="background-color: blue"&gt; &lt;div @click='innerclick' style="background-color: red"&gt; &lt;button @click='btnclick'&gt;这是一个测试按钮&lt;/button&gt; &lt;/div&gt; &lt;a @click.prevent.once href="https://www.baidu.com"&gt;这是去百度的链接&lt;/a&gt; &lt;/div&gt; &lt;script src="./../../js/vue.js"&gt;&lt;/script&gt; &lt;script&gt; var vm=new Vue(&#123; el:'#app', data:&#123;// 通过在data中设置变量 msg:'这是一个测试内容', &#125;, methods: &#123; btnclick()&#123; alert('这是一个按钮'); &#125;, innerclick()&#123; alert('这是里面的div') &#125;, outerclick()&#123; alert('这是外面的div') &#125; &#125;, &#125;) &lt;/script&gt;&lt;/body&gt; .stop 通过.stop可以阻止事件向上冒泡 1&lt;button @click.stop=&apos;btnclick&apos;&gt;这是一个测试按钮&lt;/button&gt; 我们只需要这样设置就可以阻止事件向上冒泡 .self 通过.self可以阻止事件向上冒泡1&lt;div @click.self=&apos;innerclick&apos; style=&quot;background-color: red&quot;&gt; 我们只需要这样设置就使这个里面的div在按钮进行事件冒泡的时候不会触发它的单击事件，只会触发自己的事件。 .prevent通过.prevent就可以阻止默认行为1&lt;a @click.prevent href=&quot;https://www.baidu.com&quot;&gt;这是去百度的链接&lt;/a&gt; 通过以上代码就可以实现阻止默认行为，但我们单击超链接的时候就不会进行跳转 .once通过.once就可以使事件修饰符只起作用一次1&lt;a @click.prevent.once href=&quot;https://www.baidu.com&quot;&gt;这是去百度的链接&lt;/a&gt; 通过以上代码，当我们单击超链接的时候第一次不会进行跳转，但是再次单击的时候就会进行跳转了 其他事件修饰符也适用 总结这次学习了vue中的事件修饰符]]></content>
      <categories>
        <category>学习笔记</category>
        <category>VUE学习笔记</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过vue做一个简单的跑马灯]]></title>
    <url>%2F2019%2F06%2F15%2F%E9%80%9A%E8%BF%87vue%E5%81%9A%E4%B8%80%E4%B8%AA%E8%B7%91%E9%A9%AC%E7%81%AF%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前面简单的学习了vue中的一些简单的东西以及入门，这次通过vue来做一个简单的跑马灯来试一试. 实现原理其实实现原理非常的简单，只需要将我们需要跑起来的字符串的首个字符拼接到字符串尾部，再通过定时器将新的字符串渲染到页面就可以了，只不过这些都是通过vue框架来实现的。 代码12345678910111213141516171819202122232425262728293031323334&lt;body&gt; &lt;div v-cloak id="app"&gt; &lt;button @click='pmd'&gt;跑起来&lt;/button&gt; &lt;button @click='stoppmd'&gt;停止&lt;/button&gt; &lt;p v-text="msg"&gt; &lt;/p&gt; &lt;/div&gt; &lt;script src="./../../js/vue.js"&gt;&lt;/script&gt; &lt;script&gt; var vm=new Vue(&#123; el:'#app', data:&#123;// 通过在data中设置变量 msg:'这是一个测试内容', timer:null,//通过timer这个变量来控制只有第一次单击有效 &#125;, methods: &#123; pmd()&#123; if(this.timer!=null) return ; //如果timer为null，那么就直接调出函数 this.timer=setInterval(() =&gt; &#123; var start=this.msg.substr(0,1); var end=this.msg.substr(1); this.msg=end+start; // console.log(this.msg); &#125;, 500); &#125;, stoppmd()&#123; clearInterval(this.timer); this.timer=null; &#125; &#125;, &#125;) &lt;/script&gt;&lt;/body&gt; 学习到的一些知识以及遇到的一些问题 学习到的第一个就是箭头函数，通过使用es6中的箭头函数就可以解决this的问题，就不用重新去指定this 第二个就是return的使用，过去我只知道return只能够返回函数值，现在我知道了return不仅仅能够返回函数值，还能够提前跳出函数返回函数值，配合条件表达式就能很好的实现一些功能。 第三个就是可以设置一个变量将定时器函数传给这个变量，然后就可以通过比如清除函数来清空定时器之类的以及重新开启定时器。 遇到的一些问题一个就是对象中的this的指向问题，如果是对象中定义的方法，就可以直接通过this拿到当前对象，但是如果在对象中的方法中调用了其他方法，并在这个方法中写函数的话，那么这个时候的this就指向调用的外部函数，如果要重新让this指向对象就需要在自己定义的方法中声明this=this，或者使用es6中的箭头函数。 总结在这次的学习中学习到很多es6中的新知识，下次要系统的完整的去学习es6中的知识。]]></content>
      <tags>
        <tag>JS</tag>
        <tag>动画</tag>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue.js的学习（一）]]></title>
    <url>%2F2019%2F06%2F15%2Fvue-js%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最近开始学习现在最火的前端开发框架vue.js，这篇博客记录我的学习过程以及学习笔记。 vue.js的使用先去官网下载好vue.js的文件，然后在项目中引入js文件就可以开始使用vue来进行开发了，例如这样：1&lt;script src="./../../js/vue.js"&gt;&lt;/script&gt; 然后这是一个vue的基本模板：123456789101112131415&lt;body&gt; &lt;!-- 这是一个普通的块 --&gt; &lt;div v-cloak id="app"&gt; &lt;/div&gt; &lt;script src="./../../js/vue.js"&gt;&lt;/script&gt; &lt;script&gt; var vm=new Vue(&#123; el:'#app',// 在vue中对id为app的元素进行操作 data:&#123;//这里面写数据 &#125;, methods: &#123;//这里面写各种方法 &#125;, &#125;) &lt;/script&gt;&lt;/body&gt; 插值表达式和v-text在vue中想要对元素输入数值是非常简单的，不需要通过js或者jQuery拿到对象再通过函数进行传入数据，直接在dom元素中直接通过插值表达式就可以将vue中data中的值给到dom元素中。比如这样： 通过插值表达式123&lt;div v-cloak id="app"&gt; &#123;&#123;msg&#125;&#125;12314&lt;/div&gt; 123456789var vm=new Vue(&#123; el:'#app', data:&#123; //这里定义一个变量来我们想要的值 msg:'这是一个测试' &#125;, methods: &#123; &#125;, &#125;) 我们只需要通过插值表达式将我们创建的vue对象中的data中的变量写到dom元素中就可以将变量渲染出来。 可以看到我们定义的变量的值成功被渲染出来了 但是注意这样会有一个问题，就是在网速较慢的时候vue.js这个文件就会加载的比较慢，那么插值表达式就不会生效，而是直接将整个表达式当做字符串输出出来，那么这个时候我们可以通过给相应的dom元素加上v-cloak,然后再设置样式123[v-cloak] &#123;display: none;&#125; v-text使用v-text也可以将数据渲染到dom元素，但是用法不一样12 &lt;div v-text="msg+'123423'" id="app"&gt;&lt;/div&gt; 这样就可以实现了插值表达式一样的效果了。 注意：v-text 后面可以通过+来拼接字符串 v-html这个用法和v-text一致，作用也相似，只是v-html可以解析html标签，但是v-text不能 12&lt;div v-html="msg+'123423'" id="app"&gt;&lt;/div&gt; v-bindv-bind可以给dom元素绑定属性值 v-bind可以简写成: 123&lt;div v-cloak id="app"&gt; &lt;input type="button" value="这是一个按钮" v-bind:title="mtitle"&gt;&lt;/div&gt; 123456789var vm=new Vue(&#123; el:'#app', data:&#123; msg:'这是一个测试', mtitle:'这是一个测试' &#125;, methods: &#123; &#125;, &#125;) 可以看到，成功给这个按钮加上了一个我们在vue中定义的title v-bind:title=后面跟的是一个变量，所以后面也是可以拼接字符串的，许多vue中的属性也都是如此 v-onv-on与v-bind类似，只不过绑定的不是dom元素的属性，而是各种事件， v-on可以简写成@ 123&lt;div v-cloak id="app"&gt; &lt;button @click="mclick"&gt;这又是一个按钮&lt;/button&gt;&lt;/div&gt; 123456789101112var vm=new Vue(&#123; el:'#app', data:&#123; msg:'这是一个测试', mtitle:'这是一个测试' &#125;, methods: &#123; mclick () &#123; alert('单击了这个按钮'); &#125; &#125;,&#125;) 可以看到成功触发了我们自己定义的单击事件。 总结这篇博客记录学习了vue最简单初始的一些东西，一个小小的入门。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>VUE学习笔记</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chrome-调试大全]]></title>
    <url>%2F2019%2F06%2F15%2FChrome-%E8%B0%83%E8%AF%95%E5%A4%A7%E5%85%A8%2F</url>
    <content type="text"><![CDATA[引言 原文出处：&nbsp;&nbsp;&nbsp;&nbsp;Cayley的编程之路“工欲善其事，必先利其器” 没错，这句话个人觉得说的特别有道理，举个例子来说吧，厉害的化妆师都有一套非常专业的刷子，散粉刷负责定妆，眼影刷负责打眼影，各司其职，有了专业的工具才能干专业的事，这个灵感要来源于之前我想买化妆品时，店里的海报标语，由此联想到，如果你想在某个事情上做好，并且做的专业，那么你一定要把你的工具用好，这样才能事半功倍，我见过很多师兄师姐，写了很多代码，能够很快的完成工作，能够处理很多复杂的业务逻辑，但是对于浏览器的调试掌握的并不全面和深入，说说本姑娘吧，我的编程调试起源于自学滴前端课程，因为学习的时候看的都是基础的教学视频，对于调试也只是掌握了alert和console, 请大家别笑话，认真看完再说话，试问谁当初入门时候不是走的这条路呢，当你不再限于做静态页面，古老而经典的调试方式肯定不能帮你完成日常调试，日后我进入到了大公司去实习，才真正开始接触专业开发业务，开始跟着师兄和师傅一起上路，那时我才有了“js断点调试“的意识，开始一步步调试我的js代码~ 下面总结一下一些常用调试方法，这些方法能让开发的工作顺利并且高效，这里小女子拿出来总结一下，与各位程序猿同仁分享一下 ~ （此处应有掌声…… ^_^）一. 先来认识一下这些按钮 先来看这张图最上头的一行是一个功能菜单，每一个菜单都有它相应的功能和使用方法，依次从左往右来看 1.箭头按钮：用于在页面选择一个元素来审查和查看它的相关信息，当我们在Elements这个按钮页面下点击某个Dom元素时，箭头按钮会变成选择状态2.设备图标：点击它可以切换到不同的终端进行开发模式，移动端和pc端的一个切换，可以选择不同的移动终端设备，同时可以选择不同的尺寸比例，chrome浏览器的模拟移动设备和真实的设备相差不大，是非常好的选择 可选择的适配 3.Elements&nbsp;功能标签页：用来查看，修改页面上的元素，包括DOM标签，以及css样式的查看，修改，还有相关盒模型的图形信息，下图我们可以看到当我鼠标选择id 为lg_tar的div元素时，右侧的css样式对应的会展示出此id 的样式信息，此时可以在右侧进行一个修改，修改即可在页面上生效， 灰色的element.style样式同样可以进行添加和书写，唯一的区别是，在这里添加的样式是添加到了该元素内部，实现方式即：该div元素的style属性，这个页面的功能很强大，在我们做了相关的页面后，修改样式是一块很重要的工作，细微的差距都需要调整，但是不可能说做到每修改一点即编译一遍代码，再刷新浏览器查看效果，这样很低效，一次性在浏览器中修改之后，再到代码中进行修改 对应的样式 盒模型信息 同时，当我们浏览网站看到某些特别炫酷的效果和难做的样式时候，打开这个功能，我们即可看到别人是如何实现的，学会它这知识就是你的了，仔细钻研也会有意想不到的收获4.Console控制台：用于打印和输出相关的命令信息，其实console控制台除了我们熟知的报错，打印console.log信息外，还有很多相关的功能，下面简单介绍几个：a: 一些对页面数据的指令操作，比如打断点正好执行到获取的数据上，由于数据都是层层嵌套的对象，这个时候查看里面的key/value不是很方便，即可用这个指令开查看，obj的json string 格式的key/value，我们对于数据里面有哪些字段和属性即可一目了然 其他功能 b: 除了console.log还有其他相关的指令可用 console也有相关的API 5.Sources&nbsp;js资源页面：这个页面内我们可以找到当然浏览器页面中的js 源文件，方便我们查看和调试，在我还没有走出校园时候，我经常看一些大站的js代码，那时候其实基本都看不懂，但是最起码可以看看人家的代码风格，人家的命名方式，所有的代码都是压缩之后的代码，我们可以点击下面的{}大括号按钮将代码转成可读格式Sources Panel 的左侧分别是 Sources 和 Content scripts和Snippets 对应的源代码 格式化后的代码 关于打断点调试的内容，下面介绍，先来说一些，其他平时基本没人用但是很有用的小点，比如当我们想不起某个方法的具体使用时候，会打开控制台随意写一些测试代码，或者想测试一下刚刚写的方法是否会出现期待的样子，但是控制台一打回车本想换行但是却执行刚写的半截代码，所以推荐使用Sources下面的左侧的Sinppets代码片段按钮，这时候点击创建一个新的片段文件，写完测试代码后把鼠标放在新建文件上run，再结合控制台查看相关信息（新建了一个名叫：app.js的片段代码，在你的项目环境页面内，该片段可执行项目内的方法） 自己书写的片段 Content scripts 是 Chrome 的一种扩展程序，它是按照扩展的ID来组织的，这些文件也是嵌入在页面中的资源，这类文件可以读写和操作我们的资源，需要调试这些扩展文件，则可以在这个目录下打开相关文件调试，但是几乎我们的项目还没有相关的扩展文件，所以啥也看不到，平时也不需要关心这块 无结果 6.Network&nbsp;网络请求标签页：可以看到所有的资源请求，包括网络请求，图片资源，html,css，js文件等请求，可以根据需求筛选请求项，一般多用于网络请求的查看和分析，分析后端接口是否正确传输，获取的数据是否准确，请求头，请求参数的查看 所有的资源 以上我选择了All，就会把该页面所有资源文件请求下来，如果只选择XHR 异步请求资源，则我们可以分析相关的请求信息 请求的相关信息 打开一个Ajax异步请求，可以看到它的请求头信息，是一个POST请求，参数有哪些，还可以预览它的返回的结果数据，这些数据的使用和查看有利于我们很好的和后端工程师们联调数据，也方便我们前端更直观的分析数据 预览请求的数据 7.Timeline标签页可以显示JS执行时间、页面元素渲染时间，不做过多介绍8.Profiles标签页可以查看CPU执行时间与内存占用，不做过多介绍9.Resources标签页会列出所有的资源，以及HTML5的Database和LocalStore等，你可以对存储的内容编辑和删除 不做过多介绍10.Security标签页 可以告诉你这个网站的安全性，查看有效的证书等11.Audits标签页 可以帮你分析页面性能，有助于优化前端页面，分析后得到的报告 分析结果 二.Sources资源页面的断点调试1.如何调试：调试js代码，肯定是我们常用的功能，那么如何打断点，找到要调试的文件，然后在内容源代码左侧的代码标记行处点击即可打上一个断点 2.断点与 js代码修改看下面这张图，我在一个名为toggleTab的方法下打了两个断点，当开始执行我们的点击切换tab行为后，代码会在执行的断点出停下来，并把相关的数据展示一部分，此时可以在已经执行过得代码处，把鼠标放上去，即可查看相关的具体数据信息，同时我们可以使用右侧的功能键进行调试，右侧最上面一排分别是：暂停/继续、单步执行(F10快捷键)、单步跳入此执行块(F11快捷键)、单步跳出此执行块、禁用/启用所有断点。下面是各种具体的功能区 在代码中打断点 在当前的代码执行区域，在调试中如果发现需要修改的地方，也是可以立即修改的，修改后保存即可生效，这样就免去了再到代码中去书写，再刷新回看了 临时修改 3.快速进入调试的方法当我们的代码执行到某个程序块方法处，这个方法上可能你并没有设置相关的断点，此时你可以F11进入此程序块，但是往往我们的项目都是经过很多源代码封装好的方法，有时候进入后，会走很多底层的封装方法，需要很多步骤才能真正进入这个函数块，此时将鼠标放在此函数上，会出现相关提示，会告诉你在该文件的哪一行代码处，点击即可直接看到这个函数，然后临时打上断点，按F10或者点击右上角的第二个按钮即可直接进入此函数的断点处 4.调试的功能区域每一个功能区，都有它相关的左右，先来看一张图，它都有哪些功能 Call Stack调用栈：当断点执行到某一程序块处停下来后，右侧调试区的 Call Stack 会显示当前断点所处的方法调用栈，从上到下由最新调用处依次往下排列，Call Stack 列表的下方是Scope Variables列表可以查看此时局部变量和全局变量的值。图中可以看出，我们最先走了toggleTab这个方法，然后走到了一个更新对象的方法上，当前调用在哪里，箭头会帮你指向哪里，同时我们可以点击，调用栈列表上的任意一处，即可回头再去看看代码 但是若你想从新从某个调用方法出执行，可以右键Restart Frame， 断点就会跳到此处开头重新执行，Scope&nbsp;中的变量值也会依据代码从新更改，这样就可以回退来从新调试，错过的调试也可以回过头来反复查看 Breakpoints关于断点：所有当前js的断点都会展示在这个区域，你可以点击按钮用来“去掉/加上”此处断点，也可以点击下方的代码表达式，调到相应的程序代码处，来查看 XHR Breakpoints在XHR Breakpoints处，点击右侧的+号，可以添加请求的URL，一旦 XHR 调用触发时就会在 request.send() 的地方中断 DOM Breakpoints:可以给你的DOM元素设置断点，有时候真的需要监听和查看某个元素的变化情况，赋值情况，但是我们并是不太关心哪一段代码对它做的修改，只想看看它的变化情况，那么可以给它来个监听事件，这个时候DOM Breakpoints中会如图 当要给DOM添加断点的时候，会出现选择项分别是如下三种修改1.子节点修改2.自身属性修改3.自身节点被删除。选中之后，Sources Panel 中右侧的 DOM Breakpoints 列表中就会出现该 DOM 断点。一旦执行到要对该 DOM 做相应修改时，代码就会在那里停下来Event listener Breakpoints&nbsp;最后Event Listener 列表，这里列出了各种可能的事件类型。勾选对应的事件类型，当触发了该类型的事件的 JavaScript 代码时就会自动中断三.Post man你值得拥有的网络请求神器在我们的开发过程中，后端的接口都是由发起AJAX请求而获取到的相关数据，但是很多情况是我们的业务还没有做到那块时，后端的同学接口都已经准备好了，但是为了便于后期的工作，将接口请求的数据模拟访问，然后对接口联调很重要，也很方便，因为我们不可能把每个请求代码都写到文件里编译好了再去浏览器内查看，这时候可以安装一个post man网络请求插件，在谷歌应用商店下载，需要翻墙 该扩展程序使用非常简单，功能同时也非常强大，输入你的请求，选择好请求的method，需要请求参数的挨个填好，send之后，就可以看到返回的数据，这个小工具很利于我们的开发 完结写到这里这篇总结就结束了，也许有很多写的不到位的地方，也有一些专业用词不严谨的地方，希望看到的读者可以和我一起交流，我也非常乐意我的总结可以给 刚刚学会编程需要调试的同学受用，再此之前我一直在寻找一篇从头到尾的调试教学文章，我一直没有找到，要么是一点点的片段讲解，要么是专讲js断点调试，所以索性后来就直接看了 Chrome Developer Tools 的英文官方文档，并结合自己的一些小使用心得总结出此文，希望受到指点和修正 也希望可以帮助一些同学~]]></content>
      <tags>
        <tag>chrome</tag>
        <tag>转载</tag>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bootstrap4与Bootstrap3的区别]]></title>
    <url>%2F2019%2F06%2F14%2FBootstrap4%E4%B8%8EBootstrap3%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;刚接触bootstrap是学习的b3，但是b4已经出来了有一段时间了，而且试过b4之后我更加的喜欢b4，因为二者之间还是有很多差别的，所以这里介绍一下二者的差别。 Bootstrap4特点 新增网格层适配了移动端； 全面引入ES6新特性（重写所有JavaScript插件）； css文件减少了至少40%； 所有文档都用Markdown编辑器重写； 放弃对IE8的支持 Bootstrap3 Bootstrap4 Less Sass语言编写 4种栅格类 5种栅格类 使用px为单位 使用rem和em为单位（除部分margin和padding使用px） 使用push和pull向左右移动 偏移列通过offset-类设置 使用float的布局方式 选择弹性盒模型（flexbox） 栅格系统方面的区别Bootstrap3的4种栅格： 特小（col-xs-） 适配手机(&lt;768px) 小（col-sm-） 适配平板(≥768px) 中（col-md-） 适配电脑(≥992px) 大（col-lg-） 适配宽屏电脑(≥1200px) Bootstrap4的5种栅格： 特小（col-）(&lt;576px) 小（col-sm-）(≥576px) 中（col-md-）(≥768px) 大（col-lg-） (≥992px) 特大（col-xl-）（≥1200px） 一些类方面的区别img-circle与新版本中的rounded-circle老版本中img-circle只对图片 而新版本中rounded-circle对所有元素全部生效 媒体对象去除了media-left media-right 只有media-body 在其中会自适应 在body前写一个图片即使left,在body之后便是right display系列 / 偏移 / 外边距 / 内边距 用d-xx来设置display属性 偏移 不再使用 col-[尺寸]-offset-[x] 而是 offset-[尺寸]-[x] 内外边距可以使用m-5这种方式来书写例如：ml-3 pt-4 并且以上两项都可以通过设置对应分辨率来控制，如：ml-md-3 颜色badge-[] 对应 bs3 label可以设置outline比如btn-outline-success 新增flex类可以通过类来设置flex，名称与css样式的属性相同 导航栏这是bs3的tabs导航栏12345&lt;ul class="nav nav-tabs"&gt; &lt;li role="presentation" class="active"&gt;&lt;a href="#"&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li role="presentation"&gt;&lt;a href="#"&gt;Profile&lt;/a&gt;&lt;/li&gt; &lt;li role="presentation"&gt;&lt;a href="#"&gt;Messages&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; bs4是这样写：12345678&lt;ul class="nav nav-tabs"&gt; &lt;li class="nav-item"&gt; &lt;a class="nav-link active" href="#"&gt;Item 1&lt;/a&gt; &lt;/li&gt; &lt;li class="nav-item"&gt; &lt;a class="nav-link disabled" href="#" tabindex="-1" aria-disabled="true"&gt;Item 2&lt;/a&gt; &lt;/li&gt;&lt;/ul&gt; 可以看出导航的内容中不再需要添加role=&quot;presentation&quot;，并且bs4中使用nav-item来规定导航中的内容 导航栏中使用mr-auto ml-auto m-auto 来使导航栏中的内容居左/右/中]]></content>
      <tags>
        <tag>CSS</tag>
        <tag>Bootstrap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bootstrap的学习与使用]]></title>
    <url>%2F2019%2F06%2F13%2FBootstrap%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B8%8E%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实学习bootstrap是在写这篇博客很久之前的事情了，但是由于一些其他的很多事情，就没有第一时间写这篇博客，记录关于bootstrap中学习的一些事情。现在来写一下。bootstrap作为现在非常流行的响应式框架，必然是要学习的，起初我对bootstrap的了解并不是很多，只知道这算是一个框架，然后我就在网上看视频跟着学，然后等学习完了就清楚了，bootstrap其实是一个前端的css库，通过调用各种css演示可以很轻松的将一个响应式的网站给搭建起来，其实最另我没有想到的是使用bootstrap框架开发竟然如此便捷，甚至可以几乎不用自己写一点的css演示就可以有一个漂亮美观的页面，其实bootstrap要学的东西不多，大部分在文档中找到相应的使用方法就会用了,这篇博客记录一下我在学习之初所做的一些笔记。 字体图标的使用 bootstrap中有许多的字体图标，但是数量也是有限的，所以我们需要一些自定义的字体图标，图标网站有很多，我比较喜欢去阿里矢量图标库找 参考阿里矢量图标库给的使用文档所提供的三种使用图标的方法： 第一种：Unicode 引用Unicode 是字体在网页端最原始的应用方式，特点是： 兼容性最好，支持 IE6+，及所有现代浏览器。 支持按字体的方式去动态调整图标大小，颜色等等。 但是因为是字体，所以不支持多色。只能使用平台里单色的图标，就算项目里有多色图标也会自动去色。 注意：新版 iconfont 支持多色图标，这些多色图标在 Unicode 模式下将不能使用，如果有需求建议使用symbol 的引用方式 Unicode 使用步骤如下： 第一步：拷贝项目下面生成的 @font-face123456789@font-face &#123; font-family: 'iconfont'; src: url('iconfont.eot'); src: url('iconfont.eot?#iefix') format('embedded-opentype'), url('iconfont.woff2') format('woff2'), url('iconfont.woff') format('woff'), url('iconfont.ttf') format('truetype'), url('iconfont.svg#iconfont') format('svg');&#125; 第二步：定义使用 iconfont 的样式1234567.iconfont &#123; font-family: "iconfont" !important; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;&#125; 第三步：挑选相应图标并获取字体编码，应用于页面1&lt;span class="iconfont"&gt;&amp;#x33;&lt;/span&gt; “iconfont” 是你项目下的 font-family。可以通过编辑项目查看，默认是 “iconfont”。 第二种：font-class 引用font-class 是 Unicode 使用方式的一种变种，主要是解决 Unicode 书写不直观，语意不明确的问题。 与 Unicode 使用方式相比，具有如下特点： 兼容性良好，支持 IE8+，及所有现代浏览器。 相比于 Unicode 语意明确，书写更直观。可以很容易分辨这个 icon 是什么。 因为使用 class 来定义图标，所以当要替换图标时，只需要修改 class 里面的 Unicode 引用。 不过因为本质上还是使用的字体，所以多色图标还是不支持的。使用步骤如下： 第一步：引入项目下面生成的 fontclass 代码：1&lt;link rel="stylesheet" href="./iconfont.css"&gt; 第二步：挑选相应图标并获取类名，应用于页面：1&lt;span class="iconfont icon-xxx"&gt;&lt;/span&gt; “ iconfont” 是你项目下的 font-family。可以通过编辑项目查看，默认是 “iconfont”。 第三种：Symbol 引用这是一种全新的使用方式，应该说这才是未来的主流，也是平台目前推荐的用法。相关介绍可以参考这篇文章 这种用法其实是做了一个 SVG 的集合，与另外两种相比具有如下特点： 支持多色图标了，不再受单色限制。 通过一些技巧，支持像字体那样，通过 font-size, color 来调整样式。 兼容性较差，支持 IE9+，及现代浏览器。 浏览器渲染 SVG 的性能一般，还不如 png。使用步骤如下： 第一步：引入项目下面生成的 symbol 代码：1&lt;script src="./iconfont.js"&gt;&lt;/script&gt; 第二步：加入通用 CSS 代码（引入一次就行）：123456789&lt;style&gt;.icon &#123; width: 1em; height: 1em; vertical-align: -0.15em; fill: currentColor; overflow: hidden;&#125;&lt;/style&gt; 第三步：挑选相应图标并获取类名，应用于页面：123&lt;svg class=&quot;icon&quot; aria-hidden=&quot;true&quot;&gt; &lt;use xlink:href=&quot;#icon-xxx&quot;&gt;&lt;/use&gt;&lt;/svg&gt; 这里用第二种方法与第三种方法做一个演示：可以看到无论用哪种方法都能成功使用到字体图标，既然symbol的方法使未来趋势那就尽量多使用symbol吧，毕竟这种方式还可以支持多色图标 有一件事情要注意，就是在最开始的时候我通过symbol方式去设置图标的颜色发现并不成功，后面查阅资料后发现是因为当我在下载图标代码的时候这个图标本身使带有颜色的，这里有两种办法： 打开js文件，将fill=&quot;#......&quot;删除。 到iconfont.cn上，全选项目中的文件，应用批量操作–&gt;批量去色 当然啦，还有其他的特别多的图标库，像font awesome这种专门为bootstrap设计的之类的，看个人喜好用什么，这里就介绍了引用阿里矢量图标库中的图标 选项卡的适配 当页面的宽度缩小到一定的程度的时候，选项卡中的选项就会换行，有时这不是我们想要的效果，我们想要的效果是当所有选项的宽度之和大于外部的宽度的时候它就会出现一个横向的滚动条 那我们就可以通过overfow ：auto来实现，但是只设置overflow很显然是不能达到这种效果的，因为这个时候当我们把页面的宽度缩小选项卡的头部会进行换行 所以我们还需要使它不进行换行，因为b4相较于b3进行了重写，不再使用float布局而是使用flex布局，所以我们可以通过flex来进行设置不换行，先设置为flex布局，再设置为不换行，这时候就实现了我们想要的效果 1234567891011121314151617181920212223242526272829&lt;style&gt; a &#123; padding-right: 100px !important; &#125; .nav-tabs &#123; /* width: 400px; */ padding-bottom: 1px; margin-top: 0; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;ul class="nav nav-tabs d-flex overflow-auto flex-nowrap"&gt; &lt;li class="nav-item"&gt; &lt;a href="#" class="nav-link active"&gt;Active&lt;/a&gt; &lt;/li&gt; &lt;li class="nav-item"&gt; &lt;a href="#" class="nav-link"&gt;Link&lt;/a&gt; &lt;/li&gt; &lt;li class="nav-item disabled"&gt; &lt;a href="#" class="nav-link"&gt;Disabled&lt;/a&gt; &lt;/li&gt; &lt;li class="nav-item"&gt; &lt;a href="#" class="nav-link active"&gt;Active&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt; 再来看一下实现的效果：成功实现效果！ 一些小笔记 bootstrap自适应的底层是用媒体查询做的通过媒体查询来定义不同分辨率下容器的不同宽度，以及栅栏系统的宽度。 bootstrap是组件化开发，有很多的组件可以使用，包括像各种定义好样式的按钮，各种按钮可以用bbg来生成。 bootstrap中的容器container与container-fluid的作用就是当成一个容器，这个容器自带了响应式的布局。这两个容器的区别就是一个是固定的宽度，一个是百分之百的宽度，container用的比较多.container拥有15px的左右内边距，可以用row来抵消。 多套轮播图的处理在响应式的布局中可能会有两套轮播图，一套显示在pc端，一套显示在手机端，pc端的图片用背景图来处理，只显示中间的那一部分，只有在宽度在拉长的时候会把边上的纯色部分显示出来处理方式是通过 background:no-repeat center center 来将背景图片居中然后通过background-size:cover来让图片显示HTML元素自定义属性的方法是通过data来设置，比如设置 data-name=”hsl” 属性，然后通过jQuery中的data(“name”)就可以拿到我们想要的数据，然后通过 data(“name”,”sss”)就可以设置属性然后就可以通过这种方法来给标签设置属性，再通过jQuery动态的设置图片 在bootstrap中有很多的全局样式，能用bootstrap自带的样式就用自带的（比如颜色） 补充一个css样式的用法，设置背景颜色可以设置trans什么的来继承父级的颜色 使用bootstrap的时候，在布局的时候主要是使用栅格系统，就可以很轻松的将一大块内容分割成我们想要的部分。 bootstrap中的徽章可以用来做圆角边框并且自带颜色 bootstrap中的媒体对象可以用来处理图片加文字的并排情况 在容器栅格布局中尽量不要使用margin，而是使用padding，因为本身12份已经占满了，没有多余的空间来设置margin 使用栅栏系统的时候当满了12列，剩下的就会换行，比如有4个col-md-6,那么这里就会占满两行。 栅格系统中的内容居中的方法有很多，比如可以用text-align或者是flex布局，对于图片来说的话可以使用margin auto 来设置要注意的一点是图片是一个行内元素，不能直接设置上下边距，如果要设置则需要将其设置为块级元素或者是行内块级元素 如果要给整块内容添加超链接直接在内容最外层添加a标签即可 在很多时候可以不用设置高度，而是可以直接通过设置padding值来让内容撑开 在使用bootstrap进行响应式开发的时候一定要注意最外层应该不要设置固定高度，否则在自适应的时候可能会出现问题 通过full-left可以将本来占一行的元素浮动到一行,b4中使用offset-来设置向左或是向右，通过设置display为inline-block也能实现这样的效果 总结学习总结是一个漫长的过程，这篇博客还会持续记录一些问题。]]></content>
      <tags>
        <tag>CSS</tag>
        <tag>Bootstrap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Echarts中响应式的完善]]></title>
    <url>%2F2019%2F06%2F13%2Fecharts%E4%B8%AD%E5%93%8D%E5%BA%94%E5%BC%8F%E7%9A%84%E5%AE%8C%E5%96%84%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前面在学习echarts的时候，发现echarts中是自带响应式的功能的，但是这个响应式的功能和我之前学习的bootstrap有很大的区别，bootstrap中的响应式是会随着网页大小的改变而动态的改变网页的布局以及大小，但是echarts中的响应式虽然也是响应式，但是却没有bootstrap中那样的动态能力，只能是在网页加载或者刷新的时候网页的大小是多大就渲染相应的布局以及大小，虽然也能实现响应式的功能，但是我觉得这在bootstrap中使用的话会很不协调，所以我决定进行一些调整，让echarts中的响应式也能像bootstrap中那样。 开始构建思路起初我以为echarts中的响应式也会像bootstrap中的那样，因为在官网的演示的例子当中就能实现类似的效果，但是我后面发现，那只是官方为了方便演示而加了那样的功能，但是实际上是没有那样的效果的，我开始打算是按照自己的思路写，但是发现遇到很多问题，以及不知道echarts中的定位的实现机制是怎么样的，后面我就查看了一下官方给的示例中的一些代码的变化，随后推断出echarts中的百分比居中是通过对canvas画布的宽度来进行居中的，其他定位也是类似，所以就应该动态的变化canvas画布的宽度以及他父级的宽度，那么就按照这个思路来实现一下吧。 直接看结果 这一部分是用来控制响应式的代码： 123456789101112131415161718192021222324252627282930313233343536$(window).resize(function()&#123; // 先获取到页面中和画布部分有关的元素 // 以及要拿到响应式父级的宽度，并将画布也设置成一样的宽度 var $tw=$('#test').width(); var $fc=$('#test&gt;div:first'); var $canvas=$fc.children(0); $fc.css(&#123; "width":$tw+'px', &#125;); $canvas.css(&#123; "width":$tw+'px', &#125;); $canvas.attr(&#123; "width":$tw*1.25, &#125;) // 然后随着窗口大小的变化去设置图表内容的位置 $mychart.setOption(&#123; media:[ &#123; query:&#123; // maxWidth: 690 &#125;, option:&#123; series:[ &#123; type:'pie', // 这里最好用宽度乘小数来表示，到时候转化为百分比的时候比较方便 center:[$tw*0.5,"50%"] &#125;, ], &#125; &#125;, ] &#125;); &#125;) 这一部分是echarts配置部分的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647var $mychart = echarts.init($('#test')[0]); var option=&#123; baseOption:&#123; legend:&#123;&#125;, tooltip:&#123;&#125;, dataset:&#123; source:[ ['物品', '销量1', '销量2'], ["衬衫", '5', '20'], ['羊毛衫', '30', '40'], ['袜子', '60', '80'], ['裤子', '60', '50'] ] &#125;, series:[ &#123; type:'pie', // center:['50%','50%'] &#125;, ], &#125;, media:[ &#123; query:&#123; // maxWidth: 690 &#125;, option:&#123; legend:&#123; left: ($tw-280)*0.5, &#125;, series:[ &#123; type:'pie', center:['50%','50%'] &#125;, ], &#125; &#125;, ] &#125; $mychart.setOption(option); 这里可以直接先引入响应式部分的代码，再写配置部分的代码。 我所遇到的坑&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在一开始的时候我无从下手，因为没有接触过类似的东西，但是我想了一整天慢慢的整明白了，大概意思就是这他的位置是在生成的时候就固定住了，想要改变就必须通过动态的去设置他的位置，就需要用到resize方法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当时我遇到的第一个比较大的坑就时在我设置canvas宽度的时候我发现好像直接修改style里面的width会导致画布里面的内容失真，使得我在很长一段时间内认为不应该从这里下手，直到我查看了官方示例的代码里的元素变化情况之后我才发现原来是canvas画布本身其实还有一个width属性,且这个属性的值基本上是恒等于style里面的那个的1.25倍，那么真相就大白了，我又开始从这方面着手了。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当时我遇到的第二个比较大的坑就是我认为我只要动态的改变容器的宽度以及canvas画布的宽度，然后再把图表设置为居中或者将center:[&#39;50%&#39;,&#39;50%&#39;]就可以实现一直居中了，后面经过测试没有效果，百思不得其解，不知道我是哪里出了问题，以为是不是哪里写错了，后面我把百分比的位置改为固定的位置之后就发现其实是可以变化的，那么我就推测其实他里面的百分比的位置所算的宽度并不是当前容器或者canvas的宽度，而是在画布生成时就已经固定了，所以我就改成了我现在所用的这种方法。 总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽然成功的实现了我想要的效果，但是还是感觉不是很满意，还应该继续封装以便重复调用，并且解决这个问题花的时间有点多，思维还是不够灵敏，要继续努力。]]></content>
      <tags>
        <tag>JS</tag>
        <tag>Echarts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Echarts.js的学习]]></title>
    <url>%2F2019%2F06%2F08%2F%E5%85%B3%E4%BA%8Eecharts-js%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最近在做期末的课程设计的时候需要做一个后台管理界面，所以需要用到一些图标插件，经过搜索我发现有好多的图标插件，最终我决定要使用echarts.js，其中一个很重要的原因就是它是有国内的百度的团队主导开发的一个项目，所以有中文文档，方便我查阅，文档查阅请看这里 快速上手echarts.js根据官方文档，上手使用echarts.js首先需要先引入js文件，js文件可是直接在官方网站直接下载，在引入js文件之后我们就可以开始使用了，使用之前我们要先创建一个容器，例如：&lt;div class=&quot;container&quot; id=&quot;test&quot; style=&quot;height: 400px;&quot;&gt;接着之后的就是进行初始化，var $mychart=echarts.init($(&#39;#test&#39;)[0]);注意，因为我这里是在jQuery中进行初始化的，但是自带的初始化方法必须传一个原生js对象，所以需要将jQuery对象转化为js对象 然后就可以开始制作图标了：12345678910111213141516171819202122$(function()&#123; var $mychart=echarts.init($('#test')[0]); var option=&#123; title:&#123; text:'这是一个测试的图表' //这是图表的标题 &#125;, tooltip:&#123;&#125;, legend:&#123; data:['销量'] //这个是告诉你表格上所有的数据的类型的那种，也就是右上角的那种东西，现在先这么理解好了，到时候查了文档再详细介绍。 &#125;, xAxis:&#123; data:["衬衫","羊毛衫","袜子"] //这个是x轴坐标，也就是横坐标的值 &#125;, yAxis:&#123;&#125;, series:[&#123; name:'销量', type:'bar', data:[5,30,60] //这里是第一个系列的值 &#125;] &#125;; $mychart.setOption(option); //将图表的设置应用 &#125;) 然后来看一下效果： 再来看看一个官方文档中给出的一个南丁格尔图我通过官方给出的在线编辑工具，一个个试了一下都是什么作用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647option = &#123; backgroundColor: '#2c343c', //这个是设置整个图表的背景颜色的。 visualMap: &#123; //通过visualmap组件来进行明暗度的映射达到一种有层次感的感觉 show: false, //将这个设置为true的话就会出来一个可以选择的小柱子 min: 60, //南丁格尔图每个区域的颜色过渡的最小值 max: 600, //南丁格尔图每个区域颜色过渡的最大值 inRange: &#123; colorLightness: [0, 1] //设置整个南丁格尔图的颜色的亮度 &#125; &#125;, series : [ &#123; name: '访问来源', type: 'pie', radius: '55%', //设置整个图的大小 data:[ &#123;value:235, name:'视频广告'&#125;, //通过键值对的形式来设置数值 &#123;value:274, name:'联盟广告'&#125;, &#123;value:310, name:'邮件营销'&#125;, &#123;value:335, name:'直接访问'&#125;, &#123;value:400, name:'搜索引擎'&#125; ], roseType: 'angle', //将普通的饼图切换成南丁格尔图 label: &#123; normal: &#123; textStyle: &#123; color: 'rgba(255, 255, 255, 0.3)' //文本颜色 &#125; &#125; &#125;, labelLine: &#123; normal: &#123; lineStyle: &#123; color: 'rgba(255, 255, 255, 0.3)' //线的颜色 &#125; &#125; &#125;, itemStyle: &#123; normal: &#123; color: '#c23531', //设置整体的颜色 shadowBlur: 300, //设置阴影的模糊度 shadowColor: 'rgba(0, 0, 0, 0.5)' 设置阴影的颜色 &#125; &#125; &#125; ]&#125;; 再来看一下官方的效果图：可以看到这个真的很酷！ 异步加载数据需要实现异步加载数据其实也很简单，只要利用相关方法就可以轻松实现，比如利用jQuery中的延迟对象中的 done()这个方法就可以轻松实现。以下是官方文档中的一个异步加载数据的实例：1234567891011121314151617181920212223242526272829303132333435var myChart = echarts.init(document.getElementById('main'));// 显示标题，图例和空的坐标轴myChart.setOption(&#123; title: &#123; text: '异步数据加载示例' &#125;, tooltip: &#123;&#125;, legend: &#123; data:['销量'] &#125;, xAxis: &#123; data: [] &#125;, yAxis: &#123;&#125;, series: [&#123; name: '销量', type: 'bar', data: [] &#125;]&#125;);// 异步加载数据$.get('data.json').done(function (data) &#123; // 填入数据 myChart.setOption(&#123; xAxis: &#123; data: data.categories &#125;, series: [&#123; // 根据名字对应到相应的系列 name: '销量', data: data.data &#125;] &#125;);&#125;); 以上例子就是先加载出空的图表，等待数据加载完毕就显示数据。 使用dataset来管理数据我们前面的例子都是普通的数据格式，设置在各个series当中，在数据共享方面存在不足，使用dataset就可以解决这些问题，下面是一个简单的dataset的例子：1234567891011121314151617181920212223242526var option=&#123; title:&#123; text:'这是一个测试的图表' &#125;, tooltip:&#123;&#125;, legend:&#123;&#125;, dataset:&#123; source:[ ['销量','销量1','销量2'], ["衬衫",'5','20'], ['羊毛衫','30','40'], ['袜子','60','80'], ['裤子','60','50'] ] &#125;, // 声明一个 X 轴，类目轴（category）。默认情况下，类目轴对应到 dataset 第一列。 xAxis:&#123; type: 'category' &#125;, yAxis:&#123;&#125;, // 声明多个 bar 系列，默认情况下，每个系列会自动对应到 dataset 的每一列。 series:[ &#123;type: 'bar'&#125;, &#123;type: 'bar'&#125;, ], &#125;; 通过以上代码也实现了一个简单的图表，但是好处在于数据可以共享，不用重复写，而且我个人更加喜欢这种方式来写数据。 按行还是按列映射dataset默认是按列来进行映射，通过比较两种映射的方法，我个人还是更加习惯喜欢默认的按列进行映射,这里就不过多的对二者的差异进行比较。想要详细了解可以前去文档进行查询。 维度 常用图表所描述的数据大部分是“二维表”结构，上述的例子中，我们都使用二维数组来容纳二维表。现在，当我们把系列（series）对应到“列”的时候，那么每一列就称为一个“维度（dimension）”，而每一行称为数据项（item）。反之，如果我们把系列（series）对应到表行，那么每一行就是“维度（dimension）”，每一列就是数据项（item）。 维度可以有单独的名字，便于在图表中显示。维度名（dimension name）可以在定义在 dataset 的第一行（或者第一列）。例如上面的例子中，’score’、’amount’、’product’ 就是维度名。从第二行开始，才是正式的数据。dataset.source 中第一行（列）到底包含不包含维度名，ECharts 默认会自动探测。当然也可以设置 dataset.sourceHeader: true 显示声明第一行（列）就是维度，或者 dataset.sourceHeader: false 表明第一行（列）开始就直接是数据。 维度的定义，也可以使用单独的 dataset.dimensions 或者 series.dimensions 来定义：第一种是在dataset中设置：12345678910111213var option1 = &#123; dataset: &#123; dimensions: [ &#123;name: 'score'&#125;, // 可以简写为 string，表示维度名。 'amount', // 可以在 type 中指定维度类型。 &#123;name: 'product', type: 'ordinal'&#125; ], source: [...] &#125;, ...&#125;; 第二种是在series中设置：1234567891011121314151617181920212223242526272829var option1 = &#123; dataset: &#123; dimensions: [ &#123;name: 'score'&#125;, // 可以简写为 string，表示维度名。 'amount', // 可以在 type 中指定维度类型。 &#123;name: 'product', type: 'ordinal'&#125; ], source: [...] &#125;, ...&#125;;var option2 = &#123; dataset: &#123; source: [...] &#125;, series: &#123; type: 'line', // 在系列中设置的 dimensions 会更优先采纳。 dimensions: [ null, // 可以设置为 null 表示不想设置维度名 'amount', &#123;name: 'product', type: 'ordinal'&#125; ] &#125;, ...&#125;; 大部分时候都不需要手动去设置维度类型。但是如果因为数据为空之类原因导致判断不足够准确时，可以手动设置维度类型。具体有哪些类型可以查询文档 数据到图形的映射（encode） encode 声明的基本结构如下，其中冒号左边是坐标系、标签等特定名称，如 ‘x’, ‘y’, ‘tooltip’ 等，冒号右边是数据中的维度名（string 格式）或者维度的序号（number 格式，从 0 开始计数），可以指定一个或多个维度（使用数组）。通常情况下，下面各种信息不需要所有的都写，按需写即可。 使用encode可以将数据按照需要映射到图形。 encode涉及到的知识很多，我们现在来看encode的一个简单的应用。123456789101112131415161718192021222324252627282930313233343536373839var option2=&#123; // 设置dataset dataset:&#123; // 设置好源数据，默认是以列的方式来进行映射，所以要注意好顺序 source:[ // 通过一个二维数组来设置数据 ['物品','销量1','销量2'], ["衬衫",'5','20'], ['羊毛衫','30','40'], ['袜子','60','80'], ['裤子','60','50'] ] &#125;, xAxis:&#123;&#125;, // 这里将图表设置为横向的柱状图 yAxis:&#123;type:'category'&#125;, // 设置了两个系列 series:[ &#123; type:'bar', // 通过encode来进行映射 encode:&#123; // 将销量映射到x轴 x:'销量1', // 将物品的类型映射到y轴 y:'物品', // 这里也可以通过索引来进行映射，就可以实现动态变更数据，但是要注意的一件事是索引是从0开始的。 tooltip: [1, 2] //也可以映射tooltip，现在还不知道是干什么的 &#125; &#125;, &#123; type:'bar', encode:&#123; x:'销量2', y:'物品', &#125; &#125; ] &#125; 这里还看一下效果： encode也还有很多其他的注意事项，这里就不一一介绍了，有需要可以查询文档 数据的各种格式 常见的图表中，保存数据的方式是通过二维表的形式来保存的，广为熟知的数据图表表格软件也都是通过二维表，这些数据也都可以转化为json格式，网络上有很多互相转换的方法，如果转化为csv格式的文件，那么可以使用一些 csv 工具如 dsv 或者 PapaParse 将 csv 转成 JSON。 在js中比较直观常见的二维格式就是二维数组了，之前前面的所有例子都是通过二维数组来存储数据的 除了二维数组之外比较常见的二维形式就是对象数组了，也就是键值对的形式，比如上面的例子可以这样写： 1234567source:[ // 按行的形式 &#123;'物品:'衬衫','销量1':5,'销量2':20&#125;, &#123;'物品:'羊毛衫','销量1':30,'销量2':40&#125;, &#123;'物品:'袜子','销量1':60,'销量2':80&#125;, &#123;'物品:'裤子','销量1':60,'销量2':50&#125;,] 还有按列的形式这里就不演示了 个人觉得二维数组的形式写起来会更加的简单方便一些，所以我更加的喜欢二维数组的方式 设置多个datase（设置多个source）可以同时设置多组数据，然后决定使用哪一组数据：12345678910111213141516171819var option = &#123; dataset: [&#123; // 序号为 0 的 dataset。 source: [...], &#125;, &#123; // 序号为 1 的 dataset。 source: [...] &#125;, &#123; // 序号为 2 的 dataset。 source: [...] &#125;], series: [&#123; // 使用序号为 2 的 dataset。 datasetIndex: 2 &#125;, &#123; // 使用序号为 1 的 dataset。 datasetIndex: 1 &#125;]&#125; 其他事项 根据官方文档，现在并不是所有的图表类型都支持dataset 官方还给了一个多个图表共享一个dataset的例子，并且有联动效果，目前还看不懂是怎么会是 想要了解更多可以前往官方文档进行查看 图表组件echarts中有很多组件，现在就按照官方文档中的示例来先介绍一下dataZoom组件，这个组件可以将图表进行放大缩小以及拖动查看，还是很有用的，现在按照官方文档中的例子来试一试:** 先是没有datazoom的散点图123456789101112131415var option3=&#123; xAxis:&#123; type:'value', &#125;, yAxis:&#123; type:'value' &#125;, series:[ &#123; name:'test', type:'scatter', //设置这个为散点图 data: [["14.616","7.241","0.896"],["3.958","5.701","0.955"],["2.768","8.971","0.669"],["9.051","9.710","0.171"],["14.046","4.182","0.536"],["12.295","1.429","0.962"],["4.417","8.167","0.113"],["0.492","4.771","0.785"],["7.632","2.605","0.645"],["14.242","5.042","0.368"]] &#125; ] &#125; 现在加上datazoom组件12345dataZoom: [&#123; // 这个dataZoom组件，默认控制x轴。 type: 'slider', // 这个 dataZoom 组件是 slider 型 dataZoom 组件 start: 10, // 左边在 10% 的位置。 end: 60 // 右边在 60% 的位置。 &#125;], 来看下效果图：可以看出现在有了一个可以拖动的条，但是还不能进行缩放 如果要可以进行缩放就需要再加上一个组件12345&#123; // 这个dataZoom组件，也控制x轴。 type: 'inside', // 这个 dataZoom 组件是 inside 型 dataZoom 组件 start: 10, // 左边在 10% 的位置。 end: 60 // 右边在 60% 的位置。 &#125; 加上以后就可以进行缩放了**这里只以x轴为例子进行了演示，y轴也是一样的方法。 响应式图表echarts中支持响应式图表，也是通过类似于媒体查询来实现的，这十分有用，因为我们的项目可能是用bootstrap来制作，那么在这种情况下响应式是必不可少的。 echarts组件的定位和布局echarts中有两种定位方式： left/right/top/bottom/width/height 定位方式：例如：{left: 23, height: 400}，可以不写单位，还可以写成百分比的形式，{left: 30%, height: 40%}可以设置 left: &#39;center&#39;，表示水平居中。可以设置 top: &#39;middle&#39;，表示垂直居中。 在横向，left、right、width 三个量中，只需两个量有值即可，因为任两个量可以决定组件的位置和大小，例如 left 和 right 或者 right 和 width 都可以决定组件的位置和大小。 纵向，top、bottom、height 三个量，和横向类同不赘述。 center / radius 定位方式：center是一个数组，表示 [x, y]，其中，x、y可以是『绝对值』或者『百分比』，含义和前述相同。radius是一个数组，表示 [内半径, 外半径]，其中，内外半径可以是『绝对值』或者『百分比』，含义和前述相同。在自适应容器大小时，百分比设置是很有用的。 图表的方向在echarts中有一些图表可能会很长，在pc端可以较好的显示，在移动端就不一定能够很好的显示了，所以就需要设置他们的方向：横纵向布局的设置，一般在『组件』或者『系列』的 orient 或者 layout 配置项上，设置为 &#39;horizontal&#39; 或者 &#39;vertical&#39;。 实现响应式前面有说到echarts中实现响应式是通过类似媒体查询来实现的，这就是echarts中的 Media Query在option中Media Query 的基本格式：123456789101112131415161718192021222324252627282930option = &#123; baseOption: &#123; // 这里是基本的『原子option』。也就是用来设置一些通用的基本的与响应式无关的选项 title: &#123;...&#125;, legend: &#123;...&#125;, series: [&#123;...&#125;, &#123;...&#125;, ...], ... &#125;, media: [ // 这里定义了 media query 的逐条规则。 &#123; query: &#123;...&#125;, // 这里写规则。 option: &#123; // 这里写此规则满足下的option。 legend: &#123;...&#125;, ... &#125; &#125;, &#123; query: &#123;...&#125;, // 第二个规则。 option: &#123; // 第二个规则对应的option。 legend: &#123;...&#125;, ... &#125; &#125;, &#123; // 这条里没有写规则，表示『默认』， option: &#123; // 即所有规则都不满足时，采纳这个option。 legend: &#123;...&#125;, ... &#125; &#125; ]&#125;; query的格式：12345&#123; minWidth: 200,//设置响应式的最小宽度，表示大于200px就是这个option maxHeight: 300,//设置响应式的最大宽度 minAspectRatio: 1.3//设置响应式的长宽比&#125; 多个query被满足时的优先级后面的覆盖前面的 默认 query：如果 media 中有某项不写 query，则表示『默认值』，即所有规则都不满足时，采纳这个option。 容器大小实时变化时的注意事项如果要一直动态的改变容器的大小并且让图表的大小也随之改变，那就必须注意query option中出现的配置项，其他query option也必须出现，防止出现回不去的情况。 关于Echarts响应式还有一件需要注意的事情Echarts.js中虽然有类似响应式的支持，但是这与bootstrap中的响应式有很大不同，echarts中自带的响应式不能像bootstrap中那样随着窗口大小的改变而实时的更改图表的位置以及大小，只有在网页刷新的时候或者再一次setoption的时候才会有位置或者大小的变更，虽然这也能达到响应式的目的，但是我觉得这在bootstrap中会显得十分的不协调，所以我针对这一方面进行了改进，下篇文章进行详细介绍。 echarts中的事件和行为echarts中自带了很多的事件和行为，我们可以通过on的方法来绑定。例如下面的代码：12345//这是一个echarts中的单击事件，单击图表之后在控制台打印数据myChart.on('click', function (params) &#123; // 控制台打印数据的名称 console.log(params.name);&#125;); echarts中还有很多的事件，这里就不一一介绍了，这里再说一下鼠标事件返回的参数params,这个参数是一个图形的数据信息对象，格式如下：12345678910111213141516171819202122232425&#123; // 当前点击的图形元素所属的组件名称， // 其值如 'series'、'markLine'、'markPoint'、'timeLine' 等。 componentType: string, // 系列类型。值可能为：'line'、'bar'、'pie' 等。当 componentType 为 'series' 时有意义。 seriesType: string, // 系列在传入的 option.series 中的 index。当 componentType 为 'series' 时有意义。 seriesIndex: number, // 系列名称。当 componentType 为 'series' 时有意义。 seriesName: string, // 数据名，类目名 name: string, // 数据在传入的 data 数组中的 index dataIndex: number, // 传入的原始数据项 data: Object, // sankey、graph 等图表同时含有 nodeData 和 edgeData 两种 data， // dataType 的值会是 'node' 或者 'edge'，表示当前点击在 node 还是 edge 上。 // 其他大部分图表中只有一种 data，dataType 无意义。 dataType: string, // 传入的数据值 value: number|Array // 数据图形的颜色。当 componentType 为 'series' 时有意义。 color: string&#125; **echarts中事件与行为更为详细的信息可以查阅相关的文档，这里就不详细说明了 总结到这里就介绍了echarts中的一些基本的概念以及信息，还不是特别全面，算是稍微认识了一下echarts，echarts的功能十分的强大可自定义的程度也是非常的高，官方文档有非常详细的配置项介绍，如果感兴趣的话可以慢慢去学习。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Echarts</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>Echarts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于animate.css与wow.js的使用]]></title>
    <url>%2F2019%2F06%2F05%2F%E5%85%B3%E4%BA%8Eanimate-css%E4%B8%8Ewow-js%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在实际的网站开发过程中或多或少的都会使用到一些动画功能，所以学会使用动画是必不可少的，前面我们已经学习过了jQuery中的一些动画相关方面的方法，并且学习了自定义动画，可以帮我们做出我们想要的动画，当时使用这些动画还是不够简单方便，其实在网上已经有很多动画相关的扩展，我们只需要调用即可简单的实现一些常用的动画，这次就来学习一下animate.css以及wow.js的使用。 animate.css animate.css是一款常见的css库，包含了很多的常见动画，使用起来也是十分的简单方便，只需要将animate.css文件引入到我们的项目中即可&lt;link rel=&quot;stylesheet&quot; href=&quot;./../../css/animate.css/animate.css&quot;&gt; 引入进来以后我们想要使用动画也是十分的简单，只需要给我们想要添加动画的元素添加上类即可，例如：1&lt;div class="col-md-6 p-5 bg-danger animated bounce"&gt; 这样我们就很轻松的给这个元素加上了一个弹起动画 那么我们要如何给动画设置一些属性呢，比如说像延时，动画时间之类的呢一种方法是通过css样式去覆盖原有的属性:例如： 1&lt;div class="col-md-6 p-5 bg-danger animated bounce" style="animation-delay: 5s;animation-duration: 3s"&gt; 以下是常用的设置： animation-duration 规定完成动画所花费的时间，以秒或毫秒计。 animation-timing-function 规定动画的速度曲线。 animation-delay 规定在动画开始之前的延迟。 animation-iteration-count 规定动画应该播放的次数。 通过这种办法我们就可以对动画进行一些设置 那么还有一种办法就是使用js对其进行设置在网上有一款js插件就是基于animate.css的js动画插件，用法其实是和animate.css是差不多的，但是可以直接设置动画相关的一些属性，使用起来可能会稍微方便那么一点点，因为不用特地再去设置css。 wow.js上面提到的那款js插件就是wow.js，它是基于animate.css制作的，所以使用它需要在网页中引入animate.css，用法与animate.css相似： 使用之前需要先进行初始化：new WOW().init(); 给需要设置动画的元素添加上wow、animate类即可添加上动画，此处的animate指的是animate.css中支持的动画名称。例如：1&lt;div class="col-md-6 p-5 bg-light wow fadeInLeft"&gt; 通过这样的设置就可以轻松的将动画轻松的应用到元素上面 通过wow.js对动画进行相关的设置是比较轻松的：data-wow-duration （动画持续时间）data-wow-delay （动画延迟时间）data-wow-offset（元素的位置露出后距离底部多少像素执行）data-wow-iteration（动画执行次数） 总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给元素添加动画的方法有很多，可以自己用css编写，或者js编写，也可以直接用网上众多的动画库，今天我这里就介绍了两款动画库。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么该用哪个呢，其实我个人更倾向于直接使用animate.css，因为不用引入其他更多的文件，虽然设置属性的时候不如wow.js方便，但是文件更少，并且可以只取自己想要的动画。]]></content>
      <tags>
        <tag>CSS</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[锚点动画的实现以及其他相关]]></title>
    <url>%2F2019%2F06%2F05%2F%E9%94%9A%E7%82%B9%E5%8A%A8%E7%94%BB%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%BB%A5%E5%8F%8A%E5%85%B6%E4%BB%96%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在单页面中导航大多数都是直接使用锚点来进行导航，因为使用起来比较方便，但是单纯的锚点导航没有动画看起来比较生硬，所以基本上涉及到单页面导航都会给锚点跳转加上动画，那么实现起来也十分的简单方便。通过现在这么多的练习与学习，我发现很多功能如果每次都要自己写的话会比较麻烦，是否可以像各种框架一样封装起来成为自己的一个框架，每次只要通过特定的方法来调用就好了，那么这次我就将这个锚点动画的功能封装在我自己的一个js当中。同时这次涉及到锚点，又使我想起了前一段时间接触到的js中的hash，总感觉二者很像，再来探讨一下二者之间的关系。 实现锚点动画代码：123456789101112(function anchor_animate() &#123; // 可传递上下偏移量 var $offsetY = parseInt(-$(".my.anchor-animate").data('moffset')) || 0; // 可传递动画时间 var $time = parseInt($(".my.anchor-animate").data('mtime')) || 500; $(".my.anchor-animate a").click(function () &#123; $('html,body').animate(&#123; // 拿到锚点对应所在对象并给其设置动画 scrollTop: ($($(this).attr('href')).offset().top + $offsetY) &#125;, $time); &#125;); &#125;)(); 通过这些简单的代码就可以实现锚点动画了，值得注意的是这是我已经封装好的锚点动画，如果想要调用只需要给想要实现锚点动画的导航栏加上.my 、 .anchor-animate 这两个类就可以了，还可以通过data来设置参数，下次想要使用的时候就很方便了，以后把更多的功能封装进来。 关于hash起初我在学习一些知识的时候有使用过hash，不过当时是使用在实现给不同页面加上hash值，然后实现页面刷新在固定页面的功能上，因为hash也是在地址栏中加上#的原因，所以我觉得这和锚点很像，然后我去查了一下，其实hash的定义就是：hash 属性是一个可读可写的字符串，该字符串是 URL 的锚部分（从 # 号开始的部分）。其实就是一家人，再记录一下hash的用法：location.hash=anchorname当设置之后当前页面的url地址栏中就会出现#anchorname了。 总结以后尽可能的将一些常用的功能都封装到自己的js之中，然后向一些框架学习，学习他们是如何封装的，让自己的js也更加的规范。]]></content>
      <tags>
        <tag>CSS</tag>
        <tag>JS</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php中页面分页的实现]]></title>
    <url>%2F2019%2F06%2F03%2Fphp%E4%B8%AD%E9%A1%B5%E9%9D%A2%E5%88%86%E9%A1%B5%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;今天老师上课给我们讲了一下php中的翻页功能的实现，，主要是通过数据库中的limit方法实现，这一点和我预想的差不多，但是通过给页面设置id的这种办法是我没有想到的，我一开始的设想是，能不能作到不用给每个页面设置一个id，根据这个id进行跳转，而是直接设置一个变量，当进行翻页的时候这个变量的数值发生变化，然后根据这个变量来获取数据库中的内容。这个想法应该可以实现，但是可能会比较麻烦，因为在php中还是必须要刷新页面才能更新数据的，所以目前来看还是这种方法应该是最好的，那么就来看看究竟是怎么实现分页功能的。 代码 先是连接数据库： 123456&lt;?php// 一个正常的连接数据库的页面$conn=mysqli_connect('localhost','root','','test') or die('失败');mysqli_set_charset($conn,'utf8');$res=mysqli_query($conn,'select * from stu');?&gt; 实现功能的页面 12345678910111213141516171819202122232425262728293031323334353637&lt;body&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;id&lt;/td&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;年龄&lt;/td&gt; &lt;td&gt;性别&lt;/td&gt; &lt;/tr&gt; &lt;?php include 'conn.php'; $data_count=mysqli_num_rows($res); //获取数据表中有多少条数据 $data_num=2; //设置一页显示多少条数据 $id=empty($_GET['id'])?1:$_GET['id']; //判断当前页面的url栏中的id参数是否为空，如果为空则默认为1，否则则为url中id的数值 $pg_count=ceil($data_count/$data_num); //计算总共有多少页，ceil的用法是往上取整 //通过limit来获取每一个页面该显示的数据 $datas=mysqli_query($conn,"select * from stu limit ".($id-1)*2 . ','. $data_num); //用来排错的方法 // if (!$datas) &#123; // printf("Error: %s\n", mysqli_error($conn)); // exit(); // &#125; // 输出最终获取到的页面的数据 while($row=mysqli_fetch_array($datas))&#123; echo "&lt;tr&gt;&lt;td&gt;$row[id]&lt;/td&gt;&lt;td&gt;$row[name]&lt;/td&gt;&lt;td&gt;$row[age]&lt;/td&gt;&lt;td&gt;$row[sex]&lt;/td&gt;&lt;/tr&gt;"; &#125; ?&gt; &lt;!-- 在href中设置id的值 --&gt; &lt;tr&gt; &lt;td&gt;&lt;a href="?id=1"&gt;首页&lt;/a&gt;&lt;/td&gt; 实现上一页的功能，先判断是否是第一页，否则id-1 &lt;td&gt;&lt;a href="?id=&lt;?php echo $id==1?1:$id-1 ?&gt;"&gt;上一页&lt;/a&gt;&lt;/td&gt; 实现上一页的功能，先判断是否是最后一页，否则id+1 &lt;td&gt;&lt;a href="?id=&lt;?php echo $id==$pg_count?$pg_count:$id+1 ?&gt;"&gt;下一页&lt;/a&gt;&lt;/td&gt; &lt;td&gt;&lt;a href="?id=&lt;?php echo $pg_count ?&gt; "&gt;尾页&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt; 其实代码还是很好理解的，但是自己在写的过程中还是遇到了一些问题，下面记录一下这些问题 我自己在编写过程中遇到的一些问题首先就是在我基本上已经写完代码之后一测试就爆出了一个警告，并且最终没有出现我想要的结果，于是我上网查询解决办法，于是找到了下面这一段代码：1234if (!$datas) &#123; printf("Error: %s\n", mysqli_error($conn)); exit(); &#125; 通过上述代码就没有再出现警告了，而是直接报错，提示问题在哪，我就在附近排查问题， $datas=mysqli_query($conn,&quot;select * from stu limit ($id-1)*2 , $data_num&quot;); 我一开始想会不会因为是没有拼接字符串的原因,于是我修改代码改成后面是拼接字符串的形式。 $datas=mysqli_query($conn,&quot;select * from stu limit&quot;.($id-1)*2 . &#39;,&#39;. $data_num); 但是一直都是出现一样的错误提示，后面经过我的测试发现是$datas中没有数据，但是我直接不写变量，把变量写死就能出来数据。反复比较自己那部分的代码和老师给的代码，但是直接比对并没有发现什么不一样，后面复制老师的这行代码稍加修改结果却是正常的。最后我终于发现了问题所在，其实我尝试的两种写法都存在问题： 首先是我一开始没有拼接变量，而是直接将变量写在字符串之中，我发现也是数据库在处理语句的时候出现的问题，我猜测应该是在使用变量的时候变量会把前面的空格给吞掉，导致语句执行错误。 后面我尝试拼接字符串的时候又出现了问题是因为我在limit后面少拼接了一个空格导致语句执行出错。 总结写php还是不是特别的熟练，所以经常出现各种问题，所以要总结错误，加深印象，以后越写越熟练以后的错误就会越来越少]]></content>
      <categories>
        <category>页面小功能</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写一个简单的五星评分系统]]></title>
    <url>%2F2019%2F05%2F27%2F%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%BA%94%E6%98%9F%E8%AF%84%E5%88%86%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最近在写期末的课程设计，网站有要求写一个五星评分的功能，我按照我的思路写了一下，经过一下午的时间，把这个功能实现的比较完善了。 一开始的第一种尝试放代码：HTML部分：1234567891011121314151617*&#123; list-style: none;&#125;.all&#123; display: flex;&#125;&lt;/style&gt;&lt;body&gt; &lt;ul class="all"&gt; &lt;li&gt;&lt;img index=0 src="./images/wxz.png" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img index=1 src="./images/wxz.png" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img index=2 src="./images/wxz.png" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img index=3 src="./images/wxz.png" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img index=4 src="./images/wxz.png" alt=""&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt; JS部分：12345678910111213141516171819202122232425262728&lt;script&gt; $(function()&#123; var $stars=$('img'); console.log($stars); // 最外面的循环是给所有img添加事件 for(var i=0;i&lt;$stars.length;i++)&#123; $stars.eq(i).mouseenter(function()&#123; // 第二层的循环是判断是否是当前正在操作的元素 for(var i=0;i&lt;$stars.length;i++)&#123; if($stars[i]==this)&#123; $(this).click(function()&#123; console.log(i); &#125;) // 第三层的循环是给所有的星星设置相应的图片,让它显示出应有的效果 for(var j=0;j&lt;$stars.length;j++)&#123; if(j&lt;=i)&#123; $stars.eq(j).attr("src","./images/xz.png") &#125; else&#123; $stars.eq(j).attr("src","./images/wxz.png") &#125; &#125; &#125; &#125; &#125;) &#125; &#125;) &lt;/script&gt; 最终是实现了效果,但是我觉得这不是最好最简单的写法,于是我将其改进了一下，有了下面的这种写法。 第二种写法第二种写法原理其实也是一样的，只不过是代码更加的简介和简单1234567891011121314151617&lt;style&gt;*&#123; list-style: none;&#125;.all&#123; display: flex;&#125;&lt;/style&gt;&lt;body&gt; &lt;ul class="all"&gt; &lt;li&gt;&lt;img index="0" src="./images/wxz.png" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img index="1" src="./images/wxz.png" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img index="2" src="./images/wxz.png" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img index="3" src="./images/wxz.png" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img index="4" src="./images/wxz.png" alt=""&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt; 12345678910111213141516171819202122&lt;script&gt; $(function()&#123; var $stars=$('img');//获取所有的星星 // 鼠标移入事件 $stars.mouseenter(function()&#123; var $star_index=parseInt($(this).attr("index")); for(var i=0;i&lt;$stars.length;i++)&#123; if(i&lt;=$star_index)&#123; $stars.eq(i).attr("src","./images/xz.png"); &#125; else&#123; $stars.eq(i).attr("src","./images/wxz.png"); &#125; &#125; &#125;) // 单击事件，向服务器提交数据 $stars.click(function()&#123; var $star_index=parseInt($(this).attr("index")); console.log($star_index+1); &#125;) &#125;) &lt;/script&gt; 可以看出第二种写法要简单很多，主要是没有这么多的循环嵌套，这也是我最终所采用的写法。 总结虽然这个评分系统的原理以及思路是挺简单的，但其实在实现的过程中还是遇到了一些困难的，不过经过不断的思考排错，最终还是将其完善了，相信只要不断的学习，以后一定能越来越得心应手。]]></content>
      <categories>
        <category>页面小功能</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML中DOM的hash属性的使用]]></title>
    <url>%2F2019%2F05%2F26%2Fhash%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hash在网站中的使用也是十分的常见，使用hash也可以带来便利，这次我们来看看hash究竟该如何让使用。 如何设置hash我们可以通过在js中设置hash的值123&lt;script&gt;window.location.hash=3;&lt;/script&gt; 这样就可以设置hash值，那么设置过后我们就可以在地址栏看到多了一个#3 如何获取hash的值12345678910111213141516&lt;script&gt; window.location.hash=3; console.log(window.location.hash); //#3 &lt;/script&gt;``` 直接就能获取hash的值，但是这样获取到的值带有``#``我们要获取的一般都是不带``#``的值所以我们可以这样处理```javasript&lt;script&gt; window.location.hash=3; console.log(window.location.hash); //#3 console.log(window.location.hash.substring(1)); //3 &lt;/script&gt; 使用字符串截取函数，截取不带#的这一部分 监听地址栏hash值的变化经常会有需求需要监听地址栏中hash值的变化，实现路由的功能，那么是如何实现的呢：1234567891011121314151617181920212223// 当监听到变化时执行的函数 function hashChange() &#123; let urlHash = window.location.hash; const hashDom = '#test' if (urlHash == hashDom) &#123; $(hashDom).show(); &#125; &#125; hashChange(); if (('onhashchange' in window) &amp;&amp; ((typeof document.documentMode === 'undefined') || document.documentMode == 8)) &#123; // 浏览器支持onhashchange事件 window.onhashchange = hashChange; // TODO，对应新的hash执行的操作函数 &#125; else &#123; // 不支持则用定时器检测的办法 setInterval(function () &#123; // 检测hash值或其中某一段是否更改的函数， 在低版本的iE浏览器中通过window.location.hash取出的指和其它的浏览器不同，要注意 let ischanged = isHashChanged(); if (ischanged) &#123; hashChange(); // TODO，对应新的hash执行的操作函数 &#125; &#125;, 150); &#125; 这里的这个例子实现的就是通过通过超链接来进行hash的跳转，并且将原本隐藏的路由元素显示出来。 总结hash的使用十分的简单，并且使用频率很高，通过hash我们就可以实现例如翻页还在同一页的效果。这里也通过一个简单的例子实现了hash的应用。]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax的学习]]></title>
    <url>%2F2019%2F05%2F26%2FAjax%E7%9A%84%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ajax技术可以说是随处可见，在网页的交互方面基本上都用到了Ajax，可以说Ajax作用是十分的强大，通过 Ajax，因特网应用程序可以变得更完善，更友好。所以作为正在学习的我来说，完整学习Ajax以及完全掌握Ajax是十分重要的。 什么是Ajax呢？ Ajax 即“Asynchronous Javascript And XML”（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。 Ajax = 异步 JavaScript 和 XML 或者是 HTML（标准通用标记语言的子集）。 Ajax 是一种用于创建快速动态网页的技术。 Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。 Ajax所涉及的相关知识 get方式提交数据与post方式提交数据的异同点1、通过get方式提交数据会把数据放在url地址栏中，而使用post方式提交数据则会把数据放到请求头中，可以在调试工具的network栏中看到这些数据2、get请求由于浏览器对于url地址栏长度的限制，所以导致get1请求发送数据会有长度限制，要支持ie，那么最大长度就为2083byte 原生js实现Ajax可以参考这里 由于原生js实现Ajax过程比较多，这里不做过多介绍，了解即可，通常使用jQuery中的ajax方法，比较方便快捷的使用Ajax。 jQuery中的Ajax jQuery 提供多个与 AJAX 有关的方法。 通过 jQuery AJAX 方法，您能够使用 HTTP Get 和 HTTP Post 从远程服务器上请求文本、HTML、XML 或 JSON - 同时能够把这些外部数据直接载入网页的被选元素中。 jQuery.ajax([settings]) 这是jQuery中的Ajax的基本用法。 settings最常用的参数 type类型：String默认值: “GET”)。请求方式 (“POST” 或 “GET”)， 默认为 “GET”。注意：其它 HTTP 请求方法，如 PUT 和 DELETE 也可以使用，但仅部分浏览器支持。 url类型：String默认值: 当前页地址。发送请求的地址。 data类型：String发送到服务器的数据。将自动转换为请求字符串格式。GET 请求中将附加在 URL 后。查看 processData 选项说明以禁止此自动转换。必须为 Key/Value 格式。如果为数组，jQuery 将自动为不同值对应同一个名称。如 {foo:[“bar1”, “bar2”]} 转换为 ‘&amp;foo=bar1&amp;foo=bar2’。 error类型：Function默认值: 自动判断 (xml 或 html)。请求失败时调用此函数。有以下三个参数：XMLHttpRequest 对象、错误信息、（可选）捕获的异常对象。如果发生了错误，错误信息（第二个参数）除了得到 null 之外，还可能是 “timeout”, “error”, “notmodified” 和 “parsererror”。这是一个 Ajax 事件。 success类型：Function请求成功后的回调函数。参数：由服务器返回，并根据 dataType 参数进行处理后的数据；描述状态的字符串。这是一个 Ajax 事件。 除了以上这些外，jQuery中Ajax的settings还有很多参数，具体可以参考这里 通过jQuery中的Ajax来写两个简单的例子 通过get方式来向远程服务器提交数据。html代码123456789101112131415161718192021222324&lt;body&gt; &lt;!-- 通过一个按钮的单击事件来触发ajax --&gt; &lt;button&gt;这是一个按钮，点击发送Ajax请求&lt;/button&gt; &lt;script&gt; $(function()&#123; var $bt=$('button'); // 为按钮绑定单击事件 $bt.click(function()&#123; // 调用jQuery中的Ajax $.ajax(&#123; type:'get', url:'./php/ajax-get.php', data:'name=hsl&amp;age=18', success:function(msg)&#123; alert(msg) &#125;, error:function(xhr)&#123; alert(xhr) &#125; &#125;) &#125;) &#125;) &lt;/script&gt;&lt;/body&gt; php代码1234&lt;?php echo '这是返回的名字'.$_GET['name']; echo '这是返回的年龄'.$_GET['age'];?&gt; 根据代码我们可以看出当我们单击按钮的时候就会触发单击事件调用ajax，给我们返回后端处理过后的数据，那结果究竟会是怎样呢。通过图片我们可以看出Ajax成功返回了我们想要的数据，并且我们可以看到这个php文件的url附加了我们的参数信息。 通过post方式来向远程服务器提交数据。html代码1234567891011121314151617181920&lt;body&gt; &lt;button&gt;这是一个发送post请求的按钮&lt;/button&gt; &lt;script&gt; $(function()&#123; $('button').click(function()&#123; $.ajax(&#123; url:'./php/ajax-post.php', type:'post',//这里的传输方式改成了post data:'name=hsl&amp;age=18', success:function(msg)&#123; alert(msg); &#125;, error:function(xhr)&#123; alert(xhr); &#125; &#125;) &#125;) &#125;) &lt;/script&gt;&lt;/body&gt; php代码1234&lt;?phpecho $_POST['name'];echo $_POST['age'];?&gt; 可以看出上面的代码主要就是将type 从get改成了post，那效果会怎样呢.从图片中我们可以看出使用post方式也成功获取了我们想要的数据，但是我们不能在url中看见我们传过去的参数，但是能在报文头中看见这些参数，因为不像get方式会在url栏传参数，所以也没有长度的限制。 总结通过这次的学习，掌握了Ajax的基本用法，也通过实例了解了get方式与post方式的一些差别，二者以后要根据实际情况来使用。]]></content>
  </entry>
  <entry>
    <title><![CDATA[关于使用flex布局遇到的一个小问题]]></title>
    <url>%2F2019%2F05%2F23%2F%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8flex%E5%B8%83%E5%B1%80%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;昨天在给我的课程设计的网站做底部信息的时候遇到了一个问题，就是我给一个子元素div设置了固定的宽度，但是当我页面宽度发生变化的时候，这个div的宽度也会发生变化，毕竟我设置的是固定的宽度，所以这肯定不是我想要的效果，今天和昨天经过测试，现在终于把问题解决了，问题是由于flex引起的。让我们先看我的一个测试的代码：123456789101112131415161718192021222324&lt;style&gt;.big&#123; width: 100%; height: 500px; background-color: blue; display: flex; border: 2px solid #000; justify-content: center; align-items: center; margin: 0 auto;&#125;.sm&#123; width: 1200px;//这里是一个固定的宽度 height: 400px; background-color: red; text-align: center; border: 3px solid yellow;//加了一个黄色边框，方便观察&#125;&lt;/style&gt;&lt;body&gt; &lt;div class="big"&gt; &lt;div class="sm"&gt;这是测试的内容&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 按照我一开始的想法，既然设置了固定的宽度，应该就不会再发生改变了，即使是flex也不能改变它可是我们再看看效果图：很明显，里面的子元素的宽度也因为父元素的宽度变小了而变小了。 我的第一次尝试是给它加一个min-width=1200px，我们再看看效果：还是一样，没有发生任何变化。那究竟要怎么解决这个问题呢，经过我的各种尝试和猜想，最终还是把问题解决了：那么要如何解决这个问题呢，看我解决后的代码：1234567891011121314151617181920212223242526&lt;style&gt;.big&#123; width: 100%; height: 500px; background-color: blue; display: flex; border: 2px solid #000; /* justify-content: center; */ //1、首先就是不能用这个属性 align-items: center; margin: 0 auto;&#125;.sm&#123; width: 1200px; min-width: 1200px; //3、同时要加上最小宽度 height: 400px; background-color: red; text-align: center; margin: 0 auto; //2、只能使用这个来使子元素居中 border: 3px solid yellow;&#125;&lt;/style&gt;&lt;body&gt; &lt;div class=&quot;big&quot;&gt; &lt;div class=&quot;sm&quot;&gt;21413423&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 我们再来看看解决后的效果图：这次我们就可以看到，里面的内容没有被缩小了，问题终于得到了解决。 其实还有一种办法可以避免这种问题，就是最外层子元素不使用flex布局，或者是不设置百分比的宽度，这样也不会出现这种问题，但是在有些情况下使用flex明显要方便很多，看实际情况选择哪种处理办法吧。 更新补充后来我又想到了一个相对较好的解决办法，那就使最外层的div可以设置为百分比的宽度，但是不设置flex，我们对要布局的子div给它再加一个父元素，让它变成孙子，我们给他加的这个div让他成为父元素，并且给这个父元素设置flex和固定的我们想要的宽度，这个时候通过父元素的flex给孙子元素flex布局就也不会出现这种问题了，这也是一种不错的解决办法（推荐） 总结flex虽然好用，很多方面用起来很方便，但是也存在很多问题我还不知道，所以使用的时候要提前做好规划，避免出现问题，我的轮播图bug就是由于flex布局引起的，但是不知道是不是这个原因。]]></content>
      <categories>
        <category>问题解决</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>flex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cookie的学习以及使用]]></title>
    <url>%2F2019%2F05%2F21%2F%E5%88%9D%E8%AF%86cookie%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这篇博客经过不断更新就成了现在的版本，最开始学习cookie的时候并没有用cookie具体来实现什么功能，虽然那个时候有思路，但并没有做出来，而经过这么长的时间我已经通过cookie来实现了一个简单的登录功能以及掌握了cookie的更多使用方式，来记录一下。 什么是cookie？这是百度百科上的一段话：Cookie，有时也用其复数形式 Cookies，指某些网站为了辨别用户身份、进行 session 跟踪而储存在用户本地终端上的数据（通常经过加密）。定义于 RFC2109 和 2965 中的都已废弃，最新取代的规范是 RFC6265 [1] 。（可以叫做浏览器缓存） 我们就可以了解到cookie的作用，cookie就是存储了一些信息在本地，并且有一定的存在时间，cookie有这样的功能，就能给用户带来很多遍历，包括不用重复登录之类的。 cookie的一些特点 cookie的生命周期：·默认情况下是一次会话，也就是直到浏览器被关闭。·如果通过expires设置了时间，并且时间还没有过期，那么关闭浏览器后下次再打开浏览器，cookie还是存在的。·如果通过expires设置了时间，但是过期了，那么就会立即删除这个cookie，所以要删除一个cookie，只要让他过期就好了。 cookie数据的格式·cookie默认是不会保存任何数据的。document.cookie=&quot;name=hsl&quot;可以通过这种方式来添加cookie·在设置cookie时只能一条一条的设置，不能一条命令设置多条cookie。cookie有大小和个数的限制：个数：20~50大小：4kb左右 cookie的作用范围·不同浏览器之间的cookie不能共用·同一浏览器中，存放cookie的路径的子目录可以访问保存的cookie，但是父目录不能。document.cookie=&quot;name=hsl;path=/;&quot;但是可以通过加上path等于根目录使网站下的所有目录都能访问cookie。·默认情况下二级域名之间的cookie不能相互访问，但是设置了主域名之后就可以，domain=hslweb.net。 封装cookie的一些方法如果不封装方法的，直接获取cookie中我们想要的值还是有一些麻烦的，还有删除一条cookie也是一样，所以这里学习别人封装的两个方法来帮助我们简化操作。 创建一条cookie12 虽然本身创建一条cookie使很简单的，但是封装一下能够使调用起来更加的方便明了。 获取我们想要的cookie123456789101112function getCookie(name) &#123; var strcookie = document.cookie; //获取cookie字符串 var arrcookie = strcookie.split("; "); //分割 //遍历匹配 for (var i = 0; i &lt; arrcookie.length; i++) &#123; var arr = arrcookie[i].split("="); if (arr[0] == name) &#123; return arr[1]; &#125; &#125; return ""; &#125; 通过以上封装，我们只需要调用函数，然后传递我们想要获取的cookie作为参数就可以获取到我们想要的cookie的值了。 删除一条cookie12345function deleteCookie(name) &#123; var date = new Date(); date.setTime(date.getTime() - 10000); document.cookie = name + "=name; expires=" + date.toGMTString(); &#125; 前面也说过要删除一条cookie只需要让它过期就可以了这个函数就实现了这样的功能，用起来也方便。 创建条简单的cookie12345&lt;script&gt; var data=new Date(); data.setDate(data.getDate()+1);//设置时间 document.cookie="name=hsl;path=/;expires="+data.toGMTString()+";";//创建一个cookie，设置了路径以及过期的时间为后一天。&lt;/script&gt; 通过cookie来实现登录注销功能先来简单的说一下思路，思路其实很简单，只需要当我们通过Ajax发送请求登录成功之后将我们获取到的用户名（如果登录是通过用户名来登录可以直接在前端获取到，否则可以由后端传过用户名来）保存到cookie中，可以给cookie设置一个期限，那么在这个期限内就都可以不用重复登录了，也可以不设置，关闭浏览器后就得重新登录，然后如果cookie中有用户名就只要把原本是登录注册的地方替换为用户名以及注销，没有用户名则依然是登陆注册，如果要注销则将cookie删除就可以了。 那么下面就是一个简单的demo：123456789101112131415&lt;li class="nav-item ml-4"&gt; &lt;a class="nav-link" href="./register.html" id="register_link" aria-disabled="true"&gt;注册&lt;/a&gt;&lt;/li&gt;&lt;li class="nav-item pt-1 ml-4"&gt; &lt;a class=" btn btn-outline-primary btn-sm" id="logon_link" role="button" href="./logon.html"&gt;登录 &lt;span class="sr-only"&gt;(current)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li class="nav-item ml-4"&gt; &lt;a class="nav-link" href="#" id="user_name" aria-disabled="true" style="display: none"&gt;admin&lt;/a&gt;&lt;/li&gt;&lt;li class="nav-item ml-4"&gt; &lt;a class="nav-link" href="./index.html" id="logout_btn" aria-disabled="true" style="display: none"&gt;注销&lt;/a&gt;&lt;/li&gt; 用户名和注销是默认不显示的，登录成功后则将他们显示，将登录注册设置为不显示。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;script&gt; $(function () &#123; // 获取cookie中的值 function getCookie(name) &#123; var strcookie = document.cookie; //获取cookie字符串 var arrcookie = strcookie.split("; "); //分割 //遍历匹配 for (var i = 0; i &lt; arrcookie.length; i++) &#123; var arr = arrcookie[i].split("="); if (arr[0] == name) &#123; return arr[1]; &#125; &#125; return ""; &#125; getCookie('name'); // 删除cookie的方法 function deleteCookie(name) &#123; var date = new Date(); date.setTime(date.getTime() - 10000); document.cookie = name + "=name; expires=" + date.toGMTString(); &#125; (function () &#123; // 获取以后要操作的元素 var register_link = $('#register_link'); var logon_link = $('#logon_link'); var user_name = $("#user_name"); var logout_btn = $('#logout_btn'); var name = getCookie('name'); // 点击注销删除cookie logout_btn.click(function () &#123; deleteCookie('name'); &#125;) // 判断cookie中是否有存放用户名 if (name) &#123; // 如果有，则将登录注册隐藏，替换成用户名和注销 console.log('这里面有东西'); user_name.text(name); register_link.hide(); logon_link.hide(); user_name.show(); logout_btn.show(); &#125; else &#123; // 如果没有，则将用户名和注销隐藏 console.log('这里面是空的'); register_link.show(); logon_link.show(); user_name.hide(); logout_btn.hide(); &#125; &#125;)(); &#125;)&lt;/script&gt; 这里只写了前端的逻辑，后端php的代码在这里就不介绍了，其实就是对用户名和密码进行一个匹配，成功了则返回相应的数据 总结：cookie的创建与设置还是很简单的，但是cookie的作用却很强大，要好好使用。cookie应用做多的场景应该就是登录功能的实现了，必须要掌握。]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过post方式上传文件]]></title>
    <url>%2F2019%2F05%2F21%2F%E9%80%9A%E8%BF%87post%E6%96%B9%E5%BC%8F%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这次学习一下通过表单得到post方式来向后端上传文件，以及使用表单来上传文件的注意点及注意事项。先上代码：123456&lt;body&gt; &lt;form action="post上传文件.php" method="POST" enctype="multipart/form-data"&gt; &lt;input type="file" name="upFile" id=""&gt;&lt;br&gt; &lt;input type="submit" name="tj"&gt; &lt;/form&gt;&lt;/body&gt; 这里之所以使用post方式上传而不使用get方式上传是因为get方式上传有文件大小方面的限制，最多2000个字符，所以使用post 很正常的一个表单，设置了控件类型以及与后端交互时要用到的name 但是要注意的是上传文件时除了要设置表单类型为 file之外，还需要给form添加一个enctype属性，并且把它的值设为multipart/form-data，只有这样才能正常上传。 我们再来看看php部分的代码：123456&lt;?phpprint_r($_FILES);echo '&lt;br&gt;';$fileInfo=$_FILES['upFile'];print_r($fileInfo);?&gt; 这个时候我们就不能再使用post方式来获取文件的内容了，我们需要用file方式。我么再来看看打印的结果：1234Array ( [tj] =&gt; 提交 ) //这个时候post变量获取到的东西就不是我们想要的东西了。Array ( [upFile] =&gt; Array ( [name] =&gt; 后面问题.png [type] =&gt; image/png [tmp_name] =&gt; E:\xampp\tmp\phpDC76.tmp [error] =&gt; 0 [size] =&gt; 32458 ) ) //而通过file变量获取到的数组里面就有我们想要的东西Array ( [name] =&gt; 后面问题.png [type] =&gt; image/png [tmp_name] =&gt; E:\xampp\tmp\phpDC76.tmp [error] =&gt; 0 [size] =&gt; 32458 )//然后再从数组中取出我们想要的文件，就可以得到文件的信息。 但是其实这个时候也不是我们想要的结果，因为我们会发现 E:\xampp\tmp\这个目录下是空的，并没有我们上传的文件 这是因为这其实是一个临时文件夹，如果我们需要永久保存我们想要的内容我们需要将文件保存到我们自己建立的一个文件夹中。 这个时候我们就需要使用到这个函数move_uploaded_file(file,newloc)第一个参数规定文件的原路径，第二个参数规定文件的新路径已经文件名。 下面将代码改进一下：加上一行代码：1move_uploaded_file($fileInfo['tmp_name'],"./test_imgs/".$fileInfo['name']); 这个时候我们再看设置的那个新路径，就已经成功将文件移动过来了。 总结：上传文件的表单与其他表单有些许不一样，要多注意，获取内容的方法也不太一样，并且要注意move_uploaded_file函数的使用，第二个参数写相对路径的时候，如果是相对与当前路径开始的话一定不能遗漏了./来表示当前路径，比如我刚开始这样写就报错：&quot;test_imgs/&quot;,而这样写就是对的:&quot;./test_imgs/&quot;所以以后要多注意。]]></content>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery中eq与get的区别]]></title>
    <url>%2F2019%2F05%2F20%2FjQuery%E4%B8%ADeq%E4%B8%8Eget%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在刚开始学习使用jQuery的时候就遇到过类似的问题，没有完全理解到什么是jQuery对象以它与Element对象的区别。而jQuery中的eq方法与get方法正好也是这方面的区别，这次来好好把他们区分一下。先上一段html代码1234&lt;body&gt; &lt;div class="test1"&gt;这是一个测试div &lt;span&gt;这是一个子元素&lt;/span&gt;&lt;/div&gt; &lt;div class="test2"&gt;这是第二个测试div&lt;/div&gt;&lt;/body&gt; js代码12345678910111213141516171819202122232425262728&lt;script&gt; $(function()&#123; // 通过这个可以看出使用核心函数选择div会将它转化成一个jQuery对象，jQuery对象的本质是一个数组对象，有length属性 console.log( $('div') ); // 而我们通过get方法获取到的对象其实是一个Element对象 console.log( $('div').get(0) ); // 所以我们就可以对它使用js原生的方法来获取它的子节点 console.log( $('div').get(0).children[0] ); // 而这种写法获取到的东西是和get所获取到的东西是一模一样的 console.log( $('div')[1] ); // 而通过eq获取到的其实是一个jQuery对象 console.log( $('div').eq(0) ); // 我们亦可以通过jQuery的核心函数将Element对象转化成jQuery对象 console.log( $($('div').get(0)) ); &#125;) &lt;/script&gt; 我们再来看看输出的结果: 总结:eq与get的区别十分的明显,一个获取到的是jQuery对象,一个获取到的是Element对象,而我们的jQuery的方法只能对jQuery对象使用,所以我们要特别注意我们获取到的是什么对象,当然我们也可以通过jQuery核心函数将Element对象转化为jQuery对象.]]></content>
      <tags>
        <tag>JS</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flex使用的小demo]]></title>
    <url>%2F2019%2F05%2F18%2Fflex%E4%BD%BF%E7%94%A8%E7%9A%84%E5%B0%8Fdemo%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前面学习了flex的相关知识，现在就这些知识运用到实例，通过写一个导航栏和一个搜索框试试效果怎么样。 通过flex布局一个等分的导航栏代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;style&gt;*&#123; margin: 0; padding: 0; list-style: none;&#125;nav&#123; width: 40%; height: 50px; background: #ccc; margin: 0 auto;&#125;nav&gt;ul&#123; display: flex; height: 100%; width: 100%; flex-flow: row nowrap; /* justify-content: space-around; */ align-items: center;&#125;/* 通过给子元素使用flex-grow会影响到父元素设置的justify-content，但是无论使用哪种方法都能达到相同的效果 */ul&gt;li&#123; text-align: center;&#125;/* 以下代码其实都可以不用，只通过一个justify-content: space-between就能达到这种效果 */ul&gt;li:nth-child(1)&#123; flex: 0 0 auto; text-align: center;&#125;ul&gt;li:nth-child(2)&#123; flex: auto; text-align: center;&#125;ul&gt;li:nth-child(3)&#123; flex: auto; text-align: center;&#125;ul&gt;li:nth-child(4)&#123; flex: auto; flex: 0 0 auto;&#125;&lt;/style&gt;&lt;body&gt; &lt;nav&gt; &lt;ul&gt; &lt;li&gt;栏目一&lt;/li&gt; &lt;li&gt;栏目二&lt;/li&gt; &lt;li&gt;栏目三&lt;/li&gt; &lt;li&gt;栏目四&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt;&lt;/body&gt; 效果图： 通过flex布局一个搜索框代码：12345678910111213141516171819202122232425262728293031323334&lt;style&gt;*&#123; margin: 0; padding: 0; list-style: none;&#125;.search&#123; margin: 0 auto; margin-top: 20px; width: 500px; display: flex;&#125;input&#123; /* 因为默认另一个button的flex-grow为0， 只要设置这个输入框的flex-grow为1则可以占满剩下的宽度 */ flex-grow: 1;&#125;button&#123; border: 0; background-color: red; outline: none; height: 30px; /* 当我们把button的高度调高之后，可以发现输入框的高度也一起随之升高了 如果想要改变这种效果可以对输入框设置align-self */&#125;&lt;/style&gt;&lt;body&gt; &lt;div class="search"&gt; &lt;input type="text"&gt; &lt;button&gt;点击搜索&lt;/button&gt; &lt;/div&gt;&lt;/body&gt; 效果图： 总结使用flex布局真的好轻松，好方便啊，再也不用为各种繁琐的事情改开改去了。]]></content>
      <tags>
        <tag>CSS</tag>
        <tag>flex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3_flex的使用]]></title>
    <url>%2F2019%2F05%2F18%2FCSS3-flex%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前段时间有了解到flex布局，flex布局是W3C再2009年提出的一种新的方案，且现在已经兼容所有的浏览器，传统的布局方式在有些时候会比较麻烦，且兼容性不是特别好，那么使用flex布局就能解决很多问题，这次来学习以下flex布局，并加以使用，以后熟练使用就能大大提高我们的布局效率。 Flex布局是什么？Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。123.box&#123; display: flex;&#125; 行内元素也可以使用Flex布局。123.box&#123; display: inline-flex;&#125; Webkit内核的浏览器，必须加上-webkit前缀。1234.box&#123; display: -webkit-flex; /* Safari */ display: flex;&#125; 注意:设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。 基本概念采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 容器的属性容器有以下6个属性： flex-direction flex-wrap flex-flow justify-content align-items align-content flex-direction属性flex-direction属性决定主轴的方向（即项目的排列方向）。123.box &#123; flex-direction: row | row-reverse | column | column-reverse;&#125; 可能有4个值： row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 flex-wrap属性默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。123.box&#123; flex-wrap: nowrap | wrap | wrap-reverse;&#125; 它可能取三个值: nowrap（默认）：不换行。 wrap：换行，第一行在上方。 wrap-reverse：换行，第一行在下方。 flex-flowflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。123.box &#123; flex-flow: &lt;flex-direction&gt; &lt;flex-wrap&gt;;&#125; justify-content属性justify-content属性定义了项目在主轴上的对齐方式。123.box &#123; justify-content: flex-start | flex-end | center | space-between | space-around;&#125; 可能取5个值，与主轴方向有关（以下假设主轴从左向右）： flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 （在做菜单栏导航栏等需要间隔相等的项目中十分有用） space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 align-items属性align-items属性定义项目在交叉轴上如何对齐。123.box &#123; align-items: flex-start | flex-end | center | baseline | stretch;&#125; 可能取5个值，与交叉轴方向有关（以下假设主轴从上向下） flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 align-content属性align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。123.box &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125; 该属性可能取6个值： flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 项目的属性以下6个属性设置在项目上。 order flex-grow flex-shrink flex-basis flex align-self order属性order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。123.item &#123; order: &lt;integer&gt;;&#125; flex-grow属性flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。123.item &#123; flex-grow: &lt;number&gt;; /* default 0 */&#125; 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 flex-shrink属性flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。123.item &#123; flex-shrink: &lt;number&gt;; /* default 1 */&#125; 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。负值对该属性无效。 flex-basis属性flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。123.item &#123; flex-basis: &lt;length&gt; | auto; /* default auto */&#125; 它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。 flex属性flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。123.item &#123; flex: none | [ &lt;&apos;flex-grow&apos;&gt; &lt;&apos;flex-shrink&apos;&gt;? || &lt;&apos;flex-basis&apos;&gt; ]&#125; 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 align-self属性align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。123.item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch;&#125; 该属性可能取6个值，除了auto，其他都与align-items属性完全一致。 文章转载自：http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html]]></content>
      <tags>
        <tag>CSS</tag>
        <tag>flex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery学习（动画效果）]]></title>
    <url>%2F2019%2F05%2F15%2FjQuery%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这次总结以下jQuery中所有自带的动画效果以及jQuery中的自定义动画，以及动画1的其他一些相关方法，帮助我们更好的学习和使用jQuery中的动画。前面已经学习使用过大部分自带动画了，这次着重讲一下自定义动画与其他方法。 显示、隐藏动画show([s,[e],[fn]]) 显示动画 内部实现原理根据当前操作的元素是块级还是行内决定, 块级内部调用display:block;,行内内部调用display:inline; hide([s,[e],[fn]]) 隐藏动画 toggle([spe],[eas],[fn]) 切换动画(显示变隐藏,隐藏变显示) 注意事项: show(1000, function () {};) 第一个参数单位是毫秒, 1000毫秒等于1秒 默认的动画时长是400毫秒 除了指定毫秒以外还可以指定三个预设参数 slow、normal、fast slow本质是600毫秒 normal本质是400毫秒 fast本质是200毫秒 展开、收起动画参数、注意事项和显示隐藏动画一模一样, 只不过动画效果不一样而已 slideDown([s],[e],[fn])展开动画 slideUp([s,[e],[fn]])收起动画 slideToggle([s],[e],[fn])切换动画(展开变收起,收起变展开)参数、注意事项和显示隐藏动画一模一样, 只不过动画效果不一样而已 fadeIn([s],[e],[fn])淡入动画 fadeOut([s],[e],[fn])淡出动画 fadeToggle([s,[e],[fn]])切换动画(显示变淡出,不显示变淡入) fadeTo([[s],o,[e],[fn]])淡入到指定透明度动画可以通过第二个参数,淡入到指定的透明度(取值范围0~1) 自定义动画有时候自带的这些动画不能完全满足我们的需求，我们就需要使用到自定义动画来帮助我们完成动画。 animate(p,[s],[e],[fn]) 第一个参数: 接收一个对象, 可以在对象中修改属性 第二个参数: 指定动画时长 第三个参数: 指定动画节奏, 默认就是swing 第四个参数: 动画执行完毕之后的回调函数下面是一个自定义动画的例子：123456789101112131415161718192021222324252627282930313233&lt;style&gt;.test&#123; background: red; width: 200px; height: 200px; border-radius: 50%;&#125;&lt;/style&gt;&lt;body&gt; &lt;div class="test"&gt;&lt;/div&gt; &lt;script&gt; $(function()&#123; // 使圆变大 $('.test').animate(&#123; // 可以同时设置多个值的变化 width:400, height:400, // 可以设置动画节奏 &#125;,2000,'Linear',function()&#123; // 可以链式设置多个动画 alert('变大执行完毕') &#125;).animate(&#123; marginLeft:200 &#125;,2000,function()&#123; alert('右移执行完毕') &#125;).animate(&#123; marginLeft:"800" &#125;,2000,function()&#123; alert('完成') &#125;); &#125;) &lt;/script&gt;&lt;/body&gt; 要注意的一点:每次开始运动都必须是初始位置或者初始状态,如果想在上一次位置或者状态下再次进行动画可以使用累加动画,上面这个例子就是圆先变大,然后在变大之前的圆心处右移,然后再回到圆心处再次右移,所以要使用累计动画的方式来设置参数比如说{marginLeft:&quot;+=200&quot;} 动画队列 多个动画方法链式编程,会等到前面的动画执行完毕再依次执行后续动画 但是如果后面紧跟一个非动画方法则会被立即执行 如果想颜色再动画执行完毕之后设置, 1.使用回调 2.使用动画队列 注意点:动画队列方法queue()后面不能继续直接添加queue()如果想继续添加必须在上一个queue()方法中next()方法 动画相关方法 delay(d,[q])设置动画延迟时长 stop([c],[j])停止指定元素上正在执行的动画1234567891011121314// 立即停止当前动画, 继续执行后续的动画// $(&quot;div&quot;).stop();// $(&quot;div&quot;).stop(false);// $(&quot;div&quot;).stop(false, false);// 立即停止当前和后续所有的动画// $(&quot;div&quot;).stop(true);// $(&quot;div&quot;).stop(true, false);// 立即完成当前的, 继续执行后续动画// $(&quot;div&quot;).stop(false, true);// 立即完成当前的, 并且停止后续所有的$(&quot;div&quot;).stop(true, true);]]></content>
      <categories>
        <category>学习笔记</category>
        <category>jQuery学习笔记</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>jQuery</tag>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chrome插件(扩展)开发全攻略]]></title>
    <url>%2F2019%2F05%2F15%2FChrome%E6%8F%92%E4%BB%B6(%E6%89%A9%E5%B1%95)%E5%BC%80%E5%8F%91%E5%85%A8%E6%94%BB%E7%95%A5%2F</url>
    <content type="text"><![CDATA[写在前面 这篇文章来自于转载，作者花了许多时间编写，写的也很详细，也很辛苦，我已经在文章尾部标明，也感谢作者的分享，这是文章原地址以下是作者原文：来源我花了将近一个多月的时间断断续续写下这篇博文，并精心写下完整demo，写博客的辛苦大家懂的，所以转载务必保留出处。本文所有涉及到的大部分代码均在这个demo里面：https://github.com/sxei/chrome-plugin-demo ，大家可以直接下载下来运行。 另外，本文图片较多，且图片服务器带宽有限，右下角的目录滚动监听必须等到图片全部加载完毕之后才会触发，所以请耐心等待加载完毕。 本文目录： demo部分截图： 前言 2.1. 什么是Chrome插件 严格来讲，我们正在说的东西应该叫Chrome扩展(Chrome Extension)，真正意义上的Chrome插件是更底层的浏览器功能扩展，可能需要对浏览器源码有一定掌握才有能力去开发。鉴于Chrome插件的叫法已经习惯，本文也全部采用这种叫法，但读者需深知本文所描述的Chrome插件实际上指的是Chrome扩展。 Chrome插件是一个用Web技术开发、用来增强浏览器功能的软件，它其实就是一个由HTML、CSS、JS、图片等资源组成的一个.crx后缀的压缩包. 个人猜测crx可能是Chrome Extension如下3个字母的简写： 另外，其实不只是前端技术，Chrome插件还可以配合C++编写的dll动态链接库实现一些更底层的功能(NPAPI)，比如全屏幕截图。 由于安全原因，Chrome浏览器42以上版本已经陆续不再支持NPAPI插件，取而代之的是更安全的PPAPI。 2.2. 学习Chrome插件开发有什么意义 增强浏览器功能，轻松实现属于自己的“定制版”浏览器，等等。 Chrome插件提供了很多实用API供我们使用，包括但不限于： 书签控制； 下载控制； 窗口控制； 标签控制； 网络请求控制，各类事件监听； 自定义原生菜单； 完善的通信机制； 等等； 2.3. 为什么是Chrome插件而不是Firefox插件 Chrome占有率更高，更多人用； 开发更简单； 应用场景更广泛，Firefox插件只能运行在Firefox上，而Chrome除了Chrome浏览器之外，还可以运行在所有webkit内核的国产浏览器，比如360极速浏览器、360安全浏览器、搜狗浏览器、QQ浏览器等等； 除此之外，Firefox浏览器也对Chrome插件的运行提供了一定的支持； 开发与调试 Chrome插件没有严格的项目结构要求，只要保证本目录有一个manifest.json即可，也不需要专门的IDE，普通的web开发工具即可。 从右上角菜单-&gt;更多工具-&gt;扩展程序可以进入 插件管理页面，也可以直接在地址栏输入 chrome://extensions 访问。 勾选开发者模式即可以文件夹的形式直接加载插件，否则只能安装.crx格式的文件。Chrome要求插件必须从它的Chrome应用商店安装，其它任何网站下载的都无法直接安装，所以，其实我们可以把crx文件解压，然后通过开发者模式直接加载。 开发中，代码有任何改动都必须重新加载插件，只需要在插件管理页按下Ctrl+R即可，以防万一最好还把页面刷新一下。 核心介绍 4.1. manifest.json 这是一个Chrome插件最重要也是必不可少的文件，用来配置所有和插件相关的配置，必须放在根目录。其中，manifest_version、name、version3个是必不可少的，description和icons是推荐的。 下面给出的是一些常见的配置项，均有中文注释，完整的配置文档请戳这里。 { // 清单文件的版本，这个必须写，而且必须是2 "manifest_version": 2, // 插件的名称 "name": "demo", // 插件的版本 "version": "1.0.0", // 插件描述 "description": "简单的Chrome扩展demo", // 图标，一般偷懒全部用一个尺寸的也没问题 "icons": { "16": "img/icon.png", "48": "img/icon.png", "128": "img/icon.png" }, // 会一直常驻的后台JS或后台页面 "background": { // 2种指定方式，如果指定JS，那么会自动生成一个背景页 "page": "background.html" //"scripts": ["js/background.js"] }, // 浏览器右上角图标设置，browser_action、page_action、app必须三选一 "browser_action": { "default_icon": "img/icon.png", // 图标悬停时的标题，可选 "default_title": "这是一个示例Chrome插件", "default_popup": "popup.html" }, // 当某些特定页面打开才显示的图标 /*"page_action": { "default_icon": "img/icon.png", "default_title": "我是pageAction", "default_popup": "popup.html" },*/ // 需要直接注入页面的JS "content_scripts": [ { //"matches": ["http://*/*", "https://*/*"], // "&lt;all_urls&gt;" 表示匹配所有地址 "matches": ["&lt;all_urls&gt;"], // 多个JS按顺序注入 "js": ["js/jquery-1.8.3.js", "js/content-script.js"], // JS的注入可以随便一点，但是CSS的注意就要千万小心了，因为一不小心就可能影响全局样式 "css": ["css/custom.css"], // 代码注入的时间，可选值： "document_start", "document_end", or "document_idle"，最后一个表示页面空闲时，默认document_idle "run_at": "document_start" }, // 这里仅仅是为了演示content-script可以配置多个规则 { "matches": ["*://*/*.png", "*://*/*.jpg", "*://*/*.gif", "*://*/*.bmp"], "js": ["js/show-image-content-size.js"] } ], // 权限申请 "permissions": [ "contextMenus", // 右键菜单 "tabs", // 标签 "notifications", // 通知 "webRequest", // web请求 "webRequestBlocking", "storage", // 插件本地存储 "http://*/*", // 可以通过executeScript或者insertCSS访问的网站 "https://*/*" // 可以通过executeScript或者insertCSS访问的网站 ], // 普通页面能够直接访问的插件资源列表，如果不设置是无法直接访问的 "web_accessible_resources": ["js/inject.js"], // 插件主页，这个很重要，不要浪费了这个免费广告位 "homepage_url": "https://www.baidu.com", // 覆盖浏览器默认页面 "chrome_url_overrides": { // 覆盖浏览器默认的新标签页 "newtab": "newtab.html" }, // Chrome40以前的插件配置页写法 "options_page": "options.html", // Chrome40以后的插件配置页写法，如果2个都写，新版Chrome只认后面这一个 "options_ui": { "page": "options.html", // 添加一些默认的样式，推荐使用 "chrome_style": true }, // 向地址栏注册一个关键字以提供搜索建议，只能设置一个关键字 "omnibox": { "keyword" : "go" }, // 默认语言 "default_locale": "zh_CN", // devtools页面入口，注意只能指向一个HTML文件，不能是JS文件 "devtools_page": "devtools.html" } 4.2. content-scripts 所谓content-scripts，其实就是Chrome插件中向页面注入脚本的一种形式（虽然名为script，其实还可以包括css的），借助content-scripts我们可以实现通过配置的方式轻松向指定页面注入JS和CSS（如果需要动态注入，可以参考下文），最常见的比如：广告屏蔽、页面CSS定制，等等。 示例配置： { // 需要直接注入页面的JS "content_scripts": [ { //"matches": ["http://*/*", "https://*/*"], // "&lt;all_urls&gt;" 表示匹配所有地址 "matches": ["&lt;all_urls&gt;"], // 多个JS按顺序注入 "js": ["js/jquery-1.8.3.js", "js/content-script.js"], // JS的注入可以随便一点，但是CSS的注意就要千万小心了，因为一不小心就可能影响全局样式 "css": ["css/custom.css"], // 代码注入的时间，可选值： "document_start", "document_end", or "document_idle"，最后一个表示页面空闲时，默认document_idle "run_at": "document_start" } ], } 特别注意，如果没有主动指定run_at为document_start（默认为document_idle），下面这种代码是不会生效的： document.addEventListener('DOMContentLoaded', function() { console.log('我被执行了！'); }); content-scripts和原始页面共享DOM，但是不共享JS，如要访问页面JS（例如某个JS变量），只能通过injected js来实现。content-scripts不能访问绝大部分chrome.xxx.api，除了下面这4种： chrome.extension(getURL , inIncognitoContext , lastError , onRequest , sendRequest) chrome.i18n chrome.runtime(connect , getManifest , getURL , id , onConnect , onMessage , sendMessage) chrome.storage 其实看到这里不要悲观，这些API绝大部分时候都够用了，非要调用其它API的话，你还可以通过通信来实现让background来帮你调用（关于通信，后文有详细介绍）。 好了，Chrome插件给我们提供了这么强大的JS注入功能，剩下的就是发挥你的想象力去玩弄浏览器了。 4.3. background 后台（姑且这么翻译吧），是一个常驻的页面，它的生命周期是插件中所有类型页面中最长的，它随着浏览器的打开而打开，随着浏览器的关闭而关闭，所以通常把需要一直运行的、启动就运行的、全局的代码放在background里面。 background的权限非常高，几乎可以调用所有的Chrome扩展API（除了devtools），而且它可以无限制跨域，也就是可以跨域访问任何网站而无需要求对方设置CORS。 经过测试，其实不止是background，所有的直接通过chrome-extension://id/xx.html这种方式打开的网页都可以无限制跨域。 配置中，background可以通过page指定一张网页，也可以通过scripts直接指定一个JS，Chrome会自动为这个JS生成一个默认的网页： { // 会一直常驻的后台JS或后台页面 "background": { // 2种指定方式，如果指定JS，那么会自动生成一个背景页 "page": "background.html" //"scripts": ["js/background.js"] }, } 需要特别说明的是，虽然你可以通过chrome-extension://xxx/background.html直接打开后台页，但是你打开的后台页和真正一直在后台运行的那个页面不是同一个，换句话说，你可以打开无数个background.html，但是真正在后台常驻的只有一个，而且这个你永远看不到它的界面，只能调试它的代码。 4.4. event-pages 这里顺带介绍一下event-pages，它是一个什么东西呢？鉴于background生命周期太长，长时间挂载后台可能会影响性能，所以Google又弄一个event-pages，在配置文件上，它与background的唯一区别就是多了一个persistent参数： { "background": { "scripts": ["event-page.js"], "persistent": false }, } 它的生命周期是：在被需要时加载，在空闲时被关闭，什么叫被需要时呢？比如第一次安装、插件更新、有content-script向它发送消息，等等。 除了配置文件的变化，代码上也有一些细微变化，个人这个简单了解一下就行了，一般情况下background也不会很消耗性能的。 4.5. popup popup是点击browser_action或者page_action图标时打开的一个小窗口网页，焦点离开网页就立即关闭，一般用来做一些临时性的交互。 popup可以包含任意你想要的HTML内容，并且会自适应大小。可以通过default_popup字段来指定popup页面，也可以调用setPopup()方法。 配置方式： { "browser_action": { "default_icon": "img/icon.png", // 图标悬停时的标题，可选 "default_title": "这是一个示例Chrome插件", "default_popup": "popup.html" } } 需要特别注意的是，由于单击图标打开popup，焦点离开又立即关闭，所以popup页面的生命周期一般很短，需要长时间运行的代码千万不要写在popup里面。 在权限上，它和background非常类似，它们之间最大的不同是生命周期的不同，popup中可以直接通过chrome.extension.getBackgroundPage()获取background的window对象。 4.6. injected-script 这里的injected-script是我给它取的，指的是通过DOM操作的方式向页面注入的一种JS。为什么要把这种JS单独拿出来讨论呢？又或者说为什么需要通过这种方式注入JS呢？ 这是因为content-script有一个很大的“缺陷”，也就是无法访问页面中的JS，虽然它可以操作DOM，但是DOM却不能调用它，也就是无法在DOM中通过绑定事件的方式调用content-script中的代码（包括直接写onclick和addEventListener2种方式都不行），但是，“在页面上添加一个按钮并调用插件的扩展API”是一个很常见的需求，那该怎么办呢？其实这就是本小节要讲的。 在content-script中通过DOM方式向页面注入inject-script代码示例： // 向页面注入JS function injectCustomJs(jsPath) { jsPath = jsPath || 'js/inject.js'; var temp = document.createElement('script'); temp.setAttribute('type', 'text/javascript'); // 获得的地址类似：chrome-extension://ihcokhadfjfchaeagdoclpnjdiokfakg/js/inject.js temp.src = chrome.extension.getURL(jsPath); temp.onload = function() { // 放在页面不好看，执行完后移除掉 this.parentNode.removeChild(this); }; document.head.appendChild(temp); } 你以为这样就行了？执行一下你会看到如下报错： Denying load of chrome-extension://efbllncjkjiijkppagepehoekjojdclc/js/inject.js. Resources must be listed in the web_accessible_resources manifest key in order to be loaded by pages outside the extension. 意思就是你想要在web中直接访问插件中的资源的话必须显示声明才行，配置文件中增加如下： { // 普通页面能够直接访问的插件资源列表，如果不设置是无法直接访问的 "web_accessible_resources": ["js/inject.js"], } 至于inject-script如何调用content-script中的代码，后面我会在专门的一个消息通信章节详细介绍。 4.7. homepage_url 开发者或者插件主页设置，一般会在如下2个地方显示： Chrome插件的8种展示形式 5.1. browserAction(浏览器右上角) 通过配置browser_action可以在浏览器的右上角增加一个图标，一个browser_action可以拥有一个图标，一个tooltip，一个badge和一个popup。 示例配置如下： "browser_action": { "default_icon": "img/icon.png", "default_title": "这是一个示例Chrome插件", "default_popup": "popup.html" } 5.1.1. 图标 browser_action图标推荐使用宽高都为19像素的图片，更大的图标会被缩小，格式随意，一般推荐png，可以通过manifest中default_icon字段配置，也可以调用setIcon()方法。 5.1.2. tooltip 修改browser_action的manifest中default_title字段，或者调用setTitle()方法。 5.1.3. badge 所谓badge就是在图标上显示一些文本，可以用来更新一些小的扩展状态提示信息。因为badge空间有限，所以只支持4个以下的字符（英文4个，中文2个）。badge无法通过配置文件来指定，必须通过代码实现，设置badge文字和颜色可以分别使用setBadgeText()和setBadgeBackgroundColor()。 chrome.browserAction.setBadgeText({text: 'new'}); chrome.browserAction.setBadgeBackgroundColor({color: [255, 0, 0, 255]}); 效果： 5.2. pageAction(地址栏右侧) 所谓pageAction，指的是只有当某些特定页面打开才显示的图标，它和browserAction最大的区别是一个始终都显示，一个只在特定情况才显示。 需要特别说明的是早些版本的Chrome是将pageAction放在地址栏的最右边，左键单击弹出popup，右键单击则弹出相关默认的选项菜单： 而新版的Chrome更改了这一策略，pageAction和普通的browserAction一样也是放在浏览器右上角，只不过没有点亮时是灰色的，点亮了才是彩色的，灰色时无论左键还是右键单击都是弹出选项： 具体是从哪一版本开始改的没去仔细考究，反正知道v50.0的时候还是前者，v58.0的时候已改为后者。 调整之后的pageAction我们可以简单地把它看成是可以置灰的browserAction。 chrome.pageAction.show(tabId) 显示图标； chrome.pageAction.hide(tabId) 隐藏图标； 示例(只有打开百度才显示图标)： // manifest.json { "page_action": { "default_icon": "img/icon.png", "default_title": "我是pageAction", "default_popup": "popup.html" }, "permissions": ["declarativeContent"] } // background.js chrome.runtime.onInstalled.addListener(function(){ chrome.declarativeContent.onPageChanged.removeRules(undefined, function(){ chrome.declarativeContent.onPageChanged.addRules([ { conditions: [ // 只有打开百度才显示pageAction new chrome.declarativeContent.PageStateMatcher({pageUrl: {urlContains: 'baidu.com'}}) ], actions: [new chrome.declarativeContent.ShowPageAction()] } ]); }); }); 效果图： 5.3. 右键菜单 通过开发Chrome插件可以自定义浏览器的右键菜单，主要是通过chrome.contextMenusAPI实现，右键菜单可以出现在不同的上下文，比如普通页面、选中的文字、图片、链接，等等，如果有同一个插件里面定义了多个菜单，Chrome会自动组合放到以插件名字命名的二级菜单里，如下： 5.3.1. 最简单的右键菜单示例 // manifest.json {"permissions": ["contextMenus"]} // background.js chrome.contextMenus.create({ title: "测试右键菜单", onclick: function(){alert('您点击了右键菜单！');} }); 效果： 5.3.2. 添加右键百度搜索 // manifest.json {"permissions": ["contextMenus"， "tabs"]} // background.js chrome.contextMenus.create({ title: '使用度娘搜索：%s', // %s表示选中的文字 contexts: ['selection'], // 只有当选中文字时才会出现此右键菜单 onclick: function(params) { // 注意不能使用location.href，因为location是属于background的window对象 chrome.tabs.create({url: 'https://www.baidu.com/s?ie=utf-8&amp;wd=' + encodeURI(params.selectionText)}); } }); 效果如下： 5.3.3. 语法说明 这里只是简单列举一些常用的，完整API参见：https://developer.chrome.com/extensions/contextMenus chrome.contextMenus.create({ type: 'normal'， // 类型，可选：["normal", "checkbox", "radio", "separator"]，默认 normal title: '菜单的名字', // 显示的文字，除非为“separator”类型否则此参数必需，如果类型为“selection”，可以使用%s显示选定的文本 contexts: ['page'], // 上下文环境，可选：["all", "page", "frame", "selection", "link", "editable", "image", "video", "audio"]，默认page onclick: function(){}, // 单击时触发的方法 parentId: 1, // 右键菜单项的父菜单项ID。指定父菜单项将会使此菜单项成为父菜单项的子菜单 documentUrlPatterns: 'https://*.baidu.com/*' // 只在某些页面显示此右键菜单 }); // 删除某一个菜单项 chrome.contextMenus.remove(menuItemId)； // 删除所有自定义右键菜单 chrome.contextMenus.removeAll(); // 更新某一个菜单项 chrome.contextMenus.update(menuItemId, updateProperties); 5.4. override(覆盖特定页面) 使用override页可以将Chrome默认的一些特定页面替换掉，改为使用扩展提供的页面。 扩展可以替代如下页面： 历史记录：从工具菜单上点击历史记录时访问的页面，或者从地址栏直接输入 chrome://history 新标签页：当创建新标签的时候访问的页面，或者从地址栏直接输入 chrome://newtab 书签：浏览器的书签，或者直接输入 chrome://bookmarks 注意： 一个扩展只能替代一个页面； 不能替代隐身窗口的新标签页； 网页必须设置title，否则用户可能会看到网页的URL，造成困扰； 下面的截图是默认的新标签页和被扩展替换掉的新标签页。 代码（注意，一个插件只能替代一个默认页，以下仅为演示）： "chrome_url_overrides": { "newtab": "newtab.html", "history": "history.html", "bookmarks": "bookmarks.html" } 5.5. devtools(开发者工具) 5.5.1. 预热 使用过vue的应该见过这种类型的插件： 是的，Chrome允许插件在开发者工具(devtools)上动手脚，主要表现在： 自定义一个和多个和Elements、Console、Sources等同级别的面板； 自定义侧边栏(sidebar)，目前只能自定义Elements面板的侧边栏； 先来看2张简单的demo截图，自定义面板（判断当前页面是否使用了jQuery）： 自定义侧边栏（获取当前页面所有图片）： 5.5.2. devtools扩展介绍 主页：https://developer.chrome.com/extensions/devtools 来一张官方图片： 每打开一个开发者工具窗口，都会创建devtools页面的实例，F12窗口关闭，页面也随着关闭，所以devtools页面的生命周期和devtools窗口是一致的。devtools页面可以访问一组特有的DevTools API以及有限的扩展API，这组特有的DevTools API只有devtools页面才可以访问，background都无权访问，这些API包括： chrome.devtools.panels：面板相关； chrome.devtools.inspectedWindow：获取被审查窗口的有关信息； chrome.devtools.network：获取有关网络请求的信息； 大部分扩展API都无法直接被DevTools页面调用，但它可以像content-script一样直接调用chrome.extension和chrome.runtimeAPI，同时它也可以像content-script一样使用Message交互的方式与background页面进行通信。 5.5.3. 实例：创建一个devtools扩展 首先，要针对开发者工具开发插件，需要在清单文件声明如下： { // 只能指向一个HTML文件，不能是JS文件 "devtools_page": "devtools.html" } 这个devtools.html里面一般什么都没有，就引入一个js： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript" src="js/devtools.js"&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 可以看出来，其实真正代码是devtools.js，html文件是“多余”的，所以这里觉得有点坑，devtools_page干嘛不允许直接指定JS呢？ 再来看devtools.js的代码： // 创建自定义面板，同一个插件可以创建多个自定义面板 // 几个参数依次为：panel标题、图标（其实设置了也没地方显示）、要加载的页面、加载成功后的回调 chrome.devtools.panels.create('MyPanel', 'img/icon.png', 'mypanel.html', function(panel) { console.log('自定义面板创建成功！'); // 注意这个log一般看不到 }); // 创建自定义侧边栏 chrome.devtools.panels.elements.createSidebarPane("Images", function(sidebar) { // sidebar.setPage('../sidebar.html'); // 指定加载某个页面 sidebar.setExpression('document.querySelectorAll("img")', 'All Images'); // 通过表达式来指定 //sidebar.setObject({aaa: 111, bbb: 'Hello World!'}); // 直接设置显示某个对象 }); setPage时的效果： 以下截图示例的代码： // 检测jQuery document.getElementById('check_jquery').addEventListener('click', function() { // 访问被检查的页面DOM需要使用inspectedWindow // 简单例子：检测被检查页面是否使用了jQuery chrome.devtools.inspectedWindow.eval("jQuery.fn.jquery", function(result, isException) { var html = ''; if (isException) html = '当前页面没有使用jQuery。'; else html = '当前页面使用了jQuery，版本为：'+result; alert(html); }); }); // 打开某个资源 document.getElementById('open_resource').addEventListener('click', function() { chrome.devtools.inspectedWindow.eval("window.location.href", function(result, isException) { chrome.devtools.panels.openResource(result, 20, function() { console.log('资源打开成功！'); }); }); }); // 审查元素 document.getElementById('test_inspect').addEventListener('click', function() { chrome.devtools.inspectedWindow.eval("inspect(document.images[0])", function(result, isException){}); }); // 获取所有资源 document.getElementById('get_all_resources').addEventListener('click', function() { chrome.devtools.inspectedWindow.getResources(function(resources) { alert(JSON.stringify(resources)); }); }); 5.5.4. 调试技巧 修改了devtools页面的代码时，需要先在 chrome://extensions 页面按下Ctrl+R重新加载插件，然后关闭再打开开发者工具即可，无需刷新页面（而且只刷新页面不刷新开发者工具的话是不会生效的）。 由于devtools本身就是开发者工具页面，所以几乎没有方法可以直接调试它，直接用 chrome-extension://extid/devtools.html"的方式打开页面肯定报错，因为不支持相关特殊API，只能先自己写一些方法屏蔽这些错误，调试通了再放开。 5.6. option(选项页) 所谓options页，就是插件的设置页面，有2个入口，一个是右键图标有一个“选项”菜单，还有一个在插件管理页面： 在Chrome40以前，options页面和其它普通页面没什么区别，Chrome40以后则有了一些变化。 我们先看老版的options： { // Chrome40以前的插件配置页写法 "options_page": "options.html", } 这个页面里面的内容就随你自己发挥了，配置之后在插件管理页就会看到一个选项按钮入口，点进去就是打开一个网页，没啥好讲的。 效果: 再来看新版的optionsV2： { "options_ui": { "page": "options.html", // 添加一些默认的样式，推荐使用 "chrome_style": true }, } options.html的代码我们没有任何改动，只是配置文件改了，之后效果如下： 看起来是不是高大上了？ 几点注意： 为了兼容，建议2种都写，如果都写了，Chrome40以后会默认读取新版的方式； 新版options中不能使用alert； 数据存储建议用chrome.storage，因为会随用户自动同步； 5.7. omnibox omnibox是向用户提供搜索建议的一种方式。先来看个gif图以便了解一下这东西到底是个什么鬼： 注册某个关键字以触发插件自己的搜索建议界面，然后可以任意发挥了。 首先，配置文件如下： { // 向地址栏注册一个关键字以提供搜索建议，只能设置一个关键字 "omnibox": { "keyword" : "go" }, } 然后background.js中注册监听事件： // omnibox 演示 chrome.omnibox.onInputChanged.addListener((text, suggest) =&gt; { console.log('inputChanged: ' + text); if(!text) return; if(text == '美女') { suggest([ {content: '中国' + text, description: '你要找“中国美女”吗？'}, {content: '日本' + text, description: '你要找“日本美女”吗？'}, {content: '泰国' + text, description: '你要找“泰国美女或人妖”吗？'}, {content: '韩国' + text, description: '你要找“韩国美女”吗？'} ]); } else if(text == '微博') { suggest([ {content: '新浪' + text, description: '新浪' + text}, {content: '腾讯' + text, description: '腾讯' + text}, {content: '搜狐' + text, description: '搜索' + text}, ]); } else { suggest([ {content: '百度搜索 ' + text, description: '百度搜索 ' + text}, {content: '谷歌搜索 ' + text, description: '谷歌搜索 ' + text}, ]); } }); // 当用户接收关键字建议时触发 chrome.omnibox.onInputEntered.addListener((text) =&gt; { console.log('inputEntered: ' + text); if(!text) return; var href = ''; if(text.endsWith('美女')) href = 'http://image.baidu.com/search/index?tn=baiduimage&amp;ie=utf-8&amp;word=' + text; else if(text.startsWith('百度搜索')) href = 'https://www.baidu.com/s?ie=UTF-8&amp;wd=' + text.replace('百度搜索 ', ''); else if(text.startsWith('谷歌搜索')) href = 'https://www.google.com.tw/search?q=' + text.replace('谷歌搜索 ', ''); else href = 'https://www.baidu.com/s?ie=UTF-8&amp;wd=' + text; openUrlCurrentTab(href); }); // 获取当前选项卡ID function getCurrentTabId(callback) { chrome.tabs.query({active: true, currentWindow: true}, function(tabs) { if(callback) callback(tabs.length ? tabs[0].id: null); }); } // 当前标签打开某个链接 function openUrlCurrentTab(url) { getCurrentTabId(tabId =&gt; { chrome.tabs.update(tabId, {url: url}); }) } 5.8. 桌面通知 Chrome提供了一个chrome.notificationsAPI以便插件推送桌面通知，暂未找到chrome.notifications和HTML5自带的Notification的显著区别及优势。 在后台JS中，无论是使用chrome.notifications还是Notification都不需要申请权限（HTML5方式需要申请权限），直接使用即可。 最简单的通知： 代码： chrome.notifications.create(null, { type: 'basic', iconUrl: 'img/icon.png', title: '这是标题', message: '您刚才点击了自定义右键菜单！' }); 通知的样式可以很丰富： 这个没有深入研究，有需要的可以去看官方文档。 5种类型的JS对比 Chrome插件的JS主要可以分为这5类：injected script、content-script、popup js、background js和devtools js， 6.1. 权限对比 {% raw %} JS种类 可访问的API DOM访问情况 JS访问情况 直接跨域 injected script 和普通JS无任何差别，不能访问任何扩展API 可以访问 可以访问 不可以 content script 只能访问 extension、runtime等部分API 可以访问 不可以 不可以 popup js 可访问绝大部分API，除了devtools系列 不可直接访问 不可以 可以 background js 可访问绝大部分API，除了devtools系列 不可直接访问 不可以 可以 devtools js 只能访问 devtools、extension、runtime等部分API 可以 可以 不可以 6.2. 调试方式对比 JS类型 调试方式 图片说明 injected script 直接普通的F12即可 懒得截图 content-script 打开Console,如图切换 popup-js popup页面右键审查元素 background 插件管理页点击背景页即可 devtools-js 暂未找到有效方法 - {% endraw %} 消息通信 通信主页：https://developer.chrome.com/extensions/messaging 前面我们介绍了Chrome插件中存在的5种JS，那么它们之间如何互相通信呢？下面先来系统概况一下，然后再分类细说。需要知道的是，popup和background其实几乎可以视为一种东西，因为它们可访问的API都一样、通信机制一样、都可以跨域。 7.1. 互相通信概览 注：-表示不存在或者无意义，或者待验证。 injected-script content-script popup-js background-js injected-script - window.postMessage - - content-script window.postMessage - chrome.runtime.sendMessage chrome.runtime.connect chrome.runtime.sendMessage chrome.runtime.connect popup-js - chrome.tabs.sendMessage chrome.tabs.connect - chrome.extension. getBackgroundPage() background-js - chrome.tabs.sendMessage chrome.tabs.connect chrome.extension.getViews - devtools-js chrome.devtools. inspectedWindow.eval - chrome.runtime.sendMessage chrome.runtime.sendMessage 7.2. 通信详细介绍 7.2.1. popup和background popup可以直接调用background中的JS方法，也可以直接访问background的DOM： // background.jsfunction test(){ alert(‘我是background！’);} // popup.jsvar bg = chrome.extension.getBackgroundPage();bg.test(); // 访问bg的函数alert(bg.document.body.innerHTML); // 访问bg的DOM 小插曲，今天碰到一个情况，发现popup无法获取background的任何方法，找了半天才发现是因为background的js报错了，而你如果不主动查看background的js的话，是看不到错误信息的，特此提醒。 至于background访问popup如下（前提是popup已经打开）： var views = chrome.extension.getViews({type:‘popup’});if(views.length &gt; 0) { console.log(views[0].location.href);} 7.2.2. popup或者bg向content主动发送消息 background.js或者popup.js： function sendMessageToContentScript(message, callback){ chrome.tabs.query({active: true, currentWindow: true}, function(tabs) { chrome.tabs.sendMessage(tabs[0].id, message, function(response) { if(callback) callback(response); }); });}sendMessageToContentScript({cmd:‘test’, value:‘你好，我是popup！’}, function(response){ console.log(‘来自content的回复：’+response);}); content-script.js接收： chrome.runtime.onMessage.addListener(function(request, sender, sendResponse){ // console.log(sender.tab ?”from a content script:” + sender.tab.url :”from the extension”); if(request.cmd == ‘test’) alert(request.value); sendResponse(‘我收到了你的消息！’);}); 双方通信直接发送的都是JSON对象，不是JSON字符串，所以无需解析，很方便（当然也可以直接发送字符串）。 网上有些老代码中用的是chrome.extension.onMessage，没有完全查清二者的区别(貌似是别名)，但是建议统一使用chrome.runtime.onMessage。 7.2.3. content-script主动发消息给后台 content-script.js： chrome.runtime.sendMessage({greeting: ‘你好，我是content-script呀，我主动发消息给后台！’}, function(response) { console.log(‘收到来自后台的回复：’ + response);}); background.js 或者 popup.js： // 监听来自content-script的消息chrome.runtime.onMessage.addListener(function(request, sender, sendResponse){ console.log(‘收到来自content-script的消息：’); console.log(request, sender, sendResponse); sendResponse(‘我是后台，我已收到你的消息：’ + JSON.stringify(request));}); 注意事项： content_scripts向popup主动发消息的前提是popup必须打开！否则需要利用background作中转； 如果background和popup同时监听，那么它们都可以同时收到消息，但是只有一个可以sendResponse，一个先发送了，那么另外一个再发送就无效； 7.2.4. injected script和content-script content-script和页面内的脚本（injected-script自然也属于页面内的脚本）之间唯一共享的东西就是页面的DOM元素，有2种方法可以实现二者通讯： 可以通过window.postMessage和window.addEventListener来实现二者消息通讯； 通过自定义DOM事件来实现； 第一种方法（推荐）： injected-script中： window.postMessage({“test”: ‘你好！’}, ‘*’); content script中： window.addEventListener(“message”, function(e){ console.log(e.data);}, false); 第二种方法： injected-script中： var customEvent = document.createEvent(‘Event’);customEvent.initEvent(‘myCustomEvent’, true, true);function fireCustomEvent(data) { hiddenDiv = document.getElementById(‘myCustomEventDiv’); hiddenDiv.innerText = data hiddenDiv.dispatchEvent(customEvent);}fireCustomEvent(‘你好，我是普通JS！’); content-script.js中： var hiddenDiv = document.getElementById(‘myCustomEventDiv’);if(!hiddenDiv) { hiddenDiv = document.createElement(‘div’); hiddenDiv.style.display = ‘none’; document.body.appendChild(hiddenDiv);}hiddenDiv.addEventListener(‘myCustomEvent’, function() { var eventData = document.getElementById(‘myCustomEventDiv’).innerText; console.log(‘收到自定义事件消息：’ + eventData);}); 7.3. 长连接和短连接 其实上面已经涉及到了，这里再单独说明一下。Chrome插件中有2种通信方式，一个是短连接（chrome.tabs.sendMessage和chrome.runtime.sendMessage），一个是长连接（chrome.tabs.connect和chrome.runtime.connect）。 短连接的话就是挤牙膏一样，我发送一下，你收到了再回复一下，如果对方不回复，你只能重新发，而长连接类似WebSocket会一直建立连接，双方可以随时互发消息。 短连接上面已经有代码示例了，这里只讲一下长连接。 popup.js： getCurrentTabId((tabId) =&gt; { var port = chrome.tabs.connect(tabId, {name: ‘test-connect’}); port.postMessage({question: ‘你是谁啊？’}); port.onMessage.addListener(function(msg) { alert(‘收到消息：’+msg.answer); if(msg.answer &amp;&amp; msg.answer.startsWith(‘我是’)) { port.postMessage({question: ‘哦，原来是你啊！’}); } });}); content-script.js： // 监听长连接chrome.runtime.onConnect.addListener(function(port) { console.log(port); if(port.name == ‘test-connect’) { port.onMessage.addListener(function(msg) { console.log(‘收到长连接消息：’, msg); if(msg.question == ‘你是谁啊？’) port.postMessage({answer: ‘我是你爸！’}); }); }}); 其它补充 8.1. 动态注入或执行JS 虽然在background和popup中无法直接访问页面DOM，但是可以通过chrome.tabs.executeScript来执行脚本，从而实现访问web页面的DOM（注意，这种方式也不能直接访问页面JS）。 示例manifest.json配置： { “name”: “动态JS注入演示”, … “permissions”: [ “tabs”, “http:///“, “https:///“ ], …} JS： // 动态执行JS代码chrome.tabs.executeScript(tabId, {code: ‘document.body.style.backgroundColor=”red”‘});// 动态执行JS文件chrome.tabs.executeScript(tabId, {file: ‘some-script.js’}); 8.2. 动态注入CSS 示例manifest.json配置： { “name”: “动态CSS注入演示”, … “permissions”: [ “tabs”, “http:///“, “https:///“ ], …} JS代码： // 动态执行CSS代码，TODO，这里有待验证chrome.tabs.insertCSS(tabId, {code: ‘xxx’});// 动态执行CSS文件chrome.tabs.insertCSS(tabId, {file: ‘some-style.css’}); 8.3. 获取当前窗口ID chrome.windows.getCurrent(function(currentWindow){ console.log(‘当前窗口ID：’ + currentWindow.id);}); 8.4. 获取当前标签页ID 一般有2种方法： // 获取当前选项卡IDfunction getCurrentTabId(callback){ chrome.tabs.query({active: true, currentWindow: true}, function(tabs) { if(callback) callback(tabs.length ? tabs[0].id: null); });} 获取当前选项卡id的另一种方法，大部分时候都类似，只有少部分时候会不一样（例如当窗口最小化时） // 获取当前选项卡IDfunction getCurrentTabId2(){ chrome.windows.getCurrent(function(currentWindow) { chrome.tabs.query({active: true, windowId: currentWindow.id}, function(tabs) { if(callback) callback(tabs.length ? tabs[0].id: null); }); });} 8.5. 本地存储 本地存储建议用chrome.storage而不是普通的localStorage，区别有好几点，个人认为最重要的2点区别是： chrome.storage是针对插件全局的，即使你在background中保存的数据，在content-script也能获取到； chrome.storage.sync可以跟随当前登录用户自动同步，这台电脑修改的设置会自动同步到其它电脑，很方便，如果没有登录或者未联网则先保存到本地，等登录了再同步至网络； 需要声明storage权限，有chrome.storage.sync和chrome.storage.local2种方式可供选择，使用示例如下： // 读取数据，第一个参数是指定要读取的key以及设置默认值chrome.storage.sync.get({color: ‘red’, age: 18}, function(items) { console.log(items.color, items.age);});// 保存数据chrome.storage.sync.set({color: ‘blue’}, function() { console.log(‘保存成功！’);}); 8.6. webRequest 通过webRequest系列API可以对HTTP请求进行任性地修改、定制，这里通过beforeRequest来简单演示一下它的冰山一角： //manifest.json{ // 权限申请 “permissions”: [ “webRequest”, // web请求 “webRequestBlocking”, // 阻塞式web请求 “storage”, // 插件本地存储 “http:///“, // 可以通过executeScript或者insertCSS访问的网站 “https:///“ // 可以通过executeScript或者insertCSS访问的网站 ],} // background.js// 是否显示图片var showImage;chrome.storage.sync.get({showImage: true}, function(items) { showImage = items.showImage;});// web请求监听，最后一个参数表示阻塞式，需单独声明权限：webRequestBlockingchrome.webRequest.onBeforeRequest.addListener(details =&gt; { // cancel 表示取消本次请求 if(!showImage &amp;&amp; details.type == ‘image’) return {cancel: true}; // 简单的音视频检测 // 大部分网站视频的type并不是media，且视频做了防下载处理，所以这里仅仅是为了演示效果，无实际意义 if(details.type == ‘media’) { chrome.notifications.create(null, { type: ‘basic’, iconUrl: ‘img/icon.png’, title: ‘检测到音视频’, message: ‘音视频地址：’ + details.url, }); }}, {urls: [“&lt;all_urls&gt;”]}, [“blocking”]); 8.7. 国际化 插件根目录新建一个名为_locales的文件夹，再在下面新建一些语言的文件夹，如en、zh_CN、zh_TW，然后再在每个文件夹放入一个messages.json，同时必须在清单文件中设置default_locale。 _locales\en\messages.json内容： { “pluginDesc”: {“message”: “A simple chrome extension demo”}, “helloWorld”: {“message”: “Hello World!”}} _locales\zh_CN\messages.json内容： { “pluginDesc”: {“message”: “一个简单的Chrome插件demo”}, “helloWorld”: {“message”: “你好啊，世界！”}} 在manifest.json和CSS文件中通过MSG_messagename引入，如： { “description”: “MSG_pluginDesc“, // 默认语言 “default_locale”: “zh_CN”,} JS中则直接chrome.i18n.getMessage(“helloWorld”)。 测试时，通过给chrome建立一个不同的快捷方式chrome.exe –lang=en来切换语言，如： 英文效果： 中文效果： 8.8. API总结 比较常用用的一些API系列： chrome.tabs chrome.runtime chrome.webRequest chrome.window chrome.storage chrome.contextMenus chrome.devtools chrome.extension 经验总结 9.1. 查看已安装插件路径 已安装的插件源码路径：C:\Users\用户名\AppData\Local\Google\Chrome\User Data\Default\Extensions，每一个插件被放在以插件ID为名的文件夹里面，想要学习某个插件的某个功能是如何实现的，看人家的源码是最好的方法了： 如何查看某个插件的ID？进入 chrome://extensions ，然后勾线开发者模式即可看到了。 9.2. 特别注意background的报错 很多时候你发现你的代码会莫名其妙的失效，找来找去又找不到原因，这时打开background的控制台才发现原来某个地方写错了导致代码没生效，正式由于background报错的隐蔽性(需要主动打开对应的控制台才能看到错误)，所以特别注意这点。 9.3. 如何让popup页面不关闭 在对popup页面审查元素的时候popup会被强制打开无法关闭，只有控制台关闭了才可以关闭popup，原因很简单：如果popup关闭了控制台就没用了。这种方法在某些情况下很实用！ 9.4. 不支持内联JavaScript的执行 也就是不支持将js直接写在html中，比如： &lt;input id=“btn” type=“button” value=“收藏” onclick=“test()”/&gt; 报错如下： Refused to execute inline event handler because it violates the following Content Security Policy directive: “script-src ‘self’ blob: filesystem: chrome-extension-resource:”. Either the ‘unsafe-inline’ keyword, a hash (‘sha256-…’), or a nonce (‘nonce-…’) is required to enable inline execution. 解决方法就是用JS绑定事件： $(‘#btn’).on(‘click’, function(){alert(‘测试’)}); 另外，对于A标签，这样写href=”javascript:;”然后用JS绑定事件虽然控制台会报错，但是不受影响，当然强迫症患者受不了的话只能写成href=”#”了。 如果这样写： &lt;a href=“javascript:;” id=“get_secret”&gt;请求secret&lt;/a&gt; 报错如下： Refused to execute JavaScript URL because it violates the following Content Security Policy directive: “script-src ‘self’ blob: filesystem: chrome-extension-resource:”. Either the ‘unsafe-inline’ keyword, a hash (‘sha256-…’), or a nonce (‘nonce-…’) is required to enable inline execution. 9.5. 注入CSS的时候必须小心 由于通过content_scripts注入的CSS优先级非常高，几乎仅次于浏览器默认样式，稍不注意可能就会影响一些网站的展示效果，所以尽量不要写一些影响全局的样式。 之所以强调这个，是因为这个带来的问题非常隐蔽，不太容易找到，可能你正在写某个网页，昨天样式还是好好的，怎么今天就突然不行了？然后你辛辛苦苦找来找去，找了半天才发现竟然是因为插件里面的一个样式影响的！ 打包与发布 打包的话直接在插件管理页有一个打包按钮： 然后会生成一个.crx文件，要发布到Google应用商店的话需要先登录你的Google账号，然后花5个$注册为开发者，本人太穷，就懒得亲自验证了，有发布需求的自己去整吧。 参考 11.1. 官方资料 推荐查看官方文档，虽然是英文，但是全且新，国内的中文资料都比较旧（注意以下全部需要FQ）： Chrome插件官方文档主页 Chrome插件官方示例 manifest清单文件 permissions权限 chrome.xxx.api文档 模糊匹配规则语法详解 11.2. 第三方资料 部分中文资料，不是特别推荐： 360安全浏览器开发文档 360极速浏览器Chrome扩展开发文档 Chrome扩展开发极客系列博客 附图 附图：Chrome高清png格式logo：个人网站：https://haoji.megithub：https://github.com/sxei博客园：http://www.cnblogs.com/liuxianancopyright ©2012-2018 小茗同学 【转载文章务必保留出处和署名，谢谢！】文章来源： 【干货】Chrome插件(扩展)开发全攻略]]></content>
      <tags>
        <tag>chrome插件开发</tag>
        <tag>chrome</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery动画做一个折叠菜单]]></title>
    <url>%2F2019%2F05%2F14%2FjQuery%E5%8A%A8%E7%94%BB%E5%81%9A%E4%B8%80%E4%B8%AA%E6%8A%98%E5%8F%A0%E8%8F%9C%E5%8D%95%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前面利用了jQuery动画做了一个对联广告，这次再次利用jQuery的其他动画做一个折叠菜单，做出一个较为美观的折叠菜单。直接上代码： css部分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;style&gt; * &#123; margin: 0; padding: 0; list-style: none; &#125; .l1&#123; width: 400px; margin: 0 auto; margin-top: 10px; &#125; .l1&gt;li&#123; /* border: 1px solid #000; border-collapse: collapse!important; */ outline: 1px solid black; font-size: 20px; /* height: 40px; line-height: 40px; */ &#125; .l1&gt;li&gt;div&#123; outline: 1px solid black; border-top: 1px solid #000; position: relative; &#125; .l1&gt;li&gt;div&gt;span&#123; display: inline-block; position: absolute; right: 10px; &#125; .l2&#123; display: none; &#125; .l2&gt;li&#123; /* outline: 1px solid black; */ /* border: 1px solid #000; */ border-collapse: collapse!important; font-size: 16px; height: 40px; line-height: 40px; &#125; .trans&#123; transform: rotate(90deg); -ms-transform: rotate(90deg); /* IE 9 */ -webkit-transform: rotate(90deg); /* Safari and Chrome */ -o-transform: rotate(90deg); /* Opera */ -moz-transform: rotate(90deg); /* Firefox */ &#125;&lt;/style&gt; html部分 12345678910111213141516171819202122232425262728293031323334353637383940&lt;body&gt; &lt;ul class="l1"&gt; &lt;li&gt; &lt;div&gt;一级菜单&lt;span&gt;&gt;&lt;/span&gt;&lt;/div&gt; &lt;ul class="l2"&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;div&gt;一级菜单&lt;span&gt;&gt;&lt;/span&gt;&lt;/div&gt; &lt;ul class="l2"&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;div&gt;一级菜单&lt;span&gt;&gt;&lt;/span&gt;&lt;/div&gt; &lt;ul class="l2"&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;div&gt;一级菜单&lt;span&gt;&gt;&lt;/span&gt;&lt;/div&gt; &lt;ul class="l2"&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/body&gt; js部分 12345678910111213141516&lt;script&gt; var index=1; $(function()&#123; $('.l1&gt;li&gt;div').click(function()&#123; index++; // 因为动画队列的存在，所以在执行新的动画之前要停止之前的动画 $(this).next().stop().slideToggle(); if(index%2==0)&#123; $(this).children().addClass('trans'); &#125; else&#123; $(this).children().removeClass('trans'); &#125; &#125;) &#125;) &lt;/script&gt; 效果图： 总结 要注意要找对执行动画的元素，可以用next(),chidren()等方法来找。 要注意动画队列，当我们快速多次的触发动画的时候，每触发一次就会加入动画队列，并且按照顺序会全部执行完毕，如果在执行新的动画之前我们不先停止之前的动画，那么就不会立即执行我们想要的动画，并且在我们不触发动画之后很有可能还会有很长一段的动画要执行。]]></content>
      <tags>
        <tag>JS</tag>
        <tag>jQuery</tag>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery动画之写一个对联广告]]></title>
    <url>%2F2019%2F05%2F14%2FjQuery%E5%86%99%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%81%94%E5%B9%BF%E5%91%8A%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jQuery自带了许多动画效果，我们可以利用这些动画效果比较方便的做出一个对联广告。直接上代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;style&gt; body &#123; margin: 0; padding: 0; height: 2000px; &#125; .left, .right &#123; width: 80px; height: 200px; background: red; position: fixed; top: 260px; &#125; .right &#123; right: 0px; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class="left"&gt; &lt;/div&gt; &lt;div class="right"&gt; &lt;/div&gt; &lt;script&gt; $(function () &#123; $('.left,.right').hide(); // 在网页往下滚动之前先隐藏 var $height = $('body,html').scrollTop(); $(window).scroll(function () &#123; // 这里用到了scroll事件来监听网页的滚动 // 通过scrollTop方法来获取滚动的值 $height = $('body,html').scrollTop(); // 如果大于500就通过动画显示出来，否则隐藏 if ($height &gt;= 500) &#123; $('.left,.right').show(1000); &#125; else &#123; $('.left,.right').hide(1000); &#125; &#125;) &#125;) &lt;/script&gt;&lt;/body&gt; 总结： 这里一定要用到scroll事件，否则无法动态获取到滚动了多少 在使用scrollTop方法获取网页的滚动的值时一定要这样写$(&#39;body,html&#39;).scrollTop();既要写body，也要写html，兼容处理，如果只写一个可能会获取到不正确的值]]></content>
      <categories>
        <category>页面小功能</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>jQuery</tag>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery写一个简单的选项卡]]></title>
    <url>%2F2019%2F05%2F14%2FjQuery%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E9%80%89%E9%A1%B9%E5%8D%A1%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这次通过jQuery的方法来写一个小小的选项卡功能，通过jQuery实现起来也是十分的简单。直接上代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;style&gt; * &#123; margin: 0; padding: 0; list-style: none; &#125; div &#123; border: 1px solid #000; width: 800px; height: 400px; margin: 0 auto; position: relative; &#125; .ch &#123; top: 320px; left: 650px; position: absolute; &#125; .ch&gt;li &#123; display: inline-block; width: 20px; height: 20px; background-color: #ccc; margin-right: 10px; &#125; img &#123; width: 100%; height: 400px; display: none; &#125; .current &#123; display: block; background-color: red !important; &#125;&lt;/style&gt;&lt;body&gt; &lt;div&gt; &lt;ul class="imgs"&gt; &lt;li&gt;&lt;img class="current" src="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2489492398,1961915359&amp;fm=26&amp;gp=0.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1287814793,457485829&amp;fm=26&amp;gp=0.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1501075685,574908757&amp;fm=11&amp;gp=0.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=3662540589,314327097&amp;fm=11&amp;gp=0.jpg" alt=""&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ul class="ch"&gt; &lt;li class="current"&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; $(function () &#123; $('.ch&gt;li').mouseenter(function () &#123; $(this).addClass('current').siblings().removeClass('current'); // 给当前操作的小方块添加样式，其他的兄弟小方块去除样式 var index = $(this).index(); // 获取当前是第几个小方块，用来确定是第几张图片 $('.imgs&gt;li&gt;img').eq(index).addClass('current').parent().siblings().children() .removeClass('current'); // 给对应的图片添加样式，其他的图片删除样式 &#125;) &#125;) &lt;/script&gt;&lt;/body&gt; 效果图： 总结 写这个选项卡思路很简单，但是在布局的时候没有考虑好导致在给img标签删除样式的时候会比较麻烦，需要先找到父级li，然后找到他的兄弟，再找到他们的儿子，下次要注意避免出现这种情况。]]></content>
      <categories>
        <category>页面小功能</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>jQuery</tag>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery学习（事件处理）]]></title>
    <url>%2F2019%2F05%2F14%2FjQuery%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jQuery中也有许多事件处理的函数，功能强大，使用起来也比原声js要更加的简单和方便，这次学习以下jQuery的事件处理函数与冒泡行为以及自定义事件等等，以及动手实践，编写实例。 事件绑定jQuery中事件绑定有两种方式 eventName(function(){}) 绑定对应事件名的监听, 例如：$(‘#div’).click(function(){});优缺点：编写方便，但是不支持所有事件与自定义事件，但常用的事件基本上都是支持的。 on(eventName, funcion(){}) 通用的绑定事件监听, 例如：$(‘#div’).on(‘click’, function(){});优缺点：支持所有事件，但是编码的时候事件名要自己敲，但是最强大，支持所有事件与自定义事件。 事件解绑 jQuery中可以通过off(eventName,function);解绑事件 获取事件坐标当事件被触发时,系统会将事件对象(event)传递给回调函数,通过event对象我们就能获取时间的坐标，获取坐标有三种方式： event.offsetX, event.offsetY 相对于事件元素左上角 event.pageX, event.pageY 相对于页面的左上角 event.clientX, event.clientY 相对于视口的左上角 实例示例代码123456789101112131415161718192021222324252627&lt;style&gt;button&#123; margin-top: 600px;&#125;&lt;/style&gt;&lt;body&gt; &lt;button&gt;这是按钮一&lt;/button&gt; &lt;button&gt;这是按钮二&lt;/button&gt; &lt;button&gt;这是按钮三&lt;/button&gt; &lt;button&gt;这是按钮四&lt;/button&gt; &lt;script&gt; $(function()&#123; $('button').eq(0).click(function(Event)&#123; alert(Event.offsetY); // 结果：10 &#125;) $('button').eq(1).click(function(Event)&#123; alert(Event.pageY); // 结果：626 &#125;) $('button').eq(2).click(function(Event)&#123; alert(Event.clientY); // 结果：630 &#125;) &#125;) &lt;/script&gt;&lt;/body&gt; 阻止事件冒泡 什么是事件冒泡·事件冒泡就是同属说就是事件从里往外的一个触发过程1234567891011121314151617181920212223242526272829303132&lt;style&gt; .father &#123; width: 400px; height: 400px; background-color: red; &#125; .son &#123; width: 200px; height: 200px; background-color: blue; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class="father"&gt; 这是爸爸 &lt;div class="son"&gt; 这是儿子 &lt;/div&gt; &lt;/div&gt; &lt;script&gt; $(function () &#123; $('.father').click(function()&#123; alert('这是爸爸'); &#125;) $('.son').click(function()&#123; alert('这是儿子'); &#125;) &#125;) &lt;/script&gt;&lt;/body&gt; 当我单击了儿子之后，由于事件冒泡，事件会由里往外触发，所以先弹出儿子，再弹出爸爸，很多时候这都不是我们想要的结果，我们通常只是需要触发儿子的事件，所以这个时候我们就需要阻止事件冒泡。 如何阻止事件冒泡?event.stopPropagation()1234567891011$(function () &#123; $('.father').click(function()&#123; alert('这是爸爸'); &#125;) &lt;!-- 传递了事件对象 --&gt; $('.son').click(function(event)&#123; event.stopPropagation(); &lt;!-- 组阻止了事件冒泡 --&gt; alert('这是儿子'); &#125;) &#125;) 此时我们再次单击儿子就会发现就只弹出了儿子的单击事件，并没有触发父亲的事件，就达到了我们的效果 阻止默认行为 什么是默认行为·就是一些元素默认自带的行为，比如单击超链接会自动跳转等等。 如何阻止默认行为event.preventDefault()123456789&lt;a href="www.baidu.com"&gt;这是一个跳转到百度的超链接&lt;/a&gt;&lt;script&gt;$(function()&#123; $('a').click(function(event)&#123; event.preventDefault(); // 此时单击超链接时就不会进行跳转了 &#125;)&#125;)&lt;/script&gt; 自动触发事件 什么是自动触发事件?·通过代码控制事件, 不用人为点击/移入/移除等事件就能被触发 自动触发事件方式$(“selector”).trigger(“eventName”);触发事件的同时会触发事件冒泡触发事件的同时会触发事件默认行为$(“selector”).triggerHandler(“eventName”);触发事件的同时不会触发事件冒泡触发事件的同时不会触发事件默认行为 以triggerHandler()为例：12345678910111213&lt;body&gt; &lt;button&gt;这是一个按钮&lt;/button&gt; &lt;script&gt; $(function()&#123; $('button').eq(0).click(function()&#123; alert('我单击了按钮'); // 原本要单击才会弹出内容 &#125;) $('button').triggerHandler('click'); // 现在在网页出现后就会弹出 &#125;) &lt;/script&gt;&lt;/body&gt; 事件命名空间我们都知道jQuery可以给同一元素绑定多个相同的事件，且都能够触发，那么在多人开发中就可能会遇到多人对同意元素操作的情况，那么为了方便管理与区分，我们就可以在注册事件的时候使用命名空间 格式：eventName.命名空间，如 click.hsl() 添加事件命名空间的前提条件1、事件是通过on来绑定的，也就是这种方法on(eventName, funcion(){})2、通过trigger触发事件 注意点(面试题):·不带命名空间事件被trigger调用,会触发带命名空间事件·带命名空间事件被trigger调用,只会触发带命名空间事件·下级不带命名空间事件被trigger调用,会冒泡触发上级不带命名空间和带命名空间事件·下级带命名空间事件被trigger调用,不会触发上级不带命名空间事件·下级带命名空间事件被trigger调用,会触发上级带命名空间事件 自定义事件 什么是自定义事件？自定义事件，可以自己定义事件的名称，然后通过这个名称还能触发相应的功能 自定义事件的前提1、事件是通过on来绑定的，也就是这种方法on(eventName, funcion(){})2、通过trigger触发事件例如：12345678910111213&lt;body&gt; &lt;button&gt;这是一个按钮&lt;/button&gt; &lt;script&gt; $(function()&#123; $('button').on('hsl',function()&#123; alert('这是一个自定义事件！'); // 自定义了一个名为hsl的事件 &#125;) $('button').triggerHandler('hsl'); // 通过trigger来触发 &#125;) &lt;/script&gt;&lt;/body&gt; 事件委托 事件委托的原理&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;事件委托是通过冒泡机制来实现的，例如有一个父元素，里面有许多子元素，我们无需给这众多的子元素都添加单击事件，我们只需给父级元素添加一个单击事件，那么我们在单击子元素的时候，就会网上冒泡，执行父元素的事件，就相当于是委托父级元素来执行一样。 事件委托的好处&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;减少监听数量：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能，因为需要不断的与dom节点进行交互，访问dom的次数越多，引起浏览器重绘与重排的次数也就越多，就会延长整个页面的交互就绪时间每个监听的函数都是一个对象，是对象就会占用内存，对象越多，内存占用率就越大，自然性能就越差… …&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;新增元素自动有事件响应处理：默认的情况下新增元素是无法相应增添前就有的事件。就可以通过冒泡到原本就有的父级元素来触发事件。 jQuery中如何添加事件委托：delegate(selector,[type],[data],fn)下面看一个例子： 1234567891011121314151617181920&lt;body&gt; &lt;ul class="father"&gt; &lt;li class="son"&gt;这是内容&lt;/li&gt; &lt;li class="son"&gt;这是内容&lt;/li&gt; &lt;li class="son"&gt;这是内容&lt;/li&gt; &lt;/ul&gt; &lt;button&gt;增加li&lt;/button&gt; &lt;script&gt; $(function()&#123; $('.son').click(function()&#123; alert('我是原本就有的li'); // 单击li时应该会有弹窗 &#125;) $('button').click(function()&#123; $('.father').append('&lt;li&gt;我是新增的li&lt;/li&gt;') // 单击新增li &#125;) &#125;) &lt;/script&gt;&lt;/body&gt; 运行以上代码，我们可以发现一个问题，单击原有的li时会有弹窗，但是单击后面新创建的li时却并没有弹窗，因为我们没有给后面创建的li添加单击事件。 此时我们使用事件委托就可以解决问题：123456789101112131415161718192021222324&lt;body&gt; &lt;ul class="father"&gt; &lt;li class="son"&gt;这是内容&lt;/li&gt; &lt;li class="son"&gt;这是内容&lt;/li&gt; &lt;li class="son"&gt;这是内容&lt;/li&gt; &lt;/ul&gt; &lt;button&gt;增加li&lt;/button&gt; &lt;script&gt; $(function()&#123; // $('.son').click(function()&#123; // alert('我是原本就有的li'); // &#125;) // 原本的单击事件也可以不需要了 $('button').click(function()&#123; $('.father').append('&lt;li&gt;我是新增的li&lt;/li&gt;') &#125;) // 通过事件委托，新添加的也能有弹窗 $('.father').delegate('li','click',function()&#123; alert('我是li'); &#125;) &#125;) &lt;/script&gt;&lt;/body&gt; 改用事件委托后，不管是新添加的还是本身就存在的li，都能成功的弹窗(原理是向上冒泡，所以要支持冒泡的事件才能有效果)]]></content>
      <categories>
        <category>学习笔记</category>
        <category>jQuery学习笔记</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery实现轮播图]]></title>
    <url>%2F2019%2F05%2F13%2FjQuery%E5%AE%9E%E7%8E%B0%E8%BD%AE%E6%92%AD%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最近开始尝试着自己写轮播图，知道轮播图的原理，通过js顶死器不断的重复的给要轮播的图片添加和删除样式，在css样式中通过display中的 none 和block 来切换显示的图片，再加上过渡效果即可实现好看的轮播图，我准备用递归函数写，但是却不知道在哪出现了问题，能够实现第一轮的正常轮播，但是后面的轮播却会出现问题，不断的检查问题，还是没有找出问题，最后放弃用递归的写法，再参考别人的代码，成功实现了轮播图功能。直接放上代码: html部分：12345678910111213141516171819202122232425&lt;div class="lunbo"&gt; &lt;div class="imgs"&gt; &lt;!-- 两个左右切换的按钮 --&gt; &lt;span class="left"&gt;&lt;&lt;/span&gt; &lt;span class="right"&gt;&gt;&lt;/span&gt; &lt;!-- 需要轮播的六张图片 --&gt; &lt;ul&gt; &lt;li class="current"&gt;&lt;img src="img/a.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="img/b.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="img/c.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="img/d.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="img/e.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="img/f.jpg" alt=""&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;!-- 图片下面部分可以用来切换图片的圆点 --&gt; &lt;ul class="dot"&gt; &lt;li class="current"&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; html部分比较简单。 css部分1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980*&#123; margin: 0; padding: 0; list-style: none; text-decoration: none;&#125;.lunbo&#123; width: 100%; height:400px; position: relative;&#125;.lunbo img&#123; width: 100%; height: 450px; position: absolute; top: 0px;&#125;.left&#123; position: absolute; display: inline-block; font-weight: bolder; z-index: 99; left: 0px; width: 50px; height: 100px; line-height: 100px; background: #ccc;; top: 135px; font-size: 60px; text-align: center; opacity: 0.3;&#125;.right&#123; position: absolute; display: inline-block; font-weight: bolder; z-index: 99; right: 0px; width: 50px; height: 100px; line-height: 100px; background: #ccc;; top: 135px; font-size: 60px; text-align: center; opacity: 0.3;&#125;.imgs&gt;ul li&#123; /* 先设置所有的图片都不显示 */ display: none;&#125;.imgs .current&#123; /* 让第一张图片显示 */ display: block;&#125;.dot .current&#123; /* 通过给小圆点来添加current类来使其变为红点 */ background:red;&#125;.dot&#123; z-index: 99; position: absolute; top:300px; /* 可以使所有的小圆点整体居中 */ left: 50%; transform: translate(-50%, -50%);&#125;.dot li&#123; /* 小圆点的默认样式 */ background: white; width: 15px; height: 15px; border-radius:50%; display: inline-block; margin-right: 20px;&#125;.dot&gt;li:hover&#123; /* 使鼠标经过左右切换的按钮变为一只手 */ cursor: pointer;&#125; 很正常的css样式设置，很多地方还不是特别的熟练，不是完美，代码还有很多可以优化的地方。 js部分 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950$(function () &#123; var timer = null; var cur = 0; var len = $(".imgs&gt;ul li").length; // 右切换 $('.right').click(function chr() &#123; cur = $('.dot&gt;.current').index(); if (cur == 5) &#123; $(".imgs&gt;ul li").eq(0).fadeIn(400).siblings("li").fadeOut(400); $(".dot&gt;li").eq(0).addClass("current").siblings().removeClass("current"); &#125; $(".dot&gt;li").eq(cur + 1).addClass("current").siblings().removeClass("current"); $(".imgs&gt;ul li").eq(cur + 1).fadeIn(400).siblings("li").fadeOut(400); &#125;); // 左切换 $('.left').click(function chl() &#123; cur = $('.dot&gt;.current').index(); if (cur == 0) &#123; $(".imgs&gt;ul li").eq(5).fadeIn(400).siblings("li").fadeOut(400); $(".dot&gt;li").eq(5).addClass("current").siblings().removeClass("current"); &#125; $(".dot&gt;li").eq(cur - 1).addClass("current").siblings().removeClass("current"); $(".imgs&gt;ul li").eq(cur - 1).fadeIn(400).siblings("li").fadeOut(400); &#125;); //鼠标滑过容器停止播放 $(".imgs").hover(function () &#123; clearInterval(timer); &#125;, function () &#123; showImg(); &#125;); // 遍历所有圆点导航实现划过切换至对应的图片 $(".dot&gt;li").click(function () &#123; clearInterval(timer); cur = $(this).index(); $(this).addClass("current").siblings().removeClass("current"); $(".imgs&gt;ul li").eq(cur).fadeIn(400).siblings("li").fadeOut(400); &#125;); //定义图片切换函数 function showImg() &#123; timer = setInterval(function () &#123; cur++; if (cur &gt;= len) &#123; cur = 0; &#125; $(".imgs&gt;ul li").eq(cur).fadeIn(400).siblings("li").fadeOut(400); $(".dot&gt;li").eq(cur).addClass("current").siblings().removeClass("current"); &#125;, 2000); &#125; showImg();&#125;); 最后整体思路没有变，但图片的切换就没有通过切换类来实现，而是使用了更加方便的jQuery的fadeIn()方法和fadeOut()，可以直接实现淡入淡出效果。 小圆点切换的实现还是通过切换类的方法 鼠标移到图片上自动停止播放则是通过jQuery的hover方法来实现的，移入的时候清除定时器，移出的时候再次执行切换函数的图片 点击小圆点切换图片这是通过，获取点击的那个小圆点的索引来定向切换图片 左右切换是获取当前小圆点的索引来定位，然后单击切换到下一张图片写这个花了很多时间，不过最后还是完成了，也学会了很多其他的东西。 最后是效果图]]></content>
      <tags>
        <tag>JS</tag>
        <tag>jQuery</tag>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于float与inlie-block的使用]]></title>
    <url>%2F2019%2F05%2F13%2F%E5%85%B3%E4%BA%8Efloat%E4%B8%8Einlie-block%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽然之前有使用过float来把元素进行布局，但是发现这种方法存在缺点，后面发现还有display:inlie-block也能用来布局，但是在实际使用过后同样也发现一些问题，这次来讲一下这两种方式存在的问题以及解决办法。 关于float的使用使用float时存在的问题 可以看出当我们对子元素的div使用了float的时候，子元素成功浮动在了一行，但是父元素却出现了问题，父元素的宽度并没有被撑起，而是高度塌陷了，成为了一条线，这是因为使用了float之后会使文档脱离标准流，从而没有元素撑起父元素的高度。那么为了解决这个问题也有许多办法。 解决办法给父级元素设置一个固定的高度123.father&#123; height: 400px;&#125; 缺点：不够灵活 也给父级加上浮动123.father&#123; float: left;&#125; 缺点：会使父级与其他元素的关系发生变化，不推荐使用 给父级使用overflow + zoom1234.father&#123; overflow: hidden; zoom:1; /* 兼容处理,触发IE6/7的haslayout */&#125; 缺点：如果使用了定位，或者设置了边距的话，超出了父级的话将被隐藏但是使用起来比较方便，副作用也比较小比较好控制，推荐使用 在父级中加上一个div 兼容性较强 但是代码较多，且不利于维护优化 使用after伪元素1234567.father:after&#123; content: "."; /*生成内容作为最后一个元素，至于content里面是什么没有影响*/ display: block; /*使得生成的元素以块级元素显示，占满剩余空间*/ height: 0; /*避免生成的内容破坏原有空间的高度*/ clear: both; /*闭合浮动*/ visibility: hidden; /*使得生成内容不可见，并允许可能生成内容盖住的内容进行点击和交互*/&#125; 除了代码较多不好记之外是比较完美的解决方案，推荐使用。 使用了以上的办法，可以发现问题都能成功的解决。 关于display:inlie-block的使用使用display:inlie-block时存在的问题可以看出在使用display:inlie-block之后虽然子元素能够横向排列了，但是他们之间却会出现间隙，不过这种间隙不是来自边距，而是因为我们在书写div时回车会产生回车符，回车符相当于空白符，通常情况下，多个连续的空白符会合并成一个空白符，而产生“空白间隙”的真正原因就是这个让我们并不怎么注意的空白符。 解决办法我们可以发现其实这个空白符的间距其实是和字体大小有关系的，所以我们只需要将父级的字体大小设为0即可消去空白符。我们可以看到空白符已经被消去了，但是里面的字也不见了，所以我们要记得给子元素设置字体大小。 后面又发现的问题 通过图片我们可以看出，第一个和第三个子元素没有内容，那么他们就不会和有内容的子元素同占一行，会发生错位 而将他们同时设为有内容或者没有内容的时候这种情况就消失了，所以要十分注意这个问题]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery学习（css样式操作）]]></title>
    <url>%2F2019%2F05%2F12%2FjQuery%E5%AD%A6%E4%B9%A0%EF%BC%88css%E6%A0%B7%E5%BC%8F%E6%93%8D%E4%BD%9C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言 这次学了jQuery关于css样式的操作，通过jQuery的方法给元素添加修改样式以及改变和获取元素的各种宽高。 操作css样式 css(name|pro|[,val|fn])方法格式1:DOM元素.css(“样式名称”, “值”);格式2:DOM元素.css({“样式名称1”:”值1”,”样式名称2”:”值2”}); 123456789101112131415&lt;body&gt;&lt;script&gt;$(function()&#123; var $test=$('.test'); $test.css('height','100px').css('outline','1px solid red'); // 这是第一种写法，添加多个css样式 $('.test').css(&#123; 'width':'200px', 'font-size':'30px', // 这是第二种添加css样式的方法 &#125;);&#125;)&lt;/script&gt;&lt;div class="test"&gt;这是一个测试div&lt;/div&gt;&lt;/body&gt; 操作尺寸width([val|fn])方法1234567891011121314&lt;body&gt;&lt;script&gt;$(function()&#123; var $test=$('.test'); console.log($test.width()); // 获取到数值为1520 $test.width('200px'); // 设置元素宽度为200px console.log($test.width()); // 结果为200&#125;)&lt;/script&gt;&lt;div class="test"&gt;这是一个测试div&lt;/div&gt;&lt;/body&gt; height([val|fn])方法 用法与效果与width方法一致 innerHeight()/innerWidth()获取第一个匹配元素内部区域高度/宽度（包括补白、不包括边框）。 outerHeight/outerWidth() 获取第一个匹配元素外部高度（默认包括补白和边框）。 设置为 true 时，计算边距在内。1234567891011121314&lt;body&gt;&lt;script&gt;$(function()&#123; var $test=$('.test'); console.log($test.outerHeight()); // 21 console.log($test.height()); // 21 console.log($test.outerHeight(true)); // 填入参数true时会获取边距的数值，此时设置了外边距，值为41 &#125;)&lt;/script&gt;&lt;div class="test"&gt;这是一个测试div&lt;/div&gt;&lt;/body&gt; 操作和获取元素位置offset([coordinates]) 获取或设置元素相对窗口的偏移位123456789101112131415161718192021&lt;style&gt;.test&#123; margin-top: 2000px; outline: 1px solid red; height: 20px;&#125;&lt;/style&gt;&lt;body&gt;&lt;script&gt;$(function()&#123; var $test=$('.test'); console.log($test.offset().top); // 获取到值为2000 $test.offset(&#123;top:200,left:200&#125;); console.log($test.offset()); // [object Object]: &#123;left: 200, top: 200&#125;，位置成功发生变化 &#125;)&lt;/script&gt;&lt;div class="test"&gt;这是一个测试div&lt;/div&gt;&lt;/body&gt; position()获取匹配元素相对父元素的偏移。返回的对象包含两个整型属性：top 和 left。为精确计算结果，请在补白、边框和填充属性上使用像素单位。此方法只对可见元素有效。12345678910111213141516171819202122232425&lt;style&gt;.test&#123; /* margin-top: 2000px; */ outline: 1px solid red; height: 20px; position: absolute; top: 20px; left: 20px;&#125;.father&#123; position: relative;&#125;&lt;/style&gt;&lt;body&gt;&lt;script&gt;$(function()&#123; var $test=$('.test'); console.log($test.position()); // 成功获取到了绝对定位的数值20，20 &#125;)&lt;/script&gt;&lt;div class="father"&gt;&lt;div class="test"&gt;这是一个测试div&lt;/div&gt;&lt;/div&gt;&lt;/body&gt; scrollTop([val])与scrollLeft([val])获取匹配元素相对滚动条顶部的偏移。此方法对可见和隐藏元素均有效。下面以scrollTo()为例：123456789101112131415161718192021222324252627282930313233&lt;style&gt;.test&#123; margin-top: 2000px; outline: 1px solid red; height: 20px; position: absolute; top: 20px; left: 20px;&#125;button&#123; margin-top: 200px;&#125;&lt;/style&gt;&lt;body&gt;&lt;script&gt;$(function()&#123; console.log($('html').scrollTop()+$('body').scrollTop()); // 当拖动滚轮，点击按钮获取数值，数值能够正确显示。 $('button').eq(0).click(function()&#123; alert(($('html').scrollTop()+$('body').scrollTop())); // 兼容处理，保证所有浏览器都能正确获取数值&#125;); $('button').eq(1).click(function()&#123; $('html').scrollTop(300)+$('body').scrollTop(300);&#125;);&#125;)&lt;/script&gt;&lt;div class="father"&gt;&lt;div class="test"&gt;这是一个测试div&lt;/div&gt;&lt;/div&gt;&lt;button&gt;显示scrolltop&lt;/button&gt;&lt;button&gt;设置scrolltop&lt;/button&gt;&lt;/body&gt;]]></content>
      <categories>
        <category>学习笔记</category>
        <category>jQuery学习笔记</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>JS</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于css选择器的一个小小的问题]]></title>
    <url>%2F2019%2F05%2F12%2F%E5%85%B3%E4%BA%8Ecss%E9%80%89%E6%8B%A9%E5%99%A8%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%B0%8F%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[前言 昨天在写一个页面的时候，写到css样式的时候，出现了一个问题,让我有一开始有点想不明白，后面明白了，记录一下。 问题情况： 这是html代码 12345&lt;div class="father"&gt; &lt;ul&gt; &lt;li class="son"&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 这是css代码 123456789101112.father ul li&#123; display:none; /* 此时这个div块中的所有内容都将不显示 */&#125;.son&#123; display:block; /* 起初我认为此时这个li中放的所有内容都应该显示，但是我在li中放的图片并没有显示，我就去查看控制台的样式，发现在这个li中的样式是有block这个属性但是并没有生效。 */&#125;.father ul .son&#123; display:block; /* 后面我尝试着这样写，却发现这下图片就显示出来了 ，随后并猜测是选择器优先级的问题，随即查阅资料，发现组合选择器的优先级为成员选择器的权重相加，只写一个类选择器干不过上面的多个选择器权重相加，所以多组合一些就好了，或者用!important 来拉满。*/&#125; 总结选择器的权重问题。虽然以前看到过选择器优先级相关的知识，但是还没有接触过很多这种情况，以后要注意！]]></content>
      <categories>
        <category>问题解决</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery学习（核心函数）]]></title>
    <url>%2F2019%2F05%2F10%2FjQuery%E5%AD%A6%E4%B9%A0%EF%BC%88%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言 记录了jQuery的核心函数以及jQuery对象，jQuery的静态方法的使用。 jQuery核心函数jQuery核心函数一共3大类4小类 jQuery(callback)当DOM加载完成后执行传入的回调函数 jQuery([sel,[context]])接收一个包含 CSS 选择器的字符串，然后用这个字符串去匹配一组元素,并包装成jQuery对象,也就是jQuery的选择器。 jQuery(html,[ownerDoc])根据 HTML 标记字符串，动态创建DOM 元素 12345678910111213141516&lt;script&gt;$(function()&#123; var $text=$("&lt;p&gt;这是一段文字&lt;/p&gt;"); $("body").append($text);&#125;);&lt;/script&gt;``` ### jQuery对象* jQuery对象的本质是什么? jQuery对象的本质是一个伪数组```html&lt;script&gt; var $div = $('div'); console.log($div); // [object Object]: &#123;0: Object, context: Object, length: 1, prevObject: Object, selector: "div"&#125;&lt;/script&gt; 什么是伪数组?有0到length-1的属性,并且有length属性 jQuery静态方法 什么是静态方法?静态方法对应的是对象方法,对象方法用实例对象调用,而静态方法用类名调用 jQuery.holdReady(hold)暂停或者恢复jQuery.ready()事件传入true或false1234567891011121314151617181920&lt;script&gt; // 使用$直接调用,是静态方法 $.holdReady(true); // 暂停住了 $(function () &#123; $("#first").click(function () &#123; alert("我是你想要的弹窗"); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button id="first"&gt;点击测试弹出&lt;/button&gt;&lt;button id="second"&gt;解除延迟&lt;/button&gt;&lt;script&gt; $("#second").click(function()&#123; $.holdReady(false); // 单击会触发这个，然后恢复 &#125;);&lt;/script&gt; $.each(object,[callback])遍历对象或数组优点统一遍历对象和数组的方式回调参数的顺序更符合我们的思维模式 $.map(arr|obj,callback)遍历对象或数组,将回调函数的返回值组成一个新的数组返回 $.trim(str)去掉字符串起始和结尾的空格。 $.isArray(obj)判断是否是数组 $.isFunction(obj)判断是否是函数 $.isWindow(obj)判断是否是window对象]]></content>
      <categories>
        <category>学习笔记</category>
        <category>jQuery学习笔记</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery学习（入口函数与冲突问题）]]></title>
    <url>%2F2019%2F05%2F10%2FjQuery%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%A5%E5%8F%A3%E5%87%BD%E6%95%B0%E4%B8%8E%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言 jQuery入口函数与原声js入口函数的区别，以及解决冲突问题，还有一些小细节，帮助我学习。 jQuery入口函数 多个window.onload只会执行一次, 后面的会覆盖前面的 多个$(document).ready()会执行多次,后面的不会覆盖前面的 不会覆盖的本质(了解,后面jQuery原理会详细讲解)jQuery框架本质是一个闭包,每次执行我们都会给ready函数传递一个新的函数,不同函数内部的数据不会相互干扰 window.onload $(document).ready() 执行时机 必须等待网页全部加载完毕(包括 图片等),然后再执行包裹代码 只需要等待网页中的DOM结构 加载完毕,就能执行包裹的代码 执行次数 只能执行一次,如果第二次,那么 第一次的执行会被覆盖 可以执行多次,第N次都不会被上 一次覆盖 简写方案 无 $(function () { }); 解决$符号冲突问题 为什么是window.jQuery = window.$ = jQuery;,而不是window.jQuery = jQuery; jQuery框架之所以提供了jQuery访问还提供$访问,就是为了提升开发者的编码效率 $符号冲突怎么办? 很多js的框架都提供了类似jQuery这样的便捷访问方式,所以很有可能某一天我们在使用多个框架的时,多个框架作者提供的便捷访问方式冲突(A框架通过$访问,B框架也通过$访问) ***释放$使用权 当便捷访问符号发生冲突时,我们可以释放$使用权, 释放之后只能使用jQuery]]></content>
      <categories>
        <category>学习笔记</category>
        <category>jQuery学习笔记</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery学习（介绍与使用）]]></title>
    <url>%2F2019%2F05%2F10%2FjQuery%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言 对于前端来说，学习掌握jQuery是基础，则将会是我学习jQuery的记录。jQuery中文文档：http://hemin.cn/jq/。 jQuery是什么？ jQuery是一款优秀的JavaScript库，从命名可以看出jQuery最主要的用途是用来做查询（jQuery=js+Query）. 在jQuery官方Logo下方还有一个副标题（write less, do more）, 体现了jQuery除了查询以外,还能让我们对HTML文档遍历和操作、事件处理、动画以及Ajax变得更加简单 为什么要使用jQuery？ 强大选择器: 方便快速查找DOM元素如上面实例所展示一样，通过jQuery查找DOM元素要比原生js快捷很多jQuery允许开发者使用CSS1-CSS3几乎所有的选择器,以及jQuery独创的选择器 以下是一段jQuery代码：1234567891011121314151617&lt;body&gt; &lt;div class="test1"&gt;这是1&lt;/div&gt; &lt;div&gt;这是0&lt;/div&gt; &lt;div id="test2"&gt;这是2&lt;/div&gt; &lt;script&gt; $(document).ready(function()&#123; $(".test1").css('width','100px').css('height','200px'); $("#test2").css('background','blue'); // 读取数据 var $tx = $("div").eq(0).text(); alert($tx); // 写入数据 $("div").eq(0).text("新的数据"); &#125;); &lt;/script&gt;&lt;/body&gt; 通过以上代码可以看出，jQuery查找元素要快的多，方便的多，并且jQuery可以不断的调用jQuery对象的方法，并且可以一次操作。读取数据也是一个函数，使用比较方便 事件处理 DOM操作(C增U改D删) 样式操作 动画 丰富的插件支持 浏览器兼容(前端开发者痛点) 如何使用jQuery？下载过后这样调用就可以了：1&lt;script src="../jquery-1.12.4.js"&gt;&lt;/script&gt;]]></content>
      <categories>
        <category>学习笔记</category>
        <category>jQuery学习笔记</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于classList的使用]]></title>
    <url>%2F2019%2F05%2F10%2F%E5%85%B3%E4%BA%8EclassList%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言 关于classList的学习总结，作为DOMTokenList对象该属性用于在元素中添加、移出、切换css类，使用classList可以实现十分多的功能，十分的有用，以下是我的学习笔记。 语法：elem.classList方法：add( String[,String])：添加指定的类值。如果这些类已经存在于元素的属性中，那么他们将被忽略remove(String[,String])：删除指定的类值item(Number)：按集合中的索引返回类值toggle(String[,force])： 当只有一个参数的时，切换class value ，即如果类存在，删除它，并返回false，如果类不存在，则添加它并返回true。 当存在第二个参数时，如果第二个参数的计算结果为true，则添加指定的类值，如果计算结果为false，则删除它 contains(string)：检查元素的类属性中是否存在指定的类值属性：length：返回类列表中类的数量，该属性是只读的 下面是利用classList实现标签栏切换的一个小例子：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;style&gt; div &#123; width: 500px; margin: 10px; &#125; .db&#123; height: 50px; width: 300px; margin: 0 auto; border: none; &#125; .dh&#123; background: #666; height: 25px; width: 300px; margin: 0 auto; color: white; text-align: center; border: none; &#125; .dhd&#123; margin: 0 0px; width: 100px; float: left; margin-top: 3px; &#125; .dbd&#123; width: 100px; height: 50px; float: left; margin: 0 0px; display: none; width: 300px; &#125; .current&#123; display: block; background: white; color: black; &#125; .ttt&#123; border: 1px solid black; width: 300px; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class="ttt"&gt; &lt;div class='dh'&gt; &lt;div class="dhd current"&gt;标签栏一&lt;/div&gt; &lt;div class="dhd"&gt;标签栏二&lt;/div&gt; &lt;div class="dhd"&gt;标签栏三&lt;/div&gt; &lt;/div&gt; &lt;div class='db'&gt; &lt;div class="dbd current"&gt;这是内容一&lt;/div&gt; &lt;div class="dbd"&gt;这是内容二&lt;/div&gt; &lt;div class="dbd"&gt;这是内容三&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; // 利用classList的方法给当前元素添加样式让其显示，其他元素默认不显示，以达到切换效果 var hs=document.getElementsByClassName('dhd'); var ds=document.getElementsByClassName('dbd'); for(var i=0;i&lt;hs.length;i++)&#123; hs[i].onmouseover=function()&#123; for(var i=0;i&lt;ds.length;i++)&#123; if(hs[i]==this)&#123; ds[i].classList.add('current'); hs[i].classList.add('current'); &#125; else&#123; ds[i].classList.remove('current'); hs[i].classList.remove('current'); &#125; &#125; &#125; &#125; &lt;/script&gt;&lt;/body&gt;]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html中的块级元素与行级元素]]></title>
    <url>%2F2019%2F05%2F10%2Fhtml%E4%B8%AD%E7%9A%84%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E4%B8%8E%E8%A1%8C%E7%BA%A7%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[前言 在最开始的时候没有清除的认识到块级元素与行级元素的差别，也没有想到二者之间有如此大的差别，以及二者之间的关系以下是我对二者的学习总结： 块级元素和行内元素的定义块级元素： 总是在新行上开始； 高度，行高以及外边距和内边距都可控制； 宽度缺省是它的容器的100%，除非设定一个宽度。 它可以容纳内联元素和其他块元素 行内元素？ 和其他元素都在一行上； 高，行高及外边距和内边距不可改变； 宽度就是它的文字或图片的宽度，不可改变 内联元素只能容纳文本或者其他内联元素 对行内元素，需要注意如下： 设置宽度width 无效。 设置高度height 无效，可以通过line-height来设置。 设置margin 只有左右margin有效，上下无效。 设置padding 只有左右padding有效，上下则无效。注意元素范围是增大了，但是对元素周围的内容是没影响的。 可以通过display对二者进行调整display属性表： 值 描述 none 此元素不会被显示。 block 此元素将显示为块级元素，此元素前后会带有换行符。 inline 默认。此元素会被显示为内联元素，元素前后没有换行符。 inline-block 行内块元素。（CSS2.1 新增的值） list-item 此元素会作为列表显示。 run-in 此元素会根据上下文作为块级元素或内联元素显示。 compact CSS 中有值 compact，不过由于缺乏广泛支持，已经从 CSS2.1 中删除。 marker CSS 中有值 marker，不过由于缺乏广泛支持，已经从 CSS2.1 中删除。 table 此元素会作为块级表格来显示（类似 &lt;table&gt;），表格前后带有换行符。 inline-table 此元素会作为内联表格来显示（类似 &lt;table&gt;），表格前后没有换行符。 table-row-group 此元素会作为一个或多个行的分组来显示（类似 &lt;tbody&gt;）。 table-header-group 此元素会作为一个或多个行的分组来显示（类似 &lt;thead&gt;）。 table-footer-group 此元素会作为一个或多个行的分组来显示（类似 &lt;tfoot&gt;）。 table-row 此元素会作为一个表格行显示（类似 &lt;tr&gt;）。 table-column-group 此元素会作为一个或多个列的分组来显示（类似 &lt;colgroup&gt;）。 table-column 此元素会作为一个单元格列显示（类似 &lt;col&gt;） table-cell 此元素会作为一个表格单元格显示（类似 &lt;td&gt; 和 &lt;th&gt;） table-caption 此元素会作为一个表格标题显示（类似 &lt;caption&gt;） inherit 规定应该从父元素继承 display 属性的值。 这是一个小测试：123456789101112131415161718192021222324252627282930&lt;style&gt; div&#123; border: 1px solid blue; margin-bottom: 10px; &#125; span&#123; border: 1px solid red; height: 50px; margin: 40px; /* 可以发现对span这个行内元素设置了height属性但是其并没有生效 设置了margin，但只有左右margin生效，padding同理。 */ &#125; .div3&#123; display: inline; /* 将其设为行内元素，其只拥有行内元素的特性 */ &#125; .div4&#123; display: inline-block; /* 将其设置为行内块级元素，兼具二者特性 */ height: 50px; &#125;&lt;/style&gt;&lt;body&gt;&lt;div&gt;这是第一个div:div是块级元素，默认宽度是100%,可以设置宽度与高度，默认自动占一行&lt;/div&gt;&lt;div&gt;这是第二个div&lt;span&gt;这是一个块级元素:大小只与内容有关，不可以设置宽度与高度，但能设置行高，默认不占一行&lt;/span&gt;&lt;/div&gt;&lt;div"&gt;这是第三个div：通过display:inline将其变为行内元素&lt;/div&gt;&lt;div"&gt;这是第四个div:通过display:inline-block将其变为行内块级元素，兼具二者特性&lt;/div&gt;&lt;/body&gt; 效果图： 以上就是我的学习总结。]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个简单的网页二级菜单]]></title>
    <url>%2F2019%2F05%2F09%2F%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%BD%91%E9%A1%B5%E4%BA%8C%E7%BA%A7%E8%8F%9C%E5%8D%95%2F</url>
    <content type="text"><![CDATA[前言 网页二级菜单十分常见，我学习到了写法，以下是我写的一个简单的demo当作练习，以及原理说明。 CSS代码12345678910111213.menu&#123; list-style: none;&#125;.menu&gt;li&#123; float: left;&#125;li&gt;ul&#123; display: none;&#125;.menu&gt;li:hover&gt;ul&#123; display: block;&#125; 实现二级菜单的主要原理部分还是在css部分，先将所有的二级菜单的内容通过display隐藏，当鼠标经过一级菜单则将二级菜单的内容显示出来。 html代码123456789101112131415161718192021222324252627&lt;body&gt; &lt;ul class="menu"&gt; &lt;li&gt;&lt;a href="#"&gt;菜单一&lt;/a&gt; &lt;ul&gt; &lt;li&gt;测试a1&lt;/li&gt; &lt;li&gt;测试a2&lt;/li&gt; &lt;li&gt;测试a3&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="#"&gt;菜单二&lt;/a&gt; &lt;ul&gt; &lt;li&gt;测试b1&lt;/li&gt; &lt;li&gt;测试b2&lt;/li&gt; &lt;li&gt;测试b3&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="#"&gt;菜单三&lt;/a&gt; &lt;ul&gt; &lt;li&gt;测试c1&lt;/li&gt; &lt;li&gt;测试c2&lt;/li&gt; &lt;li&gt;测试c3&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/body&gt; 效果图&gt;]]></content>
      <categories>
        <category>页面小功能</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css选择器总结]]></title>
    <url>%2F2019%2F05%2F08%2Fcss%E9%80%89%E6%8B%A9%E5%99%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前言 在编写css代码时合理使用选择器有助于提升编写效率以及缩短代码量，所以对常用的选择器熟练使用是十分有必要的，以下为一些选择器的使用总结。 基础的一些选择器标签选择器，以标签名作为选择器名类选择器，通过”.”+类名作为选择器名称如：.testid选择器，通过”#”+类名作为选择器名称如：#test 交集选择器标记选择器+类选择器或id选择器，中间不能有任何的空格如：p.aaa或p#aaa注意：后代选择器作用于所有后代。（与子代选择器的区分） 后代选择器：由两个标记选择器组成，第一个为父级，第二个为子代，中间一定要有空格div p注意：子代选择器作用于所有后代。（与后代选择器的区分） 子代选择器此时选择到的是作为子代的p 子代选择器与后代选择器的区别，子代选择器只作用于后一代儿子，而不会影响到孙子，后代选择器作用于所有后代div&gt;p 并集选择器：由若干个任意选择器组成，由逗号分隔开可以同时对多个目标生效。h1,.aaa,#bbb 属性选择器假设有html代码：1&lt;input name="test" placeholder="初始值" class="test" id="test" type="text" value=""&gt; E[att^=value] E可以省略，满足 属性值 等于valueinput[name^=test]E[att$=value] E可以省略，满足 属性值后缀 等于valueinput[name$=st]E[att*=value] E可以省略，满足 属性值包含 valueinput[name*=es] 兄弟选择器p+h2 选择到的是p后面的 相邻的 h2p~h2 选择到的是p后面的 不一定相邻的 h2 伪类选择器：:root 该选择器对页面所有元素的生效，可以用其他选择器将其覆盖:not 该选择器可以将选定内容排除在大选择器之外（body :not(p)）此时选择器就不会选择到p标记。冒号之前必须有空格 伪元素选择器：:first-letter 向文本的第一个字母添加样式:first-line 向文本的首行添加特殊样式。:before 在元素之前添加内容。:after 在元素之后添加内容。 链接伪类：a:link 未访问时的状态a:visited 访问后的状态a:active 鼠标单击不动时的状态a:hover 悬停时的状态 关于选择器的优先级比较同一级别的个数，数量多的优先级高，如果相同即比较下一级别的个数important &gt; 内联 &gt; ID &gt; 类 &gt; 标签 | 伪类 | 属性选择 &gt; 伪对象 &gt; 通配符 &gt; 继承]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown基本语法(在hexo中的使用)]]></title>
    <url>%2F2019%2F03%2F11%2Fmarkdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95(%E5%9C%A8hexo%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8)%2F</url>
    <content type="text"><![CDATA[前言 hexo使用markdown来书写博客，所以熟悉了解markdown十分有必要，这是markdown在hexo中的使用,这里介绍markdown的基础以及在hexo中的应用。 一、标题12345# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题 效果： 这是一级标题这是二级标题这是三级标题这是四级标题这是五级标题二、文字1234**这是加粗的文字** //用两个*将文字包起即加粗*这是斜体文字* //用一个*将文字包起即斜体***这是加粗同时斜体的文字*** //用三个*将文字包起即加粗斜体 ~~这是加删除线的文字~~ //要加删除线的文字左右分别用两个~~号包起来 效果： 这是加粗的文字这是斜体文字这是加粗同时斜体的文字这是加删除线的文字 三、引用在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;n个…123&gt;这是引用的内容&gt;&gt;这是引用的内容&gt;&gt;&gt;这是引用的内容 效果： 这是引用的内容 这是引用的内容 这是引用的内容 四、分割线几种样式，效果一样1234-------******** 五、图片图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加还可以用html标记来插入图片：1&lt;img width=200 src=&quot;../images/lm.jpg&quot;/&gt; 并且可以自定义大小但是hexo中使用以上两种方式会导致一些问题，所以在hexo中建议使用以下方法：1&#123;% asset_img example.jpg This is an example image %&#125; 六、超链接1[超链接名](超链接地址 &quot;超链接title&quot;) title可加可不加示例：1[百度](https://www.baidu.com) 百度一样的可以使用html标记来插入超链接： 百度并且可以设置在新窗口打开 七、列表无序：123- 列表内容+ 列表内容* 列表内容 注意：- + * 跟内容之间都要有一个空格 列表内容 列表内容 列表内容 用html标记也可以：12345&lt;ul&gt;&lt;li&gt;列表内容1&lt;/li&gt;&lt;li&gt;列表内容2&lt;/li&gt;&lt;li&gt;列表内容3&lt;/li&gt;&lt;/ul&gt; 有序：数字加点:1231. 列表内容2. 列表内容3. 列表内容 列表内容 列表内容 列表内容 注意：序号跟内容之间要有空格 八、表格1234表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容 表头 表头 表头 内容 内容 内容 内容 内容 内容 第二行分割表头和内容。-有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略同样，可以用html标记实现：12345&lt;table&gt;&lt;tr&gt;&lt;td&gt;表头&lt;/td&gt;&lt;td&gt;表头&lt;/td&gt;&lt;td&gt;表头&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;内容&lt;/td&gt;&lt;td&gt;内容&lt;/td&gt;&lt;td&gt;内容&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;内容&lt;/td&gt;&lt;td&gt;内容&lt;/td&gt;&lt;td&gt;内容&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 表头表头表头内容内容内容内容内容内容 九、代码单行代码：代码之间分别用一个反引号包起来代码内容代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行123代码...在开头的三个反引号后面加上语言名称还可以显示对应高亮代码... 代码高亮 十、流程图由于hexo不支持流程图所以不做演示 十一、在实际使用过程中遇到的一些问题以及解决办法在实际的使用过程中使用markdown在hexo编写文章有时会遇到一些意想不到的问题，这里来进行一个汇总以及解决办法： 在hexo中使用表格的时候在vscode中预览的时候是好好的，可是当打开网页之后却会出现表格上方会出现大量的留白的情况，检查网页代码发现是网页中多了很多的换行符那么解决办法是在表格使用 `` 与 ``包裹起来，然后再回去查看网页，ok，问题解决。]]></content>
      <tags>
        <tag>HTML</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F12%2F02%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
