<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[php中页面分页的实现]]></title>
    <url>%2F2019%2F06%2F03%2Fphp%E4%B8%AD%E9%A1%B5%E9%9D%A2%E5%88%86%E9%A1%B5%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;今天老师上课给我们讲了一下php中的翻页功能的实现，，主要是通过数据库中的limit方法实现，这一点和我预想的差不多，但是通过给页面设置id的这种办法是我没有想到的，我一开始的设想是，能不能作到不用给每个页面设置一个id，根据这个id进行跳转，而是直接设置一个变量，当进行翻页的时候这个变量的数值发生变化，然后根据这个变量来获取数据库中的内容。这个想法应该可以实现，但是可能会比较麻烦，因为在php中还是必须要刷新页面才能更新数据的，所以目前来看还是这种方法应该是最好的，那么就来看看究竟是怎么实现分页功能的。 代码 先是连接数据库： 123456&lt;?php// 一个正常的连接数据库的页面$conn=mysqli_connect('localhost','root','','test') or die('失败');mysqli_set_charset($conn,'utf8');$res=mysqli_query($conn,'select * from stu');?&gt; 实现功能的页面 12345678910111213141516171819202122232425262728293031323334353637&lt;body&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;id&lt;/td&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;年龄&lt;/td&gt; &lt;td&gt;性别&lt;/td&gt; &lt;/tr&gt; &lt;?php include 'conn.php'; $data_count=mysqli_num_rows($res); //获取数据表中有多少条数据 $data_num=2; //设置一页显示多少条数据 $id=empty($_GET['id'])?1:$_GET['id']; //判断当前页面的url栏中的id参数是否为空，如果为空则默认为1，否则则为url中id的数值 $pg_count=ceil($data_count/$data_num); //计算总共有多少页，ceil的用法是往上取整 //通过limit来获取每一个页面该显示的数据 $datas=mysqli_query($conn,"select * from stu limit ".($id-1)*2 . ','. $data_num); //用来排错的方法 // if (!$datas) &#123; // printf("Error: %s\n", mysqli_error($conn)); // exit(); // &#125; // 输出最终获取到的页面的数据 while($row=mysqli_fetch_array($datas))&#123; echo "&lt;tr&gt;&lt;td&gt;$row[id]&lt;/td&gt;&lt;td&gt;$row[name]&lt;/td&gt;&lt;td&gt;$row[age]&lt;/td&gt;&lt;td&gt;$row[sex]&lt;/td&gt;&lt;/tr&gt;"; &#125; ?&gt; &lt;!-- 在href中设置id的值 --&gt; &lt;tr&gt; &lt;td&gt;&lt;a href="?id=1"&gt;首页&lt;/a&gt;&lt;/td&gt; 实现上一页的功能，先判断是否是第一页，否则id-1 &lt;td&gt;&lt;a href="?id=&lt;?php echo $id==1?1:$id-1 ?&gt;"&gt;上一页&lt;/a&gt;&lt;/td&gt; 实现上一页的功能，先判断是否是最后一页，否则id+1 &lt;td&gt;&lt;a href="?id=&lt;?php echo $id==$pg_count?$pg_count:$id+1 ?&gt;"&gt;下一页&lt;/a&gt;&lt;/td&gt; &lt;td&gt;&lt;a href="?id=&lt;?php echo $pg_count ?&gt; "&gt;尾页&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt; 其实代码还是很好理解的，但是自己在写的过程中还是遇到了一些问题，下面记录一下这些问题 我自己在编写过程中遇到的一些问题首先就是在我基本上已经写完代码之后一测试就爆出了一个警告，并且最终没有出现我想要的结果，于是我上网查询解决办法，于是找到了下面这一段代码：1234if (!$datas) &#123; printf("Error: %s\n", mysqli_error($conn)); exit(); &#125; 通过上述代码就没有再出现警告了，而是直接报错，提示问题在哪，我就在附近排查问题， $datas=mysqli_query($conn,&quot;select * from stu limit ($id-1)*2 , $data_num&quot;); 我一开始想会不会因为是没有拼接字符串的原因,于是我修改代码改成后面是拼接字符串的形式。 $datas=mysqli_query($conn,&quot;select * from stu limit&quot;.($id-1)*2 . &#39;,&#39;. $data_num); 但是一直都是出现一样的错误提示，后面经过我的测试发现是$datas中没有数据，但是我直接不写变量，把变量写死就能出来数据。反复比较自己那部分的代码和老师给的代码，但是直接比对并没有发现什么不一样，后面复制老师的这行代码稍加修改结果却是正常的。最后我终于发现了问题所在，其实我尝试的两种写法都存在问题： 首先是我一开始没有拼接变量，而是直接将变量写在字符串之中，我发现也是数据库在处理语句的时候出现的问题，我猜测应该是在使用变量的时候变量会把前面的空格给吞掉，导致语句执行错误。 后面我尝试拼接字符串的时候又出现了问题是因为我在limit后面少拼接了一个空格导致语句执行出错。 总结写php还是不是特别的熟练，所以经常出现各种问题，所以要总结错误，加深印象，以后越写越熟练以后的错误就会越来越少]]></content>
  </entry>
  <entry>
    <title><![CDATA[写一个简单的五星评分系统]]></title>
    <url>%2F2019%2F05%2F27%2F%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%BA%94%E6%98%9F%E8%AF%84%E5%88%86%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最近在写期末的课程设计，网站有要求写一个五星评分的功能，我按照我的思路写了一下，经过一下午的时间，把这个功能实现的比较完善了。 一开始的第一种尝试放代码：HTML部分：1234567891011121314151617*&#123; list-style: none;&#125;.all&#123; display: flex;&#125;&lt;/style&gt;&lt;body&gt; &lt;ul class="all"&gt; &lt;li&gt;&lt;img index=0 src="./images/wxz.png" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img index=1 src="./images/wxz.png" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img index=2 src="./images/wxz.png" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img index=3 src="./images/wxz.png" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img index=4 src="./images/wxz.png" alt=""&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt; JS部分：12345678910111213141516171819202122232425262728&lt;script&gt; $(function()&#123; var $stars=$('img'); console.log($stars); // 最外面的循环是给所有img添加事件 for(var i=0;i&lt;$stars.length;i++)&#123; $stars.eq(i).mouseenter(function()&#123; // 第二层的循环是判断是否是当前正在操作的元素 for(var i=0;i&lt;$stars.length;i++)&#123; if($stars[i]==this)&#123; $(this).click(function()&#123; console.log(i); &#125;) // 第三层的循环是给所有的星星设置相应的图片,让它显示出应有的效果 for(var j=0;j&lt;$stars.length;j++)&#123; if(j&lt;=i)&#123; $stars.eq(j).attr("src","./images/xz.png") &#125; else&#123; $stars.eq(j).attr("src","./images/wxz.png") &#125; &#125; &#125; &#125; &#125;) &#125; &#125;) &lt;/script&gt; 最终是实现了效果,但是我觉得这不是最好最简单的写法,于是我将其改进了一下，有了下面的这种写法。 第二种写法第二种写法原理其实也是一样的，只不过是代码更加的简介和简单1234567891011121314151617&lt;style&gt;*&#123; list-style: none;&#125;.all&#123; display: flex;&#125;&lt;/style&gt;&lt;body&gt; &lt;ul class="all"&gt; &lt;li&gt;&lt;img index="0" src="./images/wxz.png" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img index="1" src="./images/wxz.png" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img index="2" src="./images/wxz.png" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img index="3" src="./images/wxz.png" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img index="4" src="./images/wxz.png" alt=""&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt; 12345678910111213141516171819202122&lt;script&gt; $(function()&#123; var $stars=$('img');//获取所有的星星 // 鼠标移入事件 $stars.mouseenter(function()&#123; var $star_index=parseInt($(this).attr("index")); for(var i=0;i&lt;$stars.length;i++)&#123; if(i&lt;=$star_index)&#123; $stars.eq(i).attr("src","./images/xz.png"); &#125; else&#123; $stars.eq(i).attr("src","./images/wxz.png"); &#125; &#125; &#125;) // 单击事件，向服务器提交数据 $stars.click(function()&#123; var $star_index=parseInt($(this).attr("index")); console.log($star_index+1); &#125;) &#125;) &lt;/script&gt; 可以看出第二种写法要简单很多，主要是没有这么多的循环嵌套，这也是我最终所采用的写法。 总结虽然这个评分系统的原理以及思路是挺简单的，但其实在实现的过程中还是遇到了一些困难的，不过经过不断的思考排错，最终还是将其完善了，相信只要不断的学习，以后一定能越来越得心应手。]]></content>
  </entry>
  <entry>
    <title><![CDATA[HTML中DOM的hash属性的使用]]></title>
    <url>%2F2019%2F05%2F26%2Fhash%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hash在网站中的使用也是十分的常见，使用hash也可以带来便利，这次我们来看看hash究竟该如何让使用。 如何设置hash我们可以通过在js中设置hash的值123&lt;script&gt;window.location.hash=3;&lt;/script&gt; 这样就可以设置hash值，那么设置过后我们就可以在地址栏看到多了一个#3 如何获取hash的值12345678910111213141516&lt;script&gt; window.location.hash=3; console.log(window.location.hash); //#3 &lt;/script&gt;``` 直接就能获取hash的值，但是这样获取到的值带有``#``我们要获取的一般都是不带``#``的值所以我们可以这样处理```javasript&lt;script&gt; window.location.hash=3; console.log(window.location.hash); //#3 console.log(window.location.hash.substring(1)); //3 &lt;/script&gt; 使用字符串截取函数，截取不带#的这一部分 总结hash的使用十分的简单，但是hash的使用频率很高，通过hash我们就可以实现例如翻页还在同一页的效果。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Ajax的学习]]></title>
    <url>%2F2019%2F05%2F26%2FAjax%E7%9A%84%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ajax技术可以说是随处可见，在网页的交互方面基本上都用到了Ajax，可以说Ajax作用是十分的强大，通过 Ajax，因特网应用程序可以变得更完善，更友好。所以作为正在学习的我来说，完整学习Ajax以及完全掌握Ajax是十分重要的。 什么是Ajax呢？ Ajax 即“Asynchronous Javascript And XML”（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。 Ajax = 异步 JavaScript 和 XML 或者是 HTML（标准通用标记语言的子集）。 Ajax 是一种用于创建快速动态网页的技术。 Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。 Ajax所涉及的相关知识 get方式提交数据与post方式提交数据的异同点1、通过get方式提交数据会把数据放在url地址栏中，而使用post方式提交数据则会把数据放到请求头中，可以在调试工具的network栏中看到这些数据2、get请求由于浏览器对于url地址栏长度的限制，所以导致get1请求发送数据会有长度限制，要支持ie，那么最大长度就为2083byte 原生js实现Ajax可以参考这里 由于原生js实现Ajax过程比较多，这里不做过多介绍，了解即可，通常使用jQuery中的ajax方法，比较方便快捷的使用Ajax。 jQuery中的Ajax jQuery 提供多个与 AJAX 有关的方法。 通过 jQuery AJAX 方法，您能够使用 HTTP Get 和 HTTP Post 从远程服务器上请求文本、HTML、XML 或 JSON - 同时能够把这些外部数据直接载入网页的被选元素中。 jQuery.ajax([settings]) 这是jQuery中的Ajax的基本用法。 settings最常用的参数 type类型：String默认值: “GET”)。请求方式 (“POST” 或 “GET”)， 默认为 “GET”。注意：其它 HTTP 请求方法，如 PUT 和 DELETE 也可以使用，但仅部分浏览器支持。 url类型：String默认值: 当前页地址。发送请求的地址。 data类型：String发送到服务器的数据。将自动转换为请求字符串格式。GET 请求中将附加在 URL 后。查看 processData 选项说明以禁止此自动转换。必须为 Key/Value 格式。如果为数组，jQuery 将自动为不同值对应同一个名称。如 {foo:[“bar1”, “bar2”]} 转换为 ‘&amp;foo=bar1&amp;foo=bar2’。 error类型：Function默认值: 自动判断 (xml 或 html)。请求失败时调用此函数。有以下三个参数：XMLHttpRequest 对象、错误信息、（可选）捕获的异常对象。如果发生了错误，错误信息（第二个参数）除了得到 null 之外，还可能是 “timeout”, “error”, “notmodified” 和 “parsererror”。这是一个 Ajax 事件。 success类型：Function请求成功后的回调函数。参数：由服务器返回，并根据 dataType 参数进行处理后的数据；描述状态的字符串。这是一个 Ajax 事件。 除了以上这些外，jQuery中Ajax的settings还有很多参数，具体可以参考这里 通过jQuery中的Ajax来写两个简单的例子 通过get方式来向远程服务器提交数据。html代码123456789101112131415161718192021222324&lt;body&gt; &lt;!-- 通过一个按钮的单击事件来触发ajax --&gt; &lt;button&gt;这是一个按钮，点击发送Ajax请求&lt;/button&gt; &lt;script&gt; $(function()&#123; var $bt=$('button'); // 为按钮绑定单击事件 $bt.click(function()&#123; // 调用jQuery中的Ajax $.ajax(&#123; type:'get', url:'./php/ajax-get.php', data:'name=hsl&amp;age=18', success:function(msg)&#123; alert(msg) &#125;, error:function(xhr)&#123; alert(xhr) &#125; &#125;) &#125;) &#125;) &lt;/script&gt;&lt;/body&gt; php代码1234&lt;?php echo '这是返回的名字'.$_GET['name']; echo '这是返回的年龄'.$_GET['age'];?&gt; 根据代码我们可以看出当我们单击按钮的时候就会触发单击事件调用ajax，给我们返回后端处理过后的数据，那结果究竟会是怎样呢。通过图片我们可以看出Ajax成功返回了我们想要的数据，并且我们可以看到这个php文件的url附加了我们的参数信息。 通过post方式来向远程服务器提交数据。html代码1234567891011121314151617181920&lt;body&gt; &lt;button&gt;这是一个发送post请求的按钮&lt;/button&gt; &lt;script&gt; $(function()&#123; $('button').click(function()&#123; $.ajax(&#123; url:'./php/ajax-post.php', type:'post',//这里的传输方式改成了post data:'name=hsl&amp;age=18', success:function(msg)&#123; alert(msg); &#125;, error:function(xhr)&#123; alert(xhr); &#125; &#125;) &#125;) &#125;) &lt;/script&gt;&lt;/body&gt; php代码1234&lt;?phpecho $_POST['name'];echo $_POST['age'];?&gt; 可以看出上面的代码主要就是将type 从get改成了post，那效果会怎样呢.从图片中我们可以看出使用post方式也成功获取了我们想要的数据，但是我们不能在url中看见我们传过去的参数，但是能在报文头中看见这些参数，因为不像get方式会在url栏传参数，所以也没有长度的限制。 总结通过这次的学习，掌握了Ajax的基本用法，也通过实例了解了get方式与post方式的一些差别，二者以后要根据实际情况来使用。]]></content>
  </entry>
  <entry>
    <title><![CDATA[关于使用flex布局遇到的一个小问题]]></title>
    <url>%2F2019%2F05%2F23%2F%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8flex%E5%B8%83%E5%B1%80%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;昨天在给我的课程设计的网站做底部信息的时候遇到了一个问题，就是我给一个子元素div设置了固定的宽度，但是当我页面宽度发生变化的时候，这个div的宽度也会发生变化，毕竟我设置的是固定的宽度，所以这肯定不是我想要的效果，今天和昨天经过测试，现在终于把问题解决了，问题是由于flex引起的。让我们先看我的一个测试的代码：123456789101112131415161718192021222324&lt;style&gt;.big&#123; width: 100%; height: 500px; background-color: blue; display: flex; border: 2px solid #000; justify-content: center; align-items: center; margin: 0 auto;&#125;.sm&#123; width: 1200px;//这里是一个固定的宽度 height: 400px; background-color: red; text-align: center; border: 3px solid yellow;//加了一个黄色边框，方便观察&#125;&lt;/style&gt;&lt;body&gt; &lt;div class="big"&gt; &lt;div class="sm"&gt;这是测试的内容&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 按照我一开始的想法，既然设置了固定的宽度，应该就不会再发生改变了，即使是flex也不能改变它可是我们再看看效果图：很明显，里面的子元素的宽度也因为父元素的宽度变小了而变小了。 我的第一次尝试是给它加一个min-width=1200px，我们再看看效果：还是一样，没有发生任何变化。那究竟要怎么解决这个问题呢，经过我的各种尝试和猜想，最终还是把问题解决了：那么要如何解决这个问题呢，看我解决后的代码：1234567891011121314151617181920212223242526&lt;style&gt;.big&#123; width: 100%; height: 500px; background-color: blue; display: flex; border: 2px solid #000; /* justify-content: center; */ //1、首先就是不能用这个属性 align-items: center; margin: 0 auto;&#125;.sm&#123; width: 1200px; min-width: 1200px; //3、同时要加上最小宽度 height: 400px; background-color: red; text-align: center; margin: 0 auto; //2、只能使用这个来使子元素居中 border: 3px solid yellow;&#125;&lt;/style&gt;&lt;body&gt; &lt;div class=&quot;big&quot;&gt; &lt;div class=&quot;sm&quot;&gt;21413423&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 我们再来看看解决后的效果图：这次我们就可以看到，里面的内容没有被缩小了，问题终于得到了解决。 其实还有一种办法可以避免这种问题，就是最外层子元素不使用flex布局，或者是不设置百分比的宽度，这样也不会出现这种问题，但是在有些情况下使用flex明显要方便很多，看实际情况选择哪种处理办法吧。 更新补充后来我又想到了一个相对较好的解决办法，那就使最外层的div可以设置为百分比的宽度，但是不设置flex，我们对要布局的子div给它再加一个父元素，让它变成孙子，我们给他加的这个div让他成为父元素，并且给这个父元素设置flex和固定的我们想要的宽度，这个时候通过父元素的flex给孙子元素flex布局就也不会出现这种问题了，这也是一种不错的解决办法（推荐） 总结flex虽然好用，很多方面用起来很方便，但是也存在很多问题我还不知道，所以使用的时候要提前做好规划，避免出现问题，我的轮播图bug就是由于flex布局引起的，但是不知道是不是这个原因。]]></content>
  </entry>
  <entry>
    <title><![CDATA[初识cookie]]></title>
    <url>%2F2019%2F05%2F21%2F%E5%88%9D%E8%AF%86cookie%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;即使在我学习前端知识前，作为一个网络用户，我也见过cookie，但是它究竟是干什么的，有什么用，这是我以前所不知道的，但是我现在作为一名前端学习者，那么就要了解并学习cookie的相关知识，并且会使用它。 什么是cookie？这是百度百科上的一段话：Cookie，有时也用其复数形式 Cookies，指某些网站为了辨别用户身份、进行 session 跟踪而储存在用户本地终端上的数据（通常经过加密）。定义于 RFC2109 和 2965 中的都已废弃，最新取代的规范是 RFC6265 [1] 。（可以叫做浏览器缓存） 我们就可以了解到cookie的作用，cookie就是存储了一些信息在本地，并且有一定的存在时间，cookie有这样的功能，就能给用户带来很多遍历，包括不用重复登录之类的。 cookie的一些特点 cookie的生命周期：·默认情况下是一次会话，也就是直到浏览器被关闭。·如果通过expires设置了时间，并且时间还没有过期，那么关闭浏览器后下次再打开浏览器，cookie还是存在的。·如果通过expires设置了时间，但是过期了，那么就会立即删除这个cookie，所以要删除一个cookie，只要让他过期就好了。 cookie数据的格式·cookie默认是不会保存任何数据的。document.cookie=&quot;name=hsl&quot;可以通过这种方式来添加cookie·在设置cookie时只能一条一条的设置，不能一条命令设置多条cookie。cookie有大小和个数的限制：个数：20~50大小：4kb左右 cookie的作用范围·不同浏览器之间的cookie不能共用·同一浏览器中，存放cookie的路径的子目录可以访问保存的cookie，但是父目录不能。document.cookie=&quot;name=hsl;path=/;&quot;但是可以通过加上path等于根目录使网站下的所有目录都能访问cookie。·默认情况下二级域名之间的cookie不能相互访问，但是设置了主域名之后就可以，domain=hslweb.net。 实际操作一下12345&lt;script&gt; var data=new Date(); data.setDate(data.getDate()+1);//设置时间 document.cookie="name=hsl;path=/;expires="+data.toGMTString()+";";//创建一个cookie，设置了路径以及过期的时间为后一天。&lt;/script&gt; 总结：cookie的创建与设置还是很简单的，但是哦cookie的作用却很强大，要好好使用。]]></content>
  </entry>
  <entry>
    <title><![CDATA[通过post方式上传文件]]></title>
    <url>%2F2019%2F05%2F21%2F%E9%80%9A%E8%BF%87post%E6%96%B9%E5%BC%8F%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这次学习一下通过表单得到post方式来向后端上传文件，以及使用表单来上传文件的注意点及注意事项。先上代码：123456&lt;body&gt; &lt;form action="post上传文件.php" method="POST" enctype="multipart/form-data"&gt; &lt;input type="file" name="upFile" id=""&gt;&lt;br&gt; &lt;input type="submit" name="tj"&gt; &lt;/form&gt;&lt;/body&gt; 这里之所以使用post方式上传而不使用get方式上传是因为get方式上传有文件大小方面的限制，最多2000个字符，所以使用post 很正常的一个表单，设置了控件类型以及与后端交互时要用到的name 但是要注意的是上传文件时除了要设置表单类型为 file之外，还需要给form添加一个enctype属性，并且把它的值设为multipart/form-data，只有这样才能正常上传。 我们再来看看php部分的代码：123456&lt;?phpprint_r($_FILES);echo '&lt;br&gt;';$fileInfo=$_FILES['upFile'];print_r($fileInfo);?&gt; 这个时候我们就不能再使用post方式来获取文件的内容了，我们需要用file方式。我么再来看看打印的结果：1234Array ( [tj] =&gt; 提交 ) //这个时候post变量获取到的东西就不是我们想要的东西了。Array ( [upFile] =&gt; Array ( [name] =&gt; 后面问题.png [type] =&gt; image/png [tmp_name] =&gt; E:\xampp\tmp\phpDC76.tmp [error] =&gt; 0 [size] =&gt; 32458 ) ) //而通过file变量获取到的数组里面就有我们想要的东西Array ( [name] =&gt; 后面问题.png [type] =&gt; image/png [tmp_name] =&gt; E:\xampp\tmp\phpDC76.tmp [error] =&gt; 0 [size] =&gt; 32458 )//然后再从数组中取出我们想要的文件，就可以得到文件的信息。 但是其实这个时候也不是我们想要的结果，因为我们会发现 E:\xampp\tmp\这个目录下是空的，并没有我们上传的文件 这是因为这其实是一个临时文件夹，如果我们需要永久保存我们想要的内容我们需要将文件保存到我们自己建立的一个文件夹中。 这个时候我们就需要使用到这个函数move_uploaded_file(file,newloc)第一个参数规定文件的原路径，第二个参数规定文件的新路径已经文件名。 下面将代码改进一下：加上一行代码：1move_uploaded_file($fileInfo['tmp_name'],"./test_imgs/".$fileInfo['name']); 这个时候我们再看设置的那个新路径，就已经成功将文件移动过来了。 总结：上传文件的表单与其他表单有些许不一样，要多注意，获取内容的方法也不太一样，并且要注意move_uploaded_file函数的使用，第二个参数写相对路径的时候，如果是相对与当前路径开始的话一定不能遗漏了./来表示当前路径，比如我刚开始这样写就报错：&quot;test_imgs/&quot;,而这样写就是对的:&quot;./test_imgs/&quot;所以以后要多注意。]]></content>
  </entry>
  <entry>
    <title><![CDATA[jQuery中eq与get的区别]]></title>
    <url>%2F2019%2F05%2F20%2FjQuery%E4%B8%ADeq%E4%B8%8Eget%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在刚开始学习使用jQuery的时候就遇到过类似的问题，没有完全理解到什么是jQuery对象以它与Element对象的区别。而jQuery中的eq方法与get方法正好也是这方面的区别，这次来好好把他们区分一下。先上一段html代码1234&lt;body&gt; &lt;div class="test1"&gt;这是一个测试div &lt;span&gt;这是一个子元素&lt;/span&gt;&lt;/div&gt; &lt;div class="test2"&gt;这是第二个测试div&lt;/div&gt;&lt;/body&gt; js代码12345678910111213141516171819202122232425262728&lt;script&gt; $(function()&#123; // 通过这个可以看出使用核心函数选择div会将它转化成一个jQuery对象，jQuery对象的本质是一个数组对象，有length属性 console.log( $('div') ); // 而我们通过get方法获取到的对象其实是一个Element对象 console.log( $('div').get(0) ); // 所以我们就可以对它使用js原生的方法来获取它的子节点 console.log( $('div').get(0).children[0] ); // 而这种写法获取到的东西是和get所获取到的东西是一模一样的 console.log( $('div')[1] ); // 而通过eq获取到的其实是一个jQuery对象 console.log( $('div').eq(0) ); // 我们亦可以通过jQuery的核心函数将Element对象转化成jQuery对象 console.log( $($('div').get(0)) ); &#125;) &lt;/script&gt; 我们再来看看输出的结果: 总结:eq与get的区别十分的明显,一个获取到的是jQuery对象,一个获取到的是Element对象,而我们的jQuery的方法只能对jQuery对象使用,所以我们要特别注意我们获取到的是什么对象,当然我们也可以通过jQuery核心函数将Element对象转化为jQuery对象.]]></content>
  </entry>
  <entry>
    <title><![CDATA[flex使用的小demo]]></title>
    <url>%2F2019%2F05%2F18%2Fflex%E4%BD%BF%E7%94%A8%E7%9A%84%E5%B0%8Fdemo%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前面学习了flex的相关知识，现在就这些知识运用到实例，通过写一个导航栏和一个搜索框试试效果怎么样。 通过flex布局一个等分的导航栏代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;style&gt;*&#123; margin: 0; padding: 0; list-style: none;&#125;nav&#123; width: 40%; height: 50px; background: #ccc; margin: 0 auto;&#125;nav&gt;ul&#123; display: flex; height: 100%; width: 100%; flex-flow: row nowrap; /* justify-content: space-around; */ align-items: center;&#125;/* 通过给子元素使用flex-grow会影响到父元素设置的justify-content，但是无论使用哪种方法都能达到相同的效果 */ul&gt;li&#123; text-align: center;&#125;/* 以下代码其实都可以不用，只通过一个justify-content: space-between就能达到这种效果 */ul&gt;li:nth-child(1)&#123; flex: 0 0 auto; text-align: center;&#125;ul&gt;li:nth-child(2)&#123; flex: auto; text-align: center;&#125;ul&gt;li:nth-child(3)&#123; flex: auto; text-align: center;&#125;ul&gt;li:nth-child(4)&#123; flex: auto; flex: 0 0 auto;&#125;&lt;/style&gt;&lt;body&gt; &lt;nav&gt; &lt;ul&gt; &lt;li&gt;栏目一&lt;/li&gt; &lt;li&gt;栏目二&lt;/li&gt; &lt;li&gt;栏目三&lt;/li&gt; &lt;li&gt;栏目四&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt;&lt;/body&gt; 效果图： 通过flex布局一个搜索框代码：12345678910111213141516171819202122232425262728293031323334&lt;style&gt;*&#123; margin: 0; padding: 0; list-style: none;&#125;.search&#123; margin: 0 auto; margin-top: 20px; width: 500px; display: flex;&#125;input&#123; /* 因为默认另一个button的flex-grow为0， 只要设置这个输入框的flex-grow为1则可以占满剩下的宽度 */ flex-grow: 1;&#125;button&#123; border: 0; background-color: red; outline: none; height: 30px; /* 当我们把button的高度调高之后，可以发现输入框的高度也一起随之升高了 如果想要改变这种效果可以对输入框设置align-self */&#125;&lt;/style&gt;&lt;body&gt; &lt;div class="search"&gt; &lt;input type="text"&gt; &lt;button&gt;点击搜索&lt;/button&gt; &lt;/div&gt;&lt;/body&gt; 效果图： 总结使用flex布局真的好轻松，好方便啊，再也不用为各种繁琐的事情改开改去了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[CSS3_flex的使用]]></title>
    <url>%2F2019%2F05%2F18%2FCSS3-flex%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前段时间有了解到flex布局，flex布局是W3C再2009年提出的一种新的方案，且现在已经兼容所有的浏览器，传统的布局方式在有些时候会比较麻烦，且兼容性不是特别好，那么使用flex布局就能解决很多问题，这次来学习以下flex布局，并加以使用，以后熟练使用就能大大提高我们的布局效率。 Flex布局是什么？Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。123.box&#123; display: flex;&#125; 行内元素也可以使用Flex布局。123.box&#123; display: inline-flex;&#125; Webkit内核的浏览器，必须加上-webkit前缀。1234.box&#123; display: -webkit-flex; /* Safari */ display: flex;&#125; 注意:设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。 基本概念采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 容器的属性容器有以下6个属性： flex-direction flex-wrap flex-flow justify-content align-items align-content flex-direction属性flex-direction属性决定主轴的方向（即项目的排列方向）。123.box &#123; flex-direction: row | row-reverse | column | column-reverse;&#125; 可能有4个值： row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 flex-wrap属性默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。123.box&#123; flex-wrap: nowrap | wrap | wrap-reverse;&#125; 它可能取三个值: nowrap（默认）：不换行。 wrap：换行，第一行在上方。 wrap-reverse：换行，第一行在下方。 flex-flowflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。123.box &#123; flex-flow: &lt;flex-direction&gt; &lt;flex-wrap&gt;;&#125; justify-content属性justify-content属性定义了项目在主轴上的对齐方式。123.box &#123; justify-content: flex-start | flex-end | center | space-between | space-around;&#125; 可能取5个值，与主轴方向有关（以下假设主轴从左向右）： flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 （在做菜单栏导航栏等需要间隔相等的项目中十分有用） space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 align-items属性align-items属性定义项目在交叉轴上如何对齐。123.box &#123; align-items: flex-start | flex-end | center | baseline | stretch;&#125; 可能取5个值，与交叉轴方向有关（以下假设主轴从上向下） flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 align-content属性align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。123.box &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125; 该属性可能取6个值： flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 项目的属性以下6个属性设置在项目上。 order flex-grow flex-shrink flex-basis flex align-self order属性order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。123.item &#123; order: &lt;integer&gt;;&#125; flex-grow属性flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。123.item &#123; flex-grow: &lt;number&gt;; /* default 0 */&#125; 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 flex-shrink属性flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。123.item &#123; flex-shrink: &lt;number&gt;; /* default 1 */&#125; 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。负值对该属性无效。 flex-basis属性flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。123.item &#123; flex-basis: &lt;length&gt; | auto; /* default auto */&#125; 它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。 flex属性flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。123.item &#123; flex: none | [ &lt;&apos;flex-grow&apos;&gt; &lt;&apos;flex-shrink&apos;&gt;? || &lt;&apos;flex-basis&apos;&gt; ]&#125; 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 align-self属性align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。123.item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch;&#125; 该属性可能取6个值，除了auto，其他都与align-items属性完全一致。 文章转载自：http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[jQuery学习（动画效果）]]></title>
    <url>%2F2019%2F05%2F15%2FjQuery%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这次总结以下jQuery中所有自带的动画效果以及jQuery中的自定义动画，以及动画1的其他一些相关方法，帮助我们更好的学习和使用jQuery中的动画。前面已经学习使用过大部分自带动画了，这次着重讲一下自定义动画与其他方法。 显示、隐藏动画show([s,[e],[fn]]) 显示动画 内部实现原理根据当前操作的元素是块级还是行内决定, 块级内部调用display:block;,行内内部调用display:inline; hide([s,[e],[fn]]) 隐藏动画 toggle([spe],[eas],[fn]) 切换动画(显示变隐藏,隐藏变显示) 注意事项: show(1000, function () {};) 第一个参数单位是毫秒, 1000毫秒等于1秒 默认的动画时长是400毫秒 除了指定毫秒以外还可以指定三个预设参数 slow、normal、fast slow本质是600毫秒 normal本质是400毫秒 fast本质是200毫秒 展开、收起动画参数、注意事项和显示隐藏动画一模一样, 只不过动画效果不一样而已 slideDown([s],[e],[fn])展开动画 slideUp([s,[e],[fn]])收起动画 slideToggle([s],[e],[fn])切换动画(展开变收起,收起变展开)参数、注意事项和显示隐藏动画一模一样, 只不过动画效果不一样而已 fadeIn([s],[e],[fn])淡入动画 fadeOut([s],[e],[fn])淡出动画 fadeToggle([s,[e],[fn]])切换动画(显示变淡出,不显示变淡入) fadeTo([[s],o,[e],[fn]])淡入到指定透明度动画可以通过第二个参数,淡入到指定的透明度(取值范围0~1) 自定义动画有时候自带的这些动画不能完全满足我们的需求，我们就需要使用到自定义动画来帮助我们完成动画。 animate(p,[s],[e],[fn]) 第一个参数: 接收一个对象, 可以在对象中修改属性 第二个参数: 指定动画时长 第三个参数: 指定动画节奏, 默认就是swing 第四个参数: 动画执行完毕之后的回调函数下面是一个自定义动画的例子：123456789101112131415161718192021222324252627282930313233&lt;style&gt;.test&#123; background: red; width: 200px; height: 200px; border-radius: 50%;&#125;&lt;/style&gt;&lt;body&gt; &lt;div class="test"&gt;&lt;/div&gt; &lt;script&gt; $(function()&#123; // 使圆变大 $('.test').animate(&#123; // 可以同时设置多个值的变化 width:400, height:400, // 可以设置动画节奏 &#125;,2000,'Linear',function()&#123; // 可以链式设置多个动画 alert('变大执行完毕') &#125;).animate(&#123; marginLeft:200 &#125;,2000,function()&#123; alert('右移执行完毕') &#125;).animate(&#123; marginLeft:"800" &#125;,2000,function()&#123; alert('完成') &#125;); &#125;) &lt;/script&gt;&lt;/body&gt; 要注意的一点:每次开始运动都必须是初始位置或者初始状态,如果想在上一次位置或者状态下再次进行动画可以使用累加动画,上面这个例子就是圆先变大,然后在变大之前的圆心处右移,然后再回到圆心处再次右移,所以要使用累计动画的方式来设置参数比如说{marginLeft:&quot;+=200&quot;} 动画队列 多个动画方法链式编程,会等到前面的动画执行完毕再依次执行后续动画 但是如果后面紧跟一个非动画方法则会被立即执行 如果想颜色再动画执行完毕之后设置, 1.使用回调 2.使用动画队列 注意点:动画队列方法queue()后面不能继续直接添加queue()如果想继续添加必须在上一个queue()方法中next()方法 动画相关方法 delay(d,[q])设置动画延迟时长 stop([c],[j])停止指定元素上正在执行的动画1234567891011121314// 立即停止当前动画, 继续执行后续的动画// $(&quot;div&quot;).stop();// $(&quot;div&quot;).stop(false);// $(&quot;div&quot;).stop(false, false);// 立即停止当前和后续所有的动画// $(&quot;div&quot;).stop(true);// $(&quot;div&quot;).stop(true, false);// 立即完成当前的, 继续执行后续动画// $(&quot;div&quot;).stop(false, true);// 立即完成当前的, 并且停止后续所有的$(&quot;div&quot;).stop(true, true);]]></content>
  </entry>
  <entry>
    <title><![CDATA[Chrome插件(扩展)开发全攻略]]></title>
    <url>%2F2019%2F05%2F15%2FChrome%E6%8F%92%E4%BB%B6(%E6%89%A9%E5%B1%95)%E5%BC%80%E5%8F%91%E5%85%A8%E6%94%BB%E7%95%A5%2F</url>
    <content type="text"><![CDATA[写在前面 这篇文章来自于转载，作者花了许多时间编写，写的也很详细，也很辛苦，我已经在文章尾部标明，也感谢作者的分享，这是文章原地址以下是作者原文：来源我花了将近一个多月的时间断断续续写下这篇博文，并精心写下完整demo，写博客的辛苦大家懂的，所以转载务必保留出处。本文所有涉及到的大部分代码均在这个demo里面：https://github.com/sxei/chrome-plugin-demo ，大家可以直接下载下来运行。 另外，本文图片较多，且图片服务器带宽有限，右下角的目录滚动监听必须等到图片全部加载完毕之后才会触发，所以请耐心等待加载完毕。 本文目录： demo部分截图： 前言 2.1. 什么是Chrome插件 严格来讲，我们正在说的东西应该叫Chrome扩展(Chrome Extension)，真正意义上的Chrome插件是更底层的浏览器功能扩展，可能需要对浏览器源码有一定掌握才有能力去开发。鉴于Chrome插件的叫法已经习惯，本文也全部采用这种叫法，但读者需深知本文所描述的Chrome插件实际上指的是Chrome扩展。 Chrome插件是一个用Web技术开发、用来增强浏览器功能的软件，它其实就是一个由HTML、CSS、JS、图片等资源组成的一个.crx后缀的压缩包. 个人猜测crx可能是Chrome Extension如下3个字母的简写： 另外，其实不只是前端技术，Chrome插件还可以配合C++编写的dll动态链接库实现一些更底层的功能(NPAPI)，比如全屏幕截图。 由于安全原因，Chrome浏览器42以上版本已经陆续不再支持NPAPI插件，取而代之的是更安全的PPAPI。 2.2. 学习Chrome插件开发有什么意义 增强浏览器功能，轻松实现属于自己的“定制版”浏览器，等等。 Chrome插件提供了很多实用API供我们使用，包括但不限于： 书签控制； 下载控制； 窗口控制； 标签控制； 网络请求控制，各类事件监听； 自定义原生菜单； 完善的通信机制； 等等； 2.3. 为什么是Chrome插件而不是Firefox插件 Chrome占有率更高，更多人用； 开发更简单； 应用场景更广泛，Firefox插件只能运行在Firefox上，而Chrome除了Chrome浏览器之外，还可以运行在所有webkit内核的国产浏览器，比如360极速浏览器、360安全浏览器、搜狗浏览器、QQ浏览器等等； 除此之外，Firefox浏览器也对Chrome插件的运行提供了一定的支持； 开发与调试 Chrome插件没有严格的项目结构要求，只要保证本目录有一个manifest.json即可，也不需要专门的IDE，普通的web开发工具即可。 从右上角菜单-&gt;更多工具-&gt;扩展程序可以进入 插件管理页面，也可以直接在地址栏输入 chrome://extensions 访问。 勾选开发者模式即可以文件夹的形式直接加载插件，否则只能安装.crx格式的文件。Chrome要求插件必须从它的Chrome应用商店安装，其它任何网站下载的都无法直接安装，所以，其实我们可以把crx文件解压，然后通过开发者模式直接加载。 开发中，代码有任何改动都必须重新加载插件，只需要在插件管理页按下Ctrl+R即可，以防万一最好还把页面刷新一下。 核心介绍 4.1. manifest.json 这是一个Chrome插件最重要也是必不可少的文件，用来配置所有和插件相关的配置，必须放在根目录。其中，manifest_version、name、version3个是必不可少的，description和icons是推荐的。 下面给出的是一些常见的配置项，均有中文注释，完整的配置文档请戳这里。 { // 清单文件的版本，这个必须写，而且必须是2 "manifest_version": 2, // 插件的名称 "name": "demo", // 插件的版本 "version": "1.0.0", // 插件描述 "description": "简单的Chrome扩展demo", // 图标，一般偷懒全部用一个尺寸的也没问题 "icons": { "16": "img/icon.png", "48": "img/icon.png", "128": "img/icon.png" }, // 会一直常驻的后台JS或后台页面 "background": { // 2种指定方式，如果指定JS，那么会自动生成一个背景页 "page": "background.html" //"scripts": ["js/background.js"] }, // 浏览器右上角图标设置，browser_action、page_action、app必须三选一 "browser_action": { "default_icon": "img/icon.png", // 图标悬停时的标题，可选 "default_title": "这是一个示例Chrome插件", "default_popup": "popup.html" }, // 当某些特定页面打开才显示的图标 /*"page_action": { "default_icon": "img/icon.png", "default_title": "我是pageAction", "default_popup": "popup.html" },*/ // 需要直接注入页面的JS "content_scripts": [ { //"matches": ["http://*/*", "https://*/*"], // "&lt;all_urls&gt;" 表示匹配所有地址 "matches": ["&lt;all_urls&gt;"], // 多个JS按顺序注入 "js": ["js/jquery-1.8.3.js", "js/content-script.js"], // JS的注入可以随便一点，但是CSS的注意就要千万小心了，因为一不小心就可能影响全局样式 "css": ["css/custom.css"], // 代码注入的时间，可选值： "document_start", "document_end", or "document_idle"，最后一个表示页面空闲时，默认document_idle "run_at": "document_start" }, // 这里仅仅是为了演示content-script可以配置多个规则 { "matches": ["*://*/*.png", "*://*/*.jpg", "*://*/*.gif", "*://*/*.bmp"], "js": ["js/show-image-content-size.js"] } ], // 权限申请 "permissions": [ "contextMenus", // 右键菜单 "tabs", // 标签 "notifications", // 通知 "webRequest", // web请求 "webRequestBlocking", "storage", // 插件本地存储 "http://*/*", // 可以通过executeScript或者insertCSS访问的网站 "https://*/*" // 可以通过executeScript或者insertCSS访问的网站 ], // 普通页面能够直接访问的插件资源列表，如果不设置是无法直接访问的 "web_accessible_resources": ["js/inject.js"], // 插件主页，这个很重要，不要浪费了这个免费广告位 "homepage_url": "https://www.baidu.com", // 覆盖浏览器默认页面 "chrome_url_overrides": { // 覆盖浏览器默认的新标签页 "newtab": "newtab.html" }, // Chrome40以前的插件配置页写法 "options_page": "options.html", // Chrome40以后的插件配置页写法，如果2个都写，新版Chrome只认后面这一个 "options_ui": { "page": "options.html", // 添加一些默认的样式，推荐使用 "chrome_style": true }, // 向地址栏注册一个关键字以提供搜索建议，只能设置一个关键字 "omnibox": { "keyword" : "go" }, // 默认语言 "default_locale": "zh_CN", // devtools页面入口，注意只能指向一个HTML文件，不能是JS文件 "devtools_page": "devtools.html" } 4.2. content-scripts 所谓content-scripts，其实就是Chrome插件中向页面注入脚本的一种形式（虽然名为script，其实还可以包括css的），借助content-scripts我们可以实现通过配置的方式轻松向指定页面注入JS和CSS（如果需要动态注入，可以参考下文），最常见的比如：广告屏蔽、页面CSS定制，等等。 示例配置： { // 需要直接注入页面的JS "content_scripts": [ { //"matches": ["http://*/*", "https://*/*"], // "&lt;all_urls&gt;" 表示匹配所有地址 "matches": ["&lt;all_urls&gt;"], // 多个JS按顺序注入 "js": ["js/jquery-1.8.3.js", "js/content-script.js"], // JS的注入可以随便一点，但是CSS的注意就要千万小心了，因为一不小心就可能影响全局样式 "css": ["css/custom.css"], // 代码注入的时间，可选值： "document_start", "document_end", or "document_idle"，最后一个表示页面空闲时，默认document_idle "run_at": "document_start" } ], } 特别注意，如果没有主动指定run_at为document_start（默认为document_idle），下面这种代码是不会生效的： document.addEventListener('DOMContentLoaded', function() { console.log('我被执行了！'); }); content-scripts和原始页面共享DOM，但是不共享JS，如要访问页面JS（例如某个JS变量），只能通过injected js来实现。content-scripts不能访问绝大部分chrome.xxx.api，除了下面这4种： chrome.extension(getURL , inIncognitoContext , lastError , onRequest , sendRequest) chrome.i18n chrome.runtime(connect , getManifest , getURL , id , onConnect , onMessage , sendMessage) chrome.storage 其实看到这里不要悲观，这些API绝大部分时候都够用了，非要调用其它API的话，你还可以通过通信来实现让background来帮你调用（关于通信，后文有详细介绍）。 好了，Chrome插件给我们提供了这么强大的JS注入功能，剩下的就是发挥你的想象力去玩弄浏览器了。 4.3. background 后台（姑且这么翻译吧），是一个常驻的页面，它的生命周期是插件中所有类型页面中最长的，它随着浏览器的打开而打开，随着浏览器的关闭而关闭，所以通常把需要一直运行的、启动就运行的、全局的代码放在background里面。 background的权限非常高，几乎可以调用所有的Chrome扩展API（除了devtools），而且它可以无限制跨域，也就是可以跨域访问任何网站而无需要求对方设置CORS。 经过测试，其实不止是background，所有的直接通过chrome-extension://id/xx.html这种方式打开的网页都可以无限制跨域。 配置中，background可以通过page指定一张网页，也可以通过scripts直接指定一个JS，Chrome会自动为这个JS生成一个默认的网页： { // 会一直常驻的后台JS或后台页面 "background": { // 2种指定方式，如果指定JS，那么会自动生成一个背景页 "page": "background.html" //"scripts": ["js/background.js"] }, } 需要特别说明的是，虽然你可以通过chrome-extension://xxx/background.html直接打开后台页，但是你打开的后台页和真正一直在后台运行的那个页面不是同一个，换句话说，你可以打开无数个background.html，但是真正在后台常驻的只有一个，而且这个你永远看不到它的界面，只能调试它的代码。 4.4. event-pages 这里顺带介绍一下event-pages，它是一个什么东西呢？鉴于background生命周期太长，长时间挂载后台可能会影响性能，所以Google又弄一个event-pages，在配置文件上，它与background的唯一区别就是多了一个persistent参数： { "background": { "scripts": ["event-page.js"], "persistent": false }, } 它的生命周期是：在被需要时加载，在空闲时被关闭，什么叫被需要时呢？比如第一次安装、插件更新、有content-script向它发送消息，等等。 除了配置文件的变化，代码上也有一些细微变化，个人这个简单了解一下就行了，一般情况下background也不会很消耗性能的。 4.5. popup popup是点击browser_action或者page_action图标时打开的一个小窗口网页，焦点离开网页就立即关闭，一般用来做一些临时性的交互。 popup可以包含任意你想要的HTML内容，并且会自适应大小。可以通过default_popup字段来指定popup页面，也可以调用setPopup()方法。 配置方式： { "browser_action": { "default_icon": "img/icon.png", // 图标悬停时的标题，可选 "default_title": "这是一个示例Chrome插件", "default_popup": "popup.html" } } 需要特别注意的是，由于单击图标打开popup，焦点离开又立即关闭，所以popup页面的生命周期一般很短，需要长时间运行的代码千万不要写在popup里面。 在权限上，它和background非常类似，它们之间最大的不同是生命周期的不同，popup中可以直接通过chrome.extension.getBackgroundPage()获取background的window对象。 4.6. injected-script 这里的injected-script是我给它取的，指的是通过DOM操作的方式向页面注入的一种JS。为什么要把这种JS单独拿出来讨论呢？又或者说为什么需要通过这种方式注入JS呢？ 这是因为content-script有一个很大的“缺陷”，也就是无法访问页面中的JS，虽然它可以操作DOM，但是DOM却不能调用它，也就是无法在DOM中通过绑定事件的方式调用content-script中的代码（包括直接写onclick和addEventListener2种方式都不行），但是，“在页面上添加一个按钮并调用插件的扩展API”是一个很常见的需求，那该怎么办呢？其实这就是本小节要讲的。 在content-script中通过DOM方式向页面注入inject-script代码示例： // 向页面注入JS function injectCustomJs(jsPath) { jsPath = jsPath || 'js/inject.js'; var temp = document.createElement('script'); temp.setAttribute('type', 'text/javascript'); // 获得的地址类似：chrome-extension://ihcokhadfjfchaeagdoclpnjdiokfakg/js/inject.js temp.src = chrome.extension.getURL(jsPath); temp.onload = function() { // 放在页面不好看，执行完后移除掉 this.parentNode.removeChild(this); }; document.head.appendChild(temp); } 你以为这样就行了？执行一下你会看到如下报错： Denying load of chrome-extension://efbllncjkjiijkppagepehoekjojdclc/js/inject.js. Resources must be listed in the web_accessible_resources manifest key in order to be loaded by pages outside the extension. 意思就是你想要在web中直接访问插件中的资源的话必须显示声明才行，配置文件中增加如下： { // 普通页面能够直接访问的插件资源列表，如果不设置是无法直接访问的 "web_accessible_resources": ["js/inject.js"], } 至于inject-script如何调用content-script中的代码，后面我会在专门的一个消息通信章节详细介绍。 4.7. homepage_url 开发者或者插件主页设置，一般会在如下2个地方显示： Chrome插件的8种展示形式 5.1. browserAction(浏览器右上角) 通过配置browser_action可以在浏览器的右上角增加一个图标，一个browser_action可以拥有一个图标，一个tooltip，一个badge和一个popup。 示例配置如下： "browser_action": { "default_icon": "img/icon.png", "default_title": "这是一个示例Chrome插件", "default_popup": "popup.html" } 5.1.1. 图标 browser_action图标推荐使用宽高都为19像素的图片，更大的图标会被缩小，格式随意，一般推荐png，可以通过manifest中default_icon字段配置，也可以调用setIcon()方法。 5.1.2. tooltip 修改browser_action的manifest中default_title字段，或者调用setTitle()方法。 5.1.3. badge 所谓badge就是在图标上显示一些文本，可以用来更新一些小的扩展状态提示信息。因为badge空间有限，所以只支持4个以下的字符（英文4个，中文2个）。badge无法通过配置文件来指定，必须通过代码实现，设置badge文字和颜色可以分别使用setBadgeText()和setBadgeBackgroundColor()。 chrome.browserAction.setBadgeText({text: 'new'}); chrome.browserAction.setBadgeBackgroundColor({color: [255, 0, 0, 255]}); 效果： 5.2. pageAction(地址栏右侧) 所谓pageAction，指的是只有当某些特定页面打开才显示的图标，它和browserAction最大的区别是一个始终都显示，一个只在特定情况才显示。 需要特别说明的是早些版本的Chrome是将pageAction放在地址栏的最右边，左键单击弹出popup，右键单击则弹出相关默认的选项菜单： 而新版的Chrome更改了这一策略，pageAction和普通的browserAction一样也是放在浏览器右上角，只不过没有点亮时是灰色的，点亮了才是彩色的，灰色时无论左键还是右键单击都是弹出选项： 具体是从哪一版本开始改的没去仔细考究，反正知道v50.0的时候还是前者，v58.0的时候已改为后者。 调整之后的pageAction我们可以简单地把它看成是可以置灰的browserAction。 chrome.pageAction.show(tabId) 显示图标； chrome.pageAction.hide(tabId) 隐藏图标； 示例(只有打开百度才显示图标)： // manifest.json { "page_action": { "default_icon": "img/icon.png", "default_title": "我是pageAction", "default_popup": "popup.html" }, "permissions": ["declarativeContent"] } // background.js chrome.runtime.onInstalled.addListener(function(){ chrome.declarativeContent.onPageChanged.removeRules(undefined, function(){ chrome.declarativeContent.onPageChanged.addRules([ { conditions: [ // 只有打开百度才显示pageAction new chrome.declarativeContent.PageStateMatcher({pageUrl: {urlContains: 'baidu.com'}}) ], actions: [new chrome.declarativeContent.ShowPageAction()] } ]); }); }); 效果图： 5.3. 右键菜单 通过开发Chrome插件可以自定义浏览器的右键菜单，主要是通过chrome.contextMenusAPI实现，右键菜单可以出现在不同的上下文，比如普通页面、选中的文字、图片、链接，等等，如果有同一个插件里面定义了多个菜单，Chrome会自动组合放到以插件名字命名的二级菜单里，如下： 5.3.1. 最简单的右键菜单示例 // manifest.json {"permissions": ["contextMenus"]} // background.js chrome.contextMenus.create({ title: "测试右键菜单", onclick: function(){alert('您点击了右键菜单！');} }); 效果： 5.3.2. 添加右键百度搜索 // manifest.json {"permissions": ["contextMenus"， "tabs"]} // background.js chrome.contextMenus.create({ title: '使用度娘搜索：%s', // %s表示选中的文字 contexts: ['selection'], // 只有当选中文字时才会出现此右键菜单 onclick: function(params) { // 注意不能使用location.href，因为location是属于background的window对象 chrome.tabs.create({url: 'https://www.baidu.com/s?ie=utf-8&amp;wd=' + encodeURI(params.selectionText)}); } }); 效果如下： 5.3.3. 语法说明 这里只是简单列举一些常用的，完整API参见：https://developer.chrome.com/extensions/contextMenus chrome.contextMenus.create({ type: 'normal'， // 类型，可选：["normal", "checkbox", "radio", "separator"]，默认 normal title: '菜单的名字', // 显示的文字，除非为“separator”类型否则此参数必需，如果类型为“selection”，可以使用%s显示选定的文本 contexts: ['page'], // 上下文环境，可选：["all", "page", "frame", "selection", "link", "editable", "image", "video", "audio"]，默认page onclick: function(){}, // 单击时触发的方法 parentId: 1, // 右键菜单项的父菜单项ID。指定父菜单项将会使此菜单项成为父菜单项的子菜单 documentUrlPatterns: 'https://*.baidu.com/*' // 只在某些页面显示此右键菜单 }); // 删除某一个菜单项 chrome.contextMenus.remove(menuItemId)； // 删除所有自定义右键菜单 chrome.contextMenus.removeAll(); // 更新某一个菜单项 chrome.contextMenus.update(menuItemId, updateProperties); 5.4. override(覆盖特定页面) 使用override页可以将Chrome默认的一些特定页面替换掉，改为使用扩展提供的页面。 扩展可以替代如下页面： 历史记录：从工具菜单上点击历史记录时访问的页面，或者从地址栏直接输入 chrome://history 新标签页：当创建新标签的时候访问的页面，或者从地址栏直接输入 chrome://newtab 书签：浏览器的书签，或者直接输入 chrome://bookmarks 注意： 一个扩展只能替代一个页面； 不能替代隐身窗口的新标签页； 网页必须设置title，否则用户可能会看到网页的URL，造成困扰； 下面的截图是默认的新标签页和被扩展替换掉的新标签页。 代码（注意，一个插件只能替代一个默认页，以下仅为演示）： "chrome_url_overrides": { "newtab": "newtab.html", "history": "history.html", "bookmarks": "bookmarks.html" } 5.5. devtools(开发者工具) 5.5.1. 预热 使用过vue的应该见过这种类型的插件： 是的，Chrome允许插件在开发者工具(devtools)上动手脚，主要表现在： 自定义一个和多个和Elements、Console、Sources等同级别的面板； 自定义侧边栏(sidebar)，目前只能自定义Elements面板的侧边栏； 先来看2张简单的demo截图，自定义面板（判断当前页面是否使用了jQuery）： 自定义侧边栏（获取当前页面所有图片）： 5.5.2. devtools扩展介绍 主页：https://developer.chrome.com/extensions/devtools 来一张官方图片： 每打开一个开发者工具窗口，都会创建devtools页面的实例，F12窗口关闭，页面也随着关闭，所以devtools页面的生命周期和devtools窗口是一致的。devtools页面可以访问一组特有的DevTools API以及有限的扩展API，这组特有的DevTools API只有devtools页面才可以访问，background都无权访问，这些API包括： chrome.devtools.panels：面板相关； chrome.devtools.inspectedWindow：获取被审查窗口的有关信息； chrome.devtools.network：获取有关网络请求的信息； 大部分扩展API都无法直接被DevTools页面调用，但它可以像content-script一样直接调用chrome.extension和chrome.runtimeAPI，同时它也可以像content-script一样使用Message交互的方式与background页面进行通信。 5.5.3. 实例：创建一个devtools扩展 首先，要针对开发者工具开发插件，需要在清单文件声明如下： { // 只能指向一个HTML文件，不能是JS文件 "devtools_page": "devtools.html" } 这个devtools.html里面一般什么都没有，就引入一个js： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript" src="js/devtools.js"&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 可以看出来，其实真正代码是devtools.js，html文件是“多余”的，所以这里觉得有点坑，devtools_page干嘛不允许直接指定JS呢？ 再来看devtools.js的代码： // 创建自定义面板，同一个插件可以创建多个自定义面板 // 几个参数依次为：panel标题、图标（其实设置了也没地方显示）、要加载的页面、加载成功后的回调 chrome.devtools.panels.create('MyPanel', 'img/icon.png', 'mypanel.html', function(panel) { console.log('自定义面板创建成功！'); // 注意这个log一般看不到 }); // 创建自定义侧边栏 chrome.devtools.panels.elements.createSidebarPane("Images", function(sidebar) { // sidebar.setPage('../sidebar.html'); // 指定加载某个页面 sidebar.setExpression('document.querySelectorAll("img")', 'All Images'); // 通过表达式来指定 //sidebar.setObject({aaa: 111, bbb: 'Hello World!'}); // 直接设置显示某个对象 }); setPage时的效果： 以下截图示例的代码： // 检测jQuery document.getElementById('check_jquery').addEventListener('click', function() { // 访问被检查的页面DOM需要使用inspectedWindow // 简单例子：检测被检查页面是否使用了jQuery chrome.devtools.inspectedWindow.eval("jQuery.fn.jquery", function(result, isException) { var html = ''; if (isException) html = '当前页面没有使用jQuery。'; else html = '当前页面使用了jQuery，版本为：'+result; alert(html); }); }); // 打开某个资源 document.getElementById('open_resource').addEventListener('click', function() { chrome.devtools.inspectedWindow.eval("window.location.href", function(result, isException) { chrome.devtools.panels.openResource(result, 20, function() { console.log('资源打开成功！'); }); }); }); // 审查元素 document.getElementById('test_inspect').addEventListener('click', function() { chrome.devtools.inspectedWindow.eval("inspect(document.images[0])", function(result, isException){}); }); // 获取所有资源 document.getElementById('get_all_resources').addEventListener('click', function() { chrome.devtools.inspectedWindow.getResources(function(resources) { alert(JSON.stringify(resources)); }); }); 5.5.4. 调试技巧 修改了devtools页面的代码时，需要先在 chrome://extensions 页面按下Ctrl+R重新加载插件，然后关闭再打开开发者工具即可，无需刷新页面（而且只刷新页面不刷新开发者工具的话是不会生效的）。 由于devtools本身就是开发者工具页面，所以几乎没有方法可以直接调试它，直接用 chrome-extension://extid/devtools.html"的方式打开页面肯定报错，因为不支持相关特殊API，只能先自己写一些方法屏蔽这些错误，调试通了再放开。 5.6. option(选项页) 所谓options页，就是插件的设置页面，有2个入口，一个是右键图标有一个“选项”菜单，还有一个在插件管理页面： 在Chrome40以前，options页面和其它普通页面没什么区别，Chrome40以后则有了一些变化。 我们先看老版的options： { // Chrome40以前的插件配置页写法 "options_page": "options.html", } 这个页面里面的内容就随你自己发挥了，配置之后在插件管理页就会看到一个选项按钮入口，点进去就是打开一个网页，没啥好讲的。 效果: 再来看新版的optionsV2： { "options_ui": { "page": "options.html", // 添加一些默认的样式，推荐使用 "chrome_style": true }, } options.html的代码我们没有任何改动，只是配置文件改了，之后效果如下： 看起来是不是高大上了？ 几点注意： 为了兼容，建议2种都写，如果都写了，Chrome40以后会默认读取新版的方式； 新版options中不能使用alert； 数据存储建议用chrome.storage，因为会随用户自动同步； 5.7. omnibox omnibox是向用户提供搜索建议的一种方式。先来看个gif图以便了解一下这东西到底是个什么鬼： 注册某个关键字以触发插件自己的搜索建议界面，然后可以任意发挥了。 首先，配置文件如下： { // 向地址栏注册一个关键字以提供搜索建议，只能设置一个关键字 "omnibox": { "keyword" : "go" }, } 然后background.js中注册监听事件： // omnibox 演示 chrome.omnibox.onInputChanged.addListener((text, suggest) =&gt; { console.log('inputChanged: ' + text); if(!text) return; if(text == '美女') { suggest([ {content: '中国' + text, description: '你要找“中国美女”吗？'}, {content: '日本' + text, description: '你要找“日本美女”吗？'}, {content: '泰国' + text, description: '你要找“泰国美女或人妖”吗？'}, {content: '韩国' + text, description: '你要找“韩国美女”吗？'} ]); } else if(text == '微博') { suggest([ {content: '新浪' + text, description: '新浪' + text}, {content: '腾讯' + text, description: '腾讯' + text}, {content: '搜狐' + text, description: '搜索' + text}, ]); } else { suggest([ {content: '百度搜索 ' + text, description: '百度搜索 ' + text}, {content: '谷歌搜索 ' + text, description: '谷歌搜索 ' + text}, ]); } }); // 当用户接收关键字建议时触发 chrome.omnibox.onInputEntered.addListener((text) =&gt; { console.log('inputEntered: ' + text); if(!text) return; var href = ''; if(text.endsWith('美女')) href = 'http://image.baidu.com/search/index?tn=baiduimage&amp;ie=utf-8&amp;word=' + text; else if(text.startsWith('百度搜索')) href = 'https://www.baidu.com/s?ie=UTF-8&amp;wd=' + text.replace('百度搜索 ', ''); else if(text.startsWith('谷歌搜索')) href = 'https://www.google.com.tw/search?q=' + text.replace('谷歌搜索 ', ''); else href = 'https://www.baidu.com/s?ie=UTF-8&amp;wd=' + text; openUrlCurrentTab(href); }); // 获取当前选项卡ID function getCurrentTabId(callback) { chrome.tabs.query({active: true, currentWindow: true}, function(tabs) { if(callback) callback(tabs.length ? tabs[0].id: null); }); } // 当前标签打开某个链接 function openUrlCurrentTab(url) { getCurrentTabId(tabId =&gt; { chrome.tabs.update(tabId, {url: url}); }) } 5.8. 桌面通知 Chrome提供了一个chrome.notificationsAPI以便插件推送桌面通知，暂未找到chrome.notifications和HTML5自带的Notification的显著区别及优势。 在后台JS中，无论是使用chrome.notifications还是Notification都不需要申请权限（HTML5方式需要申请权限），直接使用即可。 最简单的通知： 代码： chrome.notifications.create(null, { type: 'basic', iconUrl: 'img/icon.png', title: '这是标题', message: '您刚才点击了自定义右键菜单！' }); 通知的样式可以很丰富： 这个没有深入研究，有需要的可以去看官方文档。 5种类型的JS对比 Chrome插件的JS主要可以分为这5类：injected script、content-script、popup js、background js和devtools js， 6.1. 权限对比 {% raw %} JS种类 可访问的API DOM访问情况 JS访问情况 直接跨域 injected script 和普通JS无任何差别，不能访问任何扩展API 可以访问 可以访问 不可以 content script 只能访问 extension、runtime等部分API 可以访问 不可以 不可以 popup js 可访问绝大部分API，除了devtools系列 不可直接访问 不可以 可以 background js 可访问绝大部分API，除了devtools系列 不可直接访问 不可以 可以 devtools js 只能访问 devtools、extension、runtime等部分API 可以 可以 不可以 6.2. 调试方式对比 JS类型 调试方式 图片说明 injected script 直接普通的F12即可 懒得截图 content-script 打开Console,如图切换 popup-js popup页面右键审查元素 background 插件管理页点击背景页即可 devtools-js 暂未找到有效方法 - {% endraw %} 消息通信 通信主页：https://developer.chrome.com/extensions/messaging 前面我们介绍了Chrome插件中存在的5种JS，那么它们之间如何互相通信呢？下面先来系统概况一下，然后再分类细说。需要知道的是，popup和background其实几乎可以视为一种东西，因为它们可访问的API都一样、通信机制一样、都可以跨域。 7.1. 互相通信概览 注：-表示不存在或者无意义，或者待验证。 injected-script content-script popup-js background-js injected-script - window.postMessage - - content-script window.postMessage - chrome.runtime.sendMessage chrome.runtime.connect chrome.runtime.sendMessage chrome.runtime.connect popup-js - chrome.tabs.sendMessage chrome.tabs.connect - chrome.extension. getBackgroundPage() background-js - chrome.tabs.sendMessage chrome.tabs.connect chrome.extension.getViews - devtools-js chrome.devtools. inspectedWindow.eval - chrome.runtime.sendMessage chrome.runtime.sendMessage 7.2. 通信详细介绍 7.2.1. popup和background popup可以直接调用background中的JS方法，也可以直接访问background的DOM： // background.jsfunction test(){ alert(‘我是background！’);} // popup.jsvar bg = chrome.extension.getBackgroundPage();bg.test(); // 访问bg的函数alert(bg.document.body.innerHTML); // 访问bg的DOM 小插曲，今天碰到一个情况，发现popup无法获取background的任何方法，找了半天才发现是因为background的js报错了，而你如果不主动查看background的js的话，是看不到错误信息的，特此提醒。 至于background访问popup如下（前提是popup已经打开）： var views = chrome.extension.getViews({type:‘popup’});if(views.length &gt; 0) { console.log(views[0].location.href);} 7.2.2. popup或者bg向content主动发送消息 background.js或者popup.js： function sendMessageToContentScript(message, callback){ chrome.tabs.query({active: true, currentWindow: true}, function(tabs) { chrome.tabs.sendMessage(tabs[0].id, message, function(response) { if(callback) callback(response); }); });}sendMessageToContentScript({cmd:‘test’, value:‘你好，我是popup！’}, function(response){ console.log(‘来自content的回复：’+response);}); content-script.js接收： chrome.runtime.onMessage.addListener(function(request, sender, sendResponse){ // console.log(sender.tab ?”from a content script:” + sender.tab.url :”from the extension”); if(request.cmd == ‘test’) alert(request.value); sendResponse(‘我收到了你的消息！’);}); 双方通信直接发送的都是JSON对象，不是JSON字符串，所以无需解析，很方便（当然也可以直接发送字符串）。 网上有些老代码中用的是chrome.extension.onMessage，没有完全查清二者的区别(貌似是别名)，但是建议统一使用chrome.runtime.onMessage。 7.2.3. content-script主动发消息给后台 content-script.js： chrome.runtime.sendMessage({greeting: ‘你好，我是content-script呀，我主动发消息给后台！’}, function(response) { console.log(‘收到来自后台的回复：’ + response);}); background.js 或者 popup.js： // 监听来自content-script的消息chrome.runtime.onMessage.addListener(function(request, sender, sendResponse){ console.log(‘收到来自content-script的消息：’); console.log(request, sender, sendResponse); sendResponse(‘我是后台，我已收到你的消息：’ + JSON.stringify(request));}); 注意事项： content_scripts向popup主动发消息的前提是popup必须打开！否则需要利用background作中转； 如果background和popup同时监听，那么它们都可以同时收到消息，但是只有一个可以sendResponse，一个先发送了，那么另外一个再发送就无效； 7.2.4. injected script和content-script content-script和页面内的脚本（injected-script自然也属于页面内的脚本）之间唯一共享的东西就是页面的DOM元素，有2种方法可以实现二者通讯： 可以通过window.postMessage和window.addEventListener来实现二者消息通讯； 通过自定义DOM事件来实现； 第一种方法（推荐）： injected-script中： window.postMessage({“test”: ‘你好！’}, ‘*’); content script中： window.addEventListener(“message”, function(e){ console.log(e.data);}, false); 第二种方法： injected-script中： var customEvent = document.createEvent(‘Event’);customEvent.initEvent(‘myCustomEvent’, true, true);function fireCustomEvent(data) { hiddenDiv = document.getElementById(‘myCustomEventDiv’); hiddenDiv.innerText = data hiddenDiv.dispatchEvent(customEvent);}fireCustomEvent(‘你好，我是普通JS！’); content-script.js中： var hiddenDiv = document.getElementById(‘myCustomEventDiv’);if(!hiddenDiv) { hiddenDiv = document.createElement(‘div’); hiddenDiv.style.display = ‘none’; document.body.appendChild(hiddenDiv);}hiddenDiv.addEventListener(‘myCustomEvent’, function() { var eventData = document.getElementById(‘myCustomEventDiv’).innerText; console.log(‘收到自定义事件消息：’ + eventData);}); 7.3. 长连接和短连接 其实上面已经涉及到了，这里再单独说明一下。Chrome插件中有2种通信方式，一个是短连接（chrome.tabs.sendMessage和chrome.runtime.sendMessage），一个是长连接（chrome.tabs.connect和chrome.runtime.connect）。 短连接的话就是挤牙膏一样，我发送一下，你收到了再回复一下，如果对方不回复，你只能重新发，而长连接类似WebSocket会一直建立连接，双方可以随时互发消息。 短连接上面已经有代码示例了，这里只讲一下长连接。 popup.js： getCurrentTabId((tabId) =&gt; { var port = chrome.tabs.connect(tabId, {name: ‘test-connect’}); port.postMessage({question: ‘你是谁啊？’}); port.onMessage.addListener(function(msg) { alert(‘收到消息：’+msg.answer); if(msg.answer &amp;&amp; msg.answer.startsWith(‘我是’)) { port.postMessage({question: ‘哦，原来是你啊！’}); } });}); content-script.js： // 监听长连接chrome.runtime.onConnect.addListener(function(port) { console.log(port); if(port.name == ‘test-connect’) { port.onMessage.addListener(function(msg) { console.log(‘收到长连接消息：’, msg); if(msg.question == ‘你是谁啊？’) port.postMessage({answer: ‘我是你爸！’}); }); }}); 其它补充 8.1. 动态注入或执行JS 虽然在background和popup中无法直接访问页面DOM，但是可以通过chrome.tabs.executeScript来执行脚本，从而实现访问web页面的DOM（注意，这种方式也不能直接访问页面JS）。 示例manifest.json配置： { “name”: “动态JS注入演示”, … “permissions”: [ “tabs”, “http:///“, “https:///“ ], …} JS： // 动态执行JS代码chrome.tabs.executeScript(tabId, {code: ‘document.body.style.backgroundColor=”red”‘});// 动态执行JS文件chrome.tabs.executeScript(tabId, {file: ‘some-script.js’}); 8.2. 动态注入CSS 示例manifest.json配置： { “name”: “动态CSS注入演示”, … “permissions”: [ “tabs”, “http:///“, “https:///“ ], …} JS代码： // 动态执行CSS代码，TODO，这里有待验证chrome.tabs.insertCSS(tabId, {code: ‘xxx’});// 动态执行CSS文件chrome.tabs.insertCSS(tabId, {file: ‘some-style.css’}); 8.3. 获取当前窗口ID chrome.windows.getCurrent(function(currentWindow){ console.log(‘当前窗口ID：’ + currentWindow.id);}); 8.4. 获取当前标签页ID 一般有2种方法： // 获取当前选项卡IDfunction getCurrentTabId(callback){ chrome.tabs.query({active: true, currentWindow: true}, function(tabs) { if(callback) callback(tabs.length ? tabs[0].id: null); });} 获取当前选项卡id的另一种方法，大部分时候都类似，只有少部分时候会不一样（例如当窗口最小化时） // 获取当前选项卡IDfunction getCurrentTabId2(){ chrome.windows.getCurrent(function(currentWindow) { chrome.tabs.query({active: true, windowId: currentWindow.id}, function(tabs) { if(callback) callback(tabs.length ? tabs[0].id: null); }); });} 8.5. 本地存储 本地存储建议用chrome.storage而不是普通的localStorage，区别有好几点，个人认为最重要的2点区别是： chrome.storage是针对插件全局的，即使你在background中保存的数据，在content-script也能获取到； chrome.storage.sync可以跟随当前登录用户自动同步，这台电脑修改的设置会自动同步到其它电脑，很方便，如果没有登录或者未联网则先保存到本地，等登录了再同步至网络； 需要声明storage权限，有chrome.storage.sync和chrome.storage.local2种方式可供选择，使用示例如下： // 读取数据，第一个参数是指定要读取的key以及设置默认值chrome.storage.sync.get({color: ‘red’, age: 18}, function(items) { console.log(items.color, items.age);});// 保存数据chrome.storage.sync.set({color: ‘blue’}, function() { console.log(‘保存成功！’);}); 8.6. webRequest 通过webRequest系列API可以对HTTP请求进行任性地修改、定制，这里通过beforeRequest来简单演示一下它的冰山一角： //manifest.json{ // 权限申请 “permissions”: [ “webRequest”, // web请求 “webRequestBlocking”, // 阻塞式web请求 “storage”, // 插件本地存储 “http:///“, // 可以通过executeScript或者insertCSS访问的网站 “https:///“ // 可以通过executeScript或者insertCSS访问的网站 ],} // background.js// 是否显示图片var showImage;chrome.storage.sync.get({showImage: true}, function(items) { showImage = items.showImage;});// web请求监听，最后一个参数表示阻塞式，需单独声明权限：webRequestBlockingchrome.webRequest.onBeforeRequest.addListener(details =&gt; { // cancel 表示取消本次请求 if(!showImage &amp;&amp; details.type == ‘image’) return {cancel: true}; // 简单的音视频检测 // 大部分网站视频的type并不是media，且视频做了防下载处理，所以这里仅仅是为了演示效果，无实际意义 if(details.type == ‘media’) { chrome.notifications.create(null, { type: ‘basic’, iconUrl: ‘img/icon.png’, title: ‘检测到音视频’, message: ‘音视频地址：’ + details.url, }); }}, {urls: [“&lt;all_urls&gt;”]}, [“blocking”]); 8.7. 国际化 插件根目录新建一个名为_locales的文件夹，再在下面新建一些语言的文件夹，如en、zh_CN、zh_TW，然后再在每个文件夹放入一个messages.json，同时必须在清单文件中设置default_locale。 _locales\en\messages.json内容： { “pluginDesc”: {“message”: “A simple chrome extension demo”}, “helloWorld”: {“message”: “Hello World!”}} _locales\zh_CN\messages.json内容： { “pluginDesc”: {“message”: “一个简单的Chrome插件demo”}, “helloWorld”: {“message”: “你好啊，世界！”}} 在manifest.json和CSS文件中通过MSG_messagename引入，如： { “description”: “MSG_pluginDesc“, // 默认语言 “default_locale”: “zh_CN”,} JS中则直接chrome.i18n.getMessage(“helloWorld”)。 测试时，通过给chrome建立一个不同的快捷方式chrome.exe –lang=en来切换语言，如： 英文效果： 中文效果： 8.8. API总结 比较常用用的一些API系列： chrome.tabs chrome.runtime chrome.webRequest chrome.window chrome.storage chrome.contextMenus chrome.devtools chrome.extension 经验总结 9.1. 查看已安装插件路径 已安装的插件源码路径：C:\Users\用户名\AppData\Local\Google\Chrome\User Data\Default\Extensions，每一个插件被放在以插件ID为名的文件夹里面，想要学习某个插件的某个功能是如何实现的，看人家的源码是最好的方法了： 如何查看某个插件的ID？进入 chrome://extensions ，然后勾线开发者模式即可看到了。 9.2. 特别注意background的报错 很多时候你发现你的代码会莫名其妙的失效，找来找去又找不到原因，这时打开background的控制台才发现原来某个地方写错了导致代码没生效，正式由于background报错的隐蔽性(需要主动打开对应的控制台才能看到错误)，所以特别注意这点。 9.3. 如何让popup页面不关闭 在对popup页面审查元素的时候popup会被强制打开无法关闭，只有控制台关闭了才可以关闭popup，原因很简单：如果popup关闭了控制台就没用了。这种方法在某些情况下很实用！ 9.4. 不支持内联JavaScript的执行 也就是不支持将js直接写在html中，比如： &lt;input id=“btn” type=“button” value=“收藏” onclick=“test()”/&gt; 报错如下： Refused to execute inline event handler because it violates the following Content Security Policy directive: “script-src ‘self’ blob: filesystem: chrome-extension-resource:”. Either the ‘unsafe-inline’ keyword, a hash (‘sha256-…’), or a nonce (‘nonce-…’) is required to enable inline execution. 解决方法就是用JS绑定事件： $(‘#btn’).on(‘click’, function(){alert(‘测试’)}); 另外，对于A标签，这样写href=”javascript:;”然后用JS绑定事件虽然控制台会报错，但是不受影响，当然强迫症患者受不了的话只能写成href=”#”了。 如果这样写： &lt;a href=“javascript:;” id=“get_secret”&gt;请求secret&lt;/a&gt; 报错如下： Refused to execute JavaScript URL because it violates the following Content Security Policy directive: “script-src ‘self’ blob: filesystem: chrome-extension-resource:”. Either the ‘unsafe-inline’ keyword, a hash (‘sha256-…’), or a nonce (‘nonce-…’) is required to enable inline execution. 9.5. 注入CSS的时候必须小心 由于通过content_scripts注入的CSS优先级非常高，几乎仅次于浏览器默认样式，稍不注意可能就会影响一些网站的展示效果，所以尽量不要写一些影响全局的样式。 之所以强调这个，是因为这个带来的问题非常隐蔽，不太容易找到，可能你正在写某个网页，昨天样式还是好好的，怎么今天就突然不行了？然后你辛辛苦苦找来找去，找了半天才发现竟然是因为插件里面的一个样式影响的！ 打包与发布 打包的话直接在插件管理页有一个打包按钮： 然后会生成一个.crx文件，要发布到Google应用商店的话需要先登录你的Google账号，然后花5个$注册为开发者，本人太穷，就懒得亲自验证了，有发布需求的自己去整吧。 参考 11.1. 官方资料 推荐查看官方文档，虽然是英文，但是全且新，国内的中文资料都比较旧（注意以下全部需要FQ）： Chrome插件官方文档主页 Chrome插件官方示例 manifest清单文件 permissions权限 chrome.xxx.api文档 模糊匹配规则语法详解 11.2. 第三方资料 部分中文资料，不是特别推荐： 360安全浏览器开发文档 360极速浏览器Chrome扩展开发文档 Chrome扩展开发极客系列博客 附图 附图：Chrome高清png格式logo：个人网站：https://haoji.megithub：https://github.com/sxei博客园：http://www.cnblogs.com/liuxianancopyright ©2012-2018 小茗同学 【转载文章务必保留出处和署名，谢谢！】文章来源： 【干货】Chrome插件(扩展)开发全攻略]]></content>
  </entry>
  <entry>
    <title><![CDATA[jQuery动画做一个折叠菜单]]></title>
    <url>%2F2019%2F05%2F14%2FjQuery%E5%8A%A8%E7%94%BB%E5%81%9A%E4%B8%80%E4%B8%AA%E6%8A%98%E5%8F%A0%E8%8F%9C%E5%8D%95%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前面利用了jQuery动画做了一个对联广告，这次再次利用jQuery的其他动画做一个折叠菜单，做出一个较为美观的折叠菜单。直接上代码： css部分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;style&gt; * &#123; margin: 0; padding: 0; list-style: none; &#125; .l1&#123; width: 400px; margin: 0 auto; margin-top: 10px; &#125; .l1&gt;li&#123; /* border: 1px solid #000; border-collapse: collapse!important; */ outline: 1px solid black; font-size: 20px; /* height: 40px; line-height: 40px; */ &#125; .l1&gt;li&gt;div&#123; outline: 1px solid black; border-top: 1px solid #000; position: relative; &#125; .l1&gt;li&gt;div&gt;span&#123; display: inline-block; position: absolute; right: 10px; &#125; .l2&#123; display: none; &#125; .l2&gt;li&#123; /* outline: 1px solid black; */ /* border: 1px solid #000; */ border-collapse: collapse!important; font-size: 16px; height: 40px; line-height: 40px; &#125; .trans&#123; transform: rotate(90deg); -ms-transform: rotate(90deg); /* IE 9 */ -webkit-transform: rotate(90deg); /* Safari and Chrome */ -o-transform: rotate(90deg); /* Opera */ -moz-transform: rotate(90deg); /* Firefox */ &#125;&lt;/style&gt; html部分 12345678910111213141516171819202122232425262728293031323334353637383940&lt;body&gt; &lt;ul class="l1"&gt; &lt;li&gt; &lt;div&gt;一级菜单&lt;span&gt;&gt;&lt;/span&gt;&lt;/div&gt; &lt;ul class="l2"&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;div&gt;一级菜单&lt;span&gt;&gt;&lt;/span&gt;&lt;/div&gt; &lt;ul class="l2"&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;div&gt;一级菜单&lt;span&gt;&gt;&lt;/span&gt;&lt;/div&gt; &lt;ul class="l2"&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;div&gt;一级菜单&lt;span&gt;&gt;&lt;/span&gt;&lt;/div&gt; &lt;ul class="l2"&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/body&gt; js部分 12345678910111213141516&lt;script&gt; var index=1; $(function()&#123; $('.l1&gt;li&gt;div').click(function()&#123; index++; // 因为动画队列的存在，所以在执行新的动画之前要停止之前的动画 $(this).next().stop().slideToggle(); if(index%2==0)&#123; $(this).children().addClass('trans'); &#125; else&#123; $(this).children().removeClass('trans'); &#125; &#125;) &#125;) &lt;/script&gt; 效果图： 总结 要注意要找对执行动画的元素，可以用next(),chidren()等方法来找。 要注意动画队列，当我们快速多次的触发动画的时候，每触发一次就会加入动画队列，并且按照顺序会全部执行完毕，如果在执行新的动画之前我们不先停止之前的动画，那么就不会立即执行我们想要的动画，并且在我们不触发动画之后很有可能还会有很长一段的动画要执行。]]></content>
  </entry>
  <entry>
    <title><![CDATA[jQuery动画之写一个对联广告]]></title>
    <url>%2F2019%2F05%2F14%2FjQuery%E5%86%99%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%81%94%E5%B9%BF%E5%91%8A%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jQuery自带了许多动画效果，我们可以利用这些动画效果比较方便的做出一个对联广告。直接上代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;style&gt; body &#123; margin: 0; padding: 0; height: 2000px; &#125; .left, .right &#123; width: 80px; height: 200px; background: red; position: fixed; top: 260px; &#125; .right &#123; right: 0px; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class="left"&gt; &lt;/div&gt; &lt;div class="right"&gt; &lt;/div&gt; &lt;script&gt; $(function () &#123; $('.left,.right').hide(); // 在网页往下滚动之前先隐藏 var $height = $('body,html').scrollTop(); $(window).scroll(function () &#123; // 这里用到了scroll事件来监听网页的滚动 // 通过scrollTop方法来获取滚动的值 $height = $('body,html').scrollTop(); // 如果大于500就通过动画显示出来，否则隐藏 if ($height &gt;= 500) &#123; $('.left,.right').show(1000); &#125; else &#123; $('.left,.right').hide(1000); &#125; &#125;) &#125;) &lt;/script&gt;&lt;/body&gt; 总结： 这里一定要用到scroll事件，否则无法动态获取到滚动了多少 在使用scrollTop方法获取网页的滚动的值时一定要这样写$(&#39;body,html&#39;).scrollTop();既要写body，也要写html，兼容处理，如果只写一个可能会获取到不正确的值]]></content>
  </entry>
  <entry>
    <title><![CDATA[jQuery写一个简单的选项卡]]></title>
    <url>%2F2019%2F05%2F14%2FjQuery%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E9%80%89%E9%A1%B9%E5%8D%A1%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这次通过jQuery的方法来写一个小小的选项卡功能，通过jQuery实现起来也是十分的简单。直接上代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;style&gt; * &#123; margin: 0; padding: 0; list-style: none; &#125; div &#123; border: 1px solid #000; width: 800px; height: 400px; margin: 0 auto; position: relative; &#125; .ch &#123; top: 320px; left: 650px; position: absolute; &#125; .ch&gt;li &#123; display: inline-block; width: 20px; height: 20px; background-color: #ccc; margin-right: 10px; &#125; img &#123; width: 100%; height: 400px; display: none; &#125; .current &#123; display: block; background-color: red !important; &#125;&lt;/style&gt;&lt;body&gt; &lt;div&gt; &lt;ul class="imgs"&gt; &lt;li&gt;&lt;img class="current" src="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2489492398,1961915359&amp;fm=26&amp;gp=0.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1287814793,457485829&amp;fm=26&amp;gp=0.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1501075685,574908757&amp;fm=11&amp;gp=0.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=3662540589,314327097&amp;fm=11&amp;gp=0.jpg" alt=""&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ul class="ch"&gt; &lt;li class="current"&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; $(function () &#123; $('.ch&gt;li').mouseenter(function () &#123; $(this).addClass('current').siblings().removeClass('current'); // 给当前操作的小方块添加样式，其他的兄弟小方块去除样式 var index = $(this).index(); // 获取当前是第几个小方块，用来确定是第几张图片 $('.imgs&gt;li&gt;img').eq(index).addClass('current').parent().siblings().children() .removeClass('current'); // 给对应的图片添加样式，其他的图片删除样式 &#125;) &#125;) &lt;/script&gt;&lt;/body&gt; 效果图： 总结 写这个选项卡思路很简单，但是在布局的时候没有考虑好导致在给img标签删除样式的时候会比较麻烦，需要先找到父级li，然后找到他的兄弟，再找到他们的儿子，下次要注意避免出现这种情况。]]></content>
  </entry>
  <entry>
    <title><![CDATA[jQuery学习（事件处理）]]></title>
    <url>%2F2019%2F05%2F14%2FjQuery%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jQuery中也有许多事件处理的函数，功能强大，使用起来也比原声js要更加的简单和方便，这次学习以下jQuery的事件处理函数与冒泡行为以及自定义事件等等，以及动手实践，编写实例。 事件绑定jQuery中事件绑定有两种方式 eventName(function(){}) 绑定对应事件名的监听, 例如：$(‘#div’).click(function(){});优缺点：编写方便，但是不支持所有事件与自定义事件，但常用的事件基本上都是支持的。 on(eventName, funcion(){}) 通用的绑定事件监听, 例如：$(‘#div’).on(‘click’, function(){});优缺点：支持所有事件，但是编码的时候事件名要自己敲，但是最强大，支持所有事件与自定义事件。 事件解绑 jQuery中可以通过off(eventName,function);解绑事件 获取事件坐标当事件被触发时,系统会将事件对象(event)传递给回调函数,通过event对象我们就能获取时间的坐标，获取坐标有三种方式： event.offsetX, event.offsetY 相对于事件元素左上角 event.pageX, event.pageY 相对于页面的左上角 event.clientX, event.clientY 相对于视口的左上角 实例示例代码123456789101112131415161718192021222324252627&lt;style&gt;button&#123; margin-top: 600px;&#125;&lt;/style&gt;&lt;body&gt; &lt;button&gt;这是按钮一&lt;/button&gt; &lt;button&gt;这是按钮二&lt;/button&gt; &lt;button&gt;这是按钮三&lt;/button&gt; &lt;button&gt;这是按钮四&lt;/button&gt; &lt;script&gt; $(function()&#123; $('button').eq(0).click(function(Event)&#123; alert(Event.offsetY); // 结果：10 &#125;) $('button').eq(1).click(function(Event)&#123; alert(Event.pageY); // 结果：626 &#125;) $('button').eq(2).click(function(Event)&#123; alert(Event.clientY); // 结果：630 &#125;) &#125;) &lt;/script&gt;&lt;/body&gt; 阻止事件冒泡 什么是事件冒泡·事件冒泡就是同属说就是事件从里往外的一个触发过程1234567891011121314151617181920212223242526272829303132&lt;style&gt; .father &#123; width: 400px; height: 400px; background-color: red; &#125; .son &#123; width: 200px; height: 200px; background-color: blue; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class="father"&gt; 这是爸爸 &lt;div class="son"&gt; 这是儿子 &lt;/div&gt; &lt;/div&gt; &lt;script&gt; $(function () &#123; $('.father').click(function()&#123; alert('这是爸爸'); &#125;) $('.son').click(function()&#123; alert('这是儿子'); &#125;) &#125;) &lt;/script&gt;&lt;/body&gt; 当我单击了儿子之后，由于事件冒泡，事件会由里往外触发，所以先弹出儿子，再弹出爸爸，很多时候这都不是我们想要的结果，我们通常只是需要触发儿子的事件，所以这个时候我们就需要阻止事件冒泡。 如何阻止事件冒泡?event.stopPropagation()1234567891011$(function () &#123; $('.father').click(function()&#123; alert('这是爸爸'); &#125;) &lt;!-- 传递了事件对象 --&gt; $('.son').click(function(event)&#123; event.stopPropagation(); &lt;!-- 组阻止了事件冒泡 --&gt; alert('这是儿子'); &#125;) &#125;) 此时我们再次单击儿子就会发现就只弹出了儿子的单击事件，并没有触发父亲的事件，就达到了我们的效果 阻止默认行为 什么是默认行为·就是一些元素默认自带的行为，比如单击超链接会自动跳转等等。 如何阻止默认行为event.preventDefault()123456789&lt;a href="www.baidu.com"&gt;这是一个跳转到百度的超链接&lt;/a&gt;&lt;script&gt;$(function()&#123; $('a').click(function(event)&#123; event.preventDefault(); // 此时单击超链接时就不会进行跳转了 &#125;)&#125;)&lt;/script&gt; 自动触发事件 什么是自动触发事件?·通过代码控制事件, 不用人为点击/移入/移除等事件就能被触发 自动触发事件方式$(“selector”).trigger(“eventName”);触发事件的同时会触发事件冒泡触发事件的同时会触发事件默认行为$(“selector”).triggerHandler(“eventName”);触发事件的同时不会触发事件冒泡触发事件的同时不会触发事件默认行为 以triggerHandler()为例：12345678910111213&lt;body&gt; &lt;button&gt;这是一个按钮&lt;/button&gt; &lt;script&gt; $(function()&#123; $('button').eq(0).click(function()&#123; alert('我单击了按钮'); // 原本要单击才会弹出内容 &#125;) $('button').triggerHandler('click'); // 现在在网页出现后就会弹出 &#125;) &lt;/script&gt;&lt;/body&gt; 事件命名空间我们都知道jQuery可以给同一元素绑定多个相同的事件，且都能够触发，那么在多人开发中就可能会遇到多人对同意元素操作的情况，那么为了方便管理与区分，我们就可以在注册事件的时候使用命名空间 格式：eventName.命名空间，如 click.hsl() 添加事件命名空间的前提条件1、事件是通过on来绑定的，也就是这种方法on(eventName, funcion(){})2、通过trigger触发事件 注意点(面试题):·不带命名空间事件被trigger调用,会触发带命名空间事件·带命名空间事件被trigger调用,只会触发带命名空间事件·下级不带命名空间事件被trigger调用,会冒泡触发上级不带命名空间和带命名空间事件·下级带命名空间事件被trigger调用,不会触发上级不带命名空间事件·下级带命名空间事件被trigger调用,会触发上级带命名空间事件 自定义事件 什么是自定义事件？自定义事件，可以自己定义事件的名称，然后通过这个名称还能触发相应的功能 自定义事件的前提1、事件是通过on来绑定的，也就是这种方法on(eventName, funcion(){})2、通过trigger触发事件例如：12345678910111213&lt;body&gt; &lt;button&gt;这是一个按钮&lt;/button&gt; &lt;script&gt; $(function()&#123; $('button').on('hsl',function()&#123; alert('这是一个自定义事件！'); // 自定义了一个名为hsl的事件 &#125;) $('button').triggerHandler('hsl'); // 通过trigger来触发 &#125;) &lt;/script&gt;&lt;/body&gt; 事件委托 事件委托的原理&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;事件委托是通过冒泡机制来实现的，例如有一个父元素，里面有许多子元素，我们无需给这众多的子元素都添加单击事件，我们只需给父级元素添加一个单击事件，那么我们在单击子元素的时候，就会网上冒泡，执行父元素的事件，就相当于是委托父级元素来执行一样。 事件委托的好处&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;减少监听数量：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能，因为需要不断的与dom节点进行交互，访问dom的次数越多，引起浏览器重绘与重排的次数也就越多，就会延长整个页面的交互就绪时间每个监听的函数都是一个对象，是对象就会占用内存，对象越多，内存占用率就越大，自然性能就越差… …&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;新增元素自动有事件响应处理：默认的情况下新增元素是无法相应增添前就有的事件。就可以通过冒泡到原本就有的父级元素来触发事件。 jQuery中如何添加事件委托：delegate(selector,[type],[data],fn)下面看一个例子： 1234567891011121314151617181920&lt;body&gt; &lt;ul class="father"&gt; &lt;li class="son"&gt;这是内容&lt;/li&gt; &lt;li class="son"&gt;这是内容&lt;/li&gt; &lt;li class="son"&gt;这是内容&lt;/li&gt; &lt;/ul&gt; &lt;button&gt;增加li&lt;/button&gt; &lt;script&gt; $(function()&#123; $('.son').click(function()&#123; alert('我是原本就有的li'); // 单击li时应该会有弹窗 &#125;) $('button').click(function()&#123; $('.father').append('&lt;li&gt;我是新增的li&lt;/li&gt;') // 单击新增li &#125;) &#125;) &lt;/script&gt;&lt;/body&gt; 运行以上代码，我们可以发现一个问题，单击原有的li时会有弹窗，但是单击后面新创建的li时却并没有弹窗，因为我们没有给后面创建的li添加单击事件。 此时我们使用事件委托就可以解决问题：123456789101112131415161718192021222324&lt;body&gt; &lt;ul class="father"&gt; &lt;li class="son"&gt;这是内容&lt;/li&gt; &lt;li class="son"&gt;这是内容&lt;/li&gt; &lt;li class="son"&gt;这是内容&lt;/li&gt; &lt;/ul&gt; &lt;button&gt;增加li&lt;/button&gt; &lt;script&gt; $(function()&#123; // $('.son').click(function()&#123; // alert('我是原本就有的li'); // &#125;) // 原本的单击事件也可以不需要了 $('button').click(function()&#123; $('.father').append('&lt;li&gt;我是新增的li&lt;/li&gt;') &#125;) // 通过事件委托，新添加的也能有弹窗 $('.father').delegate('li','click',function()&#123; alert('我是li'); &#125;) &#125;) &lt;/script&gt;&lt;/body&gt; 改用事件委托后，不管是新添加的还是本身就存在的li，都能成功的弹窗(原理是向上冒泡，所以要支持冒泡的事件才能有效果)]]></content>
  </entry>
  <entry>
    <title><![CDATA[jQuery实现轮播图]]></title>
    <url>%2F2019%2F05%2F13%2FjQuery%E5%AE%9E%E7%8E%B0%E8%BD%AE%E6%92%AD%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最近开始尝试着自己写轮播图，知道轮播图的原理，通过js顶死器不断的重复的给要轮播的图片添加和删除样式，在css样式中通过display中的 none 和block 来切换显示的图片，再加上过渡效果即可实现好看的轮播图，我准备用递归函数写，但是却不知道在哪出现了问题，能够实现第一轮的正常轮播，但是后面的轮播却会出现问题，不断的检查问题，还是没有找出问题，最后放弃用递归的写法，再参考别人的代码，成功实现了轮播图功能。直接放上代码: html部分：12345678910111213141516171819202122232425&lt;div class="lunbo"&gt; &lt;div class="imgs"&gt; &lt;!-- 两个左右切换的按钮 --&gt; &lt;span class="left"&gt;&lt;&lt;/span&gt; &lt;span class="right"&gt;&gt;&lt;/span&gt; &lt;!-- 需要轮播的六张图片 --&gt; &lt;ul&gt; &lt;li class="current"&gt;&lt;img src="img/a.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="img/b.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="img/c.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="img/d.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="img/e.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="img/f.jpg" alt=""&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;!-- 图片下面部分可以用来切换图片的圆点 --&gt; &lt;ul class="dot"&gt; &lt;li class="current"&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; html部分比较简单。 css部分1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980*&#123; margin: 0; padding: 0; list-style: none; text-decoration: none;&#125;.lunbo&#123; width: 100%; height:400px; position: relative;&#125;.lunbo img&#123; width: 100%; height: 450px; position: absolute; top: 0px;&#125;.left&#123; position: absolute; display: inline-block; font-weight: bolder; z-index: 99; left: 0px; width: 50px; height: 100px; line-height: 100px; background: #ccc;; top: 135px; font-size: 60px; text-align: center; opacity: 0.3;&#125;.right&#123; position: absolute; display: inline-block; font-weight: bolder; z-index: 99; right: 0px; width: 50px; height: 100px; line-height: 100px; background: #ccc;; top: 135px; font-size: 60px; text-align: center; opacity: 0.3;&#125;.imgs&gt;ul li&#123; /* 先设置所有的图片都不显示 */ display: none;&#125;.imgs .current&#123; /* 让第一张图片显示 */ display: block;&#125;.dot .current&#123; /* 通过给小圆点来添加current类来使其变为红点 */ background:red;&#125;.dot&#123; z-index: 99; position: absolute; top:300px; /* 可以使所有的小圆点整体居中 */ left: 50%; transform: translate(-50%, -50%);&#125;.dot li&#123; /* 小圆点的默认样式 */ background: white; width: 15px; height: 15px; border-radius:50%; display: inline-block; margin-right: 20px;&#125;.dot&gt;li:hover&#123; /* 使鼠标经过左右切换的按钮变为一只手 */ cursor: pointer;&#125; 很正常的css样式设置，很多地方还不是特别的熟练，不是完美，代码还有很多可以优化的地方。 js部分 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950$(function () &#123; var timer = null; var cur = 0; var len = $(".imgs&gt;ul li").length; // 右切换 $('.right').click(function chr() &#123; cur = $('.dot&gt;.current').index(); if (cur == 5) &#123; $(".imgs&gt;ul li").eq(0).fadeIn(400).siblings("li").fadeOut(400); $(".dot&gt;li").eq(0).addClass("current").siblings().removeClass("current"); &#125; $(".dot&gt;li").eq(cur + 1).addClass("current").siblings().removeClass("current"); $(".imgs&gt;ul li").eq(cur + 1).fadeIn(400).siblings("li").fadeOut(400); &#125;); // 左切换 $('.left').click(function chl() &#123; cur = $('.dot&gt;.current').index(); if (cur == 0) &#123; $(".imgs&gt;ul li").eq(5).fadeIn(400).siblings("li").fadeOut(400); $(".dot&gt;li").eq(5).addClass("current").siblings().removeClass("current"); &#125; $(".dot&gt;li").eq(cur - 1).addClass("current").siblings().removeClass("current"); $(".imgs&gt;ul li").eq(cur - 1).fadeIn(400).siblings("li").fadeOut(400); &#125;); //鼠标滑过容器停止播放 $(".imgs").hover(function () &#123; clearInterval(timer); &#125;, function () &#123; showImg(); &#125;); // 遍历所有圆点导航实现划过切换至对应的图片 $(".dot&gt;li").click(function () &#123; clearInterval(timer); cur = $(this).index(); $(this).addClass("current").siblings().removeClass("current"); $(".imgs&gt;ul li").eq(cur).fadeIn(400).siblings("li").fadeOut(400); &#125;); //定义图片切换函数 function showImg() &#123; timer = setInterval(function () &#123; cur++; if (cur &gt;= len) &#123; cur = 0; &#125; $(".imgs&gt;ul li").eq(cur).fadeIn(400).siblings("li").fadeOut(400); $(".dot&gt;li").eq(cur).addClass("current").siblings().removeClass("current"); &#125;, 2000); &#125; showImg();&#125;); 最后整体思路没有变，但图片的切换就没有通过切换类来实现，而是使用了更加方便的jQuery的fadeIn()方法和fadeOut()，可以直接实现淡入淡出效果。 小圆点切换的实现还是通过切换类的方法 鼠标移到图片上自动停止播放则是通过jQuery的hover方法来实现的，移入的时候清除定时器，移出的时候再次执行切换函数的图片 点击小圆点切换图片这是通过，获取点击的那个小圆点的索引来定向切换图片 左右切换是获取当前小圆点的索引来定位，然后单击切换到下一张图片写这个花了很多时间，不过最后还是完成了，也学会了很多其他的东西。 最后是效果图]]></content>
  </entry>
  <entry>
    <title><![CDATA[关于float与inlie-block的使用]]></title>
    <url>%2F2019%2F05%2F13%2F%E5%85%B3%E4%BA%8Efloat%E4%B8%8Einlie-block%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽然之前有使用过float来把元素进行布局，但是发现这种方法存在缺点，后面发现还有display:inlie-block也能用来布局，但是在实际使用过后同样也发现一些问题，这次来讲一下这两种方式存在的问题以及解决办法。 关于float的使用使用float时存在的问题 可以看出当我们对子元素的div使用了float的时候，子元素成功浮动在了一行，但是父元素却出现了问题，父元素的宽度并没有被撑起，而是高度塌陷了，成为了一条线，这是因为使用了float之后会使文档脱离标准流，从而没有元素撑起父元素的高度。那么为了解决这个问题也有许多办法。 解决办法给父级元素设置一个固定的高度123.father&#123; height: 400px;&#125; 缺点：不够灵活 也给父级加上浮动123.father&#123; float: left;&#125; 缺点：会使父级与其他元素的关系发生变化，不推荐使用 给父级使用overflow + zoom1234.father&#123; overflow: hidden; zoom:1; /* 兼容处理,触发IE6/7的haslayout */&#125; 缺点：如果使用了定位，或者设置了边距的话，超出了父级的话将被隐藏但是使用起来比较方便，副作用也比较小比较好控制，推荐使用 在父级中加上一个div 兼容性较强 但是代码较多，且不利于维护优化 使用after伪元素1234567.father:after&#123; content: "."; /*生成内容作为最后一个元素，至于content里面是什么没有影响*/ display: block; /*使得生成的元素以块级元素显示，占满剩余空间*/ height: 0; /*避免生成的内容破坏原有空间的高度*/ clear: both; /*闭合浮动*/ visibility: hidden; /*使得生成内容不可见，并允许可能生成内容盖住的内容进行点击和交互*/&#125; 除了代码较多不好记之外是比较完美的解决方案，推荐使用。 使用了以上的办法，可以发现问题都能成功的解决。 关于display:inlie-block的使用使用display:inlie-block时存在的问题可以看出在使用display:inlie-block之后虽然子元素能够横向排列了，但是他们之间却会出现间隙，不过这种间隙不是来自边距，而是因为我们在书写div时回车会产生回车符，回车符相当于空白符，通常情况下，多个连续的空白符会合并成一个空白符，而产生“空白间隙”的真正原因就是这个让我们并不怎么注意的空白符。 解决办法我们可以发现其实这个空白符的间距其实是和字体大小有关系的，所以我们只需要将父级的字体大小设为0即可消去空白符。我们可以看到空白符已经被消去了，但是里面的字也不见了，所以我们要记得给子元素设置字体大小。 后面又发现的问题 通过图片我们可以看出，第一个和第三个子元素没有内容，那么他们就不会和有内容的子元素同占一行，会发生错位 而将他们同时设为有内容或者没有内容的时候这种情况就消失了，所以要十分注意这个问题]]></content>
  </entry>
  <entry>
    <title><![CDATA[jQuery学习（css样式操作）]]></title>
    <url>%2F2019%2F05%2F12%2FjQuery%E5%AD%A6%E4%B9%A0%EF%BC%88css%E6%A0%B7%E5%BC%8F%E6%93%8D%E4%BD%9C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言 这次学了jQuery关于css样式的操作，通过jQuery的方法给元素添加修改样式以及改变和获取元素的各种宽高。 操作css样式 css(name|pro|[,val|fn])方法格式1:DOM元素.css(“样式名称”, “值”);格式2:DOM元素.css({“样式名称1”:”值1”,”样式名称2”:”值2”}); 123456789101112131415&lt;body&gt;&lt;script&gt;$(function()&#123; var $test=$('.test'); $test.css('height','100px').css('outline','1px solid red'); // 这是第一种写法，添加多个css样式 $('.test').css(&#123; 'width':'200px', 'font-size':'30px', // 这是第二种添加css样式的方法 &#125;);&#125;)&lt;/script&gt;&lt;div class="test"&gt;这是一个测试div&lt;/div&gt;&lt;/body&gt; 操作尺寸width([val|fn])方法1234567891011121314&lt;body&gt;&lt;script&gt;$(function()&#123; var $test=$('.test'); console.log($test.width()); // 获取到数值为1520 $test.width('200px'); // 设置元素宽度为200px console.log($test.width()); // 结果为200&#125;)&lt;/script&gt;&lt;div class="test"&gt;这是一个测试div&lt;/div&gt;&lt;/body&gt; height([val|fn])方法 用法与效果与width方法一致 innerHeight()/innerWidth()获取第一个匹配元素内部区域高度/宽度（包括补白、不包括边框）。 outerHeight/outerWidth() 获取第一个匹配元素外部高度（默认包括补白和边框）。 设置为 true 时，计算边距在内。1234567891011121314&lt;body&gt;&lt;script&gt;$(function()&#123; var $test=$('.test'); console.log($test.outerHeight()); // 21 console.log($test.height()); // 21 console.log($test.outerHeight(true)); // 填入参数true时会获取边距的数值，此时设置了外边距，值为41 &#125;)&lt;/script&gt;&lt;div class="test"&gt;这是一个测试div&lt;/div&gt;&lt;/body&gt; 操作和获取元素位置offset([coordinates]) 获取或设置元素相对窗口的偏移位123456789101112131415161718192021&lt;style&gt;.test&#123; margin-top: 2000px; outline: 1px solid red; height: 20px;&#125;&lt;/style&gt;&lt;body&gt;&lt;script&gt;$(function()&#123; var $test=$('.test'); console.log($test.offset().top); // 获取到值为2000 $test.offset(&#123;top:200,left:200&#125;); console.log($test.offset()); // [object Object]: &#123;left: 200, top: 200&#125;，位置成功发生变化 &#125;)&lt;/script&gt;&lt;div class="test"&gt;这是一个测试div&lt;/div&gt;&lt;/body&gt; position()获取匹配元素相对父元素的偏移。返回的对象包含两个整型属性：top 和 left。为精确计算结果，请在补白、边框和填充属性上使用像素单位。此方法只对可见元素有效。12345678910111213141516171819202122232425&lt;style&gt;.test&#123; /* margin-top: 2000px; */ outline: 1px solid red; height: 20px; position: absolute; top: 20px; left: 20px;&#125;.father&#123; position: relative;&#125;&lt;/style&gt;&lt;body&gt;&lt;script&gt;$(function()&#123; var $test=$('.test'); console.log($test.position()); // 成功获取到了绝对定位的数值20，20 &#125;)&lt;/script&gt;&lt;div class="father"&gt;&lt;div class="test"&gt;这是一个测试div&lt;/div&gt;&lt;/div&gt;&lt;/body&gt; scrollTop([val])与scrollLeft([val])获取匹配元素相对滚动条顶部的偏移。此方法对可见和隐藏元素均有效。下面以scrollTo()为例：123456789101112131415161718192021222324252627282930313233&lt;style&gt;.test&#123; margin-top: 2000px; outline: 1px solid red; height: 20px; position: absolute; top: 20px; left: 20px;&#125;button&#123; margin-top: 200px;&#125;&lt;/style&gt;&lt;body&gt;&lt;script&gt;$(function()&#123; console.log($('html').scrollTop()+$('body').scrollTop()); // 当拖动滚轮，点击按钮获取数值，数值能够正确显示。 $('button').eq(0).click(function()&#123; alert(($('html').scrollTop()+$('body').scrollTop())); // 兼容处理，保证所有浏览器都能正确获取数值&#125;); $('button').eq(1).click(function()&#123; $('html').scrollTop(300)+$('body').scrollTop(300);&#125;);&#125;)&lt;/script&gt;&lt;div class="father"&gt;&lt;div class="test"&gt;这是一个测试div&lt;/div&gt;&lt;/div&gt;&lt;button&gt;显示scrolltop&lt;/button&gt;&lt;button&gt;设置scrolltop&lt;/button&gt;&lt;/body&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[关于css选择器的一个小小的问题]]></title>
    <url>%2F2019%2F05%2F12%2F%E5%85%B3%E4%BA%8Ecss%E9%80%89%E6%8B%A9%E5%99%A8%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%B0%8F%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[前言 昨天在写一个页面的时候，写到css样式的时候，出现了一个问题,让我有一开始有点想不明白，后面明白了，记录一下。 问题情况： 这是html代码 12345&lt;div class="father"&gt; &lt;ul&gt; &lt;li class="son"&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 这是css代码 123456789101112.father ul li&#123; display:none; /* 此时这个div块中的所有内容都将不显示 */&#125;.son&#123; display:block; /* 起初我认为此时这个li中放的所有内容都应该显示，但是我在li中放的图片并没有显示，我就去查看控制台的样式，发现在这个li中的样式是有block这个属性但是并没有生效。 */&#125;.father ul .son&#123; display:block; /* 后面我尝试着这样写，却发现这下图片就显示出来了 ，随后并猜测是选择器优先级的问题，随即查阅资料，发现组合选择器的优先级为成员选择器的权重相加，只写一个类选择器干不过上面的多个选择器权重相加，所以多组合一些就好了，或者用!important 来拉满。*/&#125; 总结选择器的权重问题。虽然以前看到过选择器优先级相关的知识，但是还没有接触过很多这种情况，以后要注意！]]></content>
  </entry>
  <entry>
    <title><![CDATA[jQuery学习（核心函数）]]></title>
    <url>%2F2019%2F05%2F10%2FjQuery%E5%AD%A6%E4%B9%A0%EF%BC%88%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言 记录了jQuery的核心函数以及jQuery对象，jQuery的静态方法的使用。 jQuery核心函数jQuery核心函数一共3大类4小类 jQuery(callback)当DOM加载完成后执行传入的回调函数 jQuery([sel,[context]])接收一个包含 CSS 选择器的字符串，然后用这个字符串去匹配一组元素,并包装成jQuery对象,也就是jQuery的选择器。 jQuery(html,[ownerDoc])根据 HTML 标记字符串，动态创建DOM 元素 12345678910111213141516&lt;script&gt;$(function()&#123; var $text=$("&lt;p&gt;这是一段文字&lt;/p&gt;"); $("body").append($text);&#125;);&lt;/script&gt;``` ### jQuery对象* jQuery对象的本质是什么? jQuery对象的本质是一个伪数组```html&lt;script&gt; var $div = $('div'); console.log($div); // [object Object]: &#123;0: Object, context: Object, length: 1, prevObject: Object, selector: "div"&#125;&lt;/script&gt; 什么是伪数组?有0到length-1的属性,并且有length属性 jQuery静态方法 什么是静态方法?静态方法对应的是对象方法,对象方法用实例对象调用,而静态方法用类名调用 jQuery.holdReady(hold)暂停或者恢复jQuery.ready()事件传入true或false1234567891011121314151617181920&lt;script&gt; // 使用$直接调用,是静态方法 $.holdReady(true); // 暂停住了 $(function () &#123; $("#first").click(function () &#123; alert("我是你想要的弹窗"); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button id="first"&gt;点击测试弹出&lt;/button&gt;&lt;button id="second"&gt;解除延迟&lt;/button&gt;&lt;script&gt; $("#second").click(function()&#123; $.holdReady(false); // 单击会触发这个，然后恢复 &#125;);&lt;/script&gt; $.each(object,[callback])遍历对象或数组优点统一遍历对象和数组的方式回调参数的顺序更符合我们的思维模式 $.map(arr|obj,callback)遍历对象或数组,将回调函数的返回值组成一个新的数组返回 $.trim(str)去掉字符串起始和结尾的空格。 $.isArray(obj)判断是否是数组 $.isFunction(obj)判断是否是函数 $.isWindow(obj)判断是否是window对象]]></content>
  </entry>
  <entry>
    <title><![CDATA[jQuery学习（入口函数与冲突问题）]]></title>
    <url>%2F2019%2F05%2F10%2FjQuery%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%A5%E5%8F%A3%E5%87%BD%E6%95%B0%E4%B8%8E%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言 jQuery入口函数与原声js入口函数的区别，以及解决冲突问题，还有一些小细节，帮助我学习。 jQuery入口函数 多个window.onload只会执行一次, 后面的会覆盖前面的 多个$(document).ready()会执行多次,后面的不会覆盖前面的 不会覆盖的本质(了解,后面jQuery原理会详细讲解)jQuery框架本质是一个闭包,每次执行我们都会给ready函数传递一个新的函数,不同函数内部的数据不会相互干扰 window.onload $(document).ready() 执行时机 必须等待网页全部加载完毕(包括 图片等),然后再执行包裹代码 只需要等待网页中的DOM结构 加载完毕,就能执行包裹的代码 执行次数 只能执行一次,如果第二次,那么 第一次的执行会被覆盖 可以执行多次,第N次都不会被上 一次覆盖 简写方案 无 $(function () { }); 解决$符号冲突问题 为什么是window.jQuery = window.$ = jQuery;,而不是window.jQuery = jQuery; jQuery框架之所以提供了jQuery访问还提供$访问,就是为了提升开发者的编码效率 $符号冲突怎么办? 很多js的框架都提供了类似jQuery这样的便捷访问方式,所以很有可能某一天我们在使用多个框架的时,多个框架作者提供的便捷访问方式冲突(A框架通过$访问,B框架也通过$访问) ***释放$使用权 当便捷访问符号发生冲突时,我们可以释放$使用权, 释放之后只能使用jQuery]]></content>
  </entry>
  <entry>
    <title><![CDATA[jQuery学习（介绍与使用）]]></title>
    <url>%2F2019%2F05%2F10%2FjQuery%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言 对于前端来说，学习掌握jQuery是基础，则将会是我学习jQuery的记录。jQuery中文文档：http://hemin.cn/jq/。 jQuery是什么？ jQuery是一款优秀的JavaScript库，从命名可以看出jQuery最主要的用途是用来做查询（jQuery=js+Query）. 在jQuery官方Logo下方还有一个副标题（write less, do more）, 体现了jQuery除了查询以外,还能让我们对HTML文档遍历和操作、事件处理、动画以及Ajax变得更加简单 为什么要使用jQuery？ 强大选择器: 方便快速查找DOM元素如上面实例所展示一样，通过jQuery查找DOM元素要比原生js快捷很多jQuery允许开发者使用CSS1-CSS3几乎所有的选择器,以及jQuery独创的选择器 以下是一段jQuery代码：1234567891011121314151617&lt;body&gt; &lt;div class="test1"&gt;这是1&lt;/div&gt; &lt;div&gt;这是0&lt;/div&gt; &lt;div id="test2"&gt;这是2&lt;/div&gt; &lt;script&gt; $(document).ready(function()&#123; $(".test1").css('width','100px').css('height','200px'); $("#test2").css('background','blue'); // 读取数据 var $tx = $("div").eq(0).text(); alert($tx); // 写入数据 $("div").eq(0).text("新的数据"); &#125;); &lt;/script&gt;&lt;/body&gt; 通过以上代码可以看出，jQuery查找元素要快的多，方便的多，并且jQuery可以不断的调用jQuery对象的方法，并且可以一次操作。读取数据也是一个函数，使用比较方便 事件处理 DOM操作(C增U改D删) 样式操作 动画 丰富的插件支持 浏览器兼容(前端开发者痛点) 如何使用jQuery？下载过后这样调用就可以了：1&lt;script src="../jquery-1.12.4.js"&gt;&lt;/script&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[关于classList的使用]]></title>
    <url>%2F2019%2F05%2F10%2F%E5%85%B3%E4%BA%8EclassList%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言 关于classList的学习总结，作为DOMTokenList对象该属性用于在元素中添加、移出、切换css类，使用classList可以实现十分多的功能，十分的有用，以下是我的学习笔记。 语法：elem.classList方法：add( String[,String])：添加指定的类值。如果这些类已经存在于元素的属性中，那么他们将被忽略remove(String[,String])：删除指定的类值item(Number)：按集合中的索引返回类值toggle(String[,force])： 当只有一个参数的时，切换class value ，即如果类存在，删除它，并返回false，如果类不存在，则添加它并返回true。 当存在第二个参数时，如果第二个参数的计算结果为true，则添加指定的类值，如果计算结果为false，则删除它 contains(string)：检查元素的类属性中是否存在指定的类值属性：length：返回类列表中类的数量，该属性是只读的 下面是利用classList实现标签栏切换的一个小例子：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;style&gt; div &#123; width: 500px; margin: 10px; &#125; .db&#123; height: 50px; width: 300px; margin: 0 auto; border: none; &#125; .dh&#123; background: #666; height: 25px; width: 300px; margin: 0 auto; color: white; text-align: center; border: none; &#125; .dhd&#123; margin: 0 0px; width: 100px; float: left; margin-top: 3px; &#125; .dbd&#123; width: 100px; height: 50px; float: left; margin: 0 0px; display: none; width: 300px; &#125; .current&#123; display: block; background: white; color: black; &#125; .ttt&#123; border: 1px solid black; width: 300px; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class="ttt"&gt; &lt;div class='dh'&gt; &lt;div class="dhd current"&gt;标签栏一&lt;/div&gt; &lt;div class="dhd"&gt;标签栏二&lt;/div&gt; &lt;div class="dhd"&gt;标签栏三&lt;/div&gt; &lt;/div&gt; &lt;div class='db'&gt; &lt;div class="dbd current"&gt;这是内容一&lt;/div&gt; &lt;div class="dbd"&gt;这是内容二&lt;/div&gt; &lt;div class="dbd"&gt;这是内容三&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; // 利用classList的方法给当前元素添加样式让其显示，其他元素默认不显示，以达到切换效果 var hs=document.getElementsByClassName('dhd'); var ds=document.getElementsByClassName('dbd'); for(var i=0;i&lt;hs.length;i++)&#123; hs[i].onmouseover=function()&#123; for(var i=0;i&lt;ds.length;i++)&#123; if(hs[i]==this)&#123; ds[i].classList.add('current'); hs[i].classList.add('current'); &#125; else&#123; ds[i].classList.remove('current'); hs[i].classList.remove('current'); &#125; &#125; &#125; &#125; &lt;/script&gt;&lt;/body&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[html中的块级元素与行级元素]]></title>
    <url>%2F2019%2F05%2F10%2Fhtml%E4%B8%AD%E7%9A%84%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E4%B8%8E%E8%A1%8C%E7%BA%A7%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[前言 在最开始的时候没有清除的认识到块级元素与行级元素的差别，也没有想到二者之间有如此大的差别，以及二者之间的关系以下是我对二者的学习总结： 块级元素和行内元素的定义块级元素： 总是在新行上开始； 高度，行高以及外边距和内边距都可控制； 宽度缺省是它的容器的100%，除非设定一个宽度。 它可以容纳内联元素和其他块元素 行内元素？ 和其他元素都在一行上； 高，行高及外边距和内边距不可改变； 宽度就是它的文字或图片的宽度，不可改变 内联元素只能容纳文本或者其他内联元素 对行内元素，需要注意如下： 设置宽度width 无效。 设置高度height 无效，可以通过line-height来设置。 设置margin 只有左右margin有效，上下无效。 设置padding 只有左右padding有效，上下则无效。注意元素范围是增大了，但是对元素周围的内容是没影响的。 可以通过display对二者进行调整display属性表： 值 描述 none 此元素不会被显示。 block 此元素将显示为块级元素，此元素前后会带有换行符。 inline 默认。此元素会被显示为内联元素，元素前后没有换行符。 inline-block 行内块元素。（CSS2.1 新增的值） list-item 此元素会作为列表显示。 run-in 此元素会根据上下文作为块级元素或内联元素显示。 compact CSS 中有值 compact，不过由于缺乏广泛支持，已经从 CSS2.1 中删除。 marker CSS 中有值 marker，不过由于缺乏广泛支持，已经从 CSS2.1 中删除。 table 此元素会作为块级表格来显示（类似 &lt;table&gt;），表格前后带有换行符。 inline-table 此元素会作为内联表格来显示（类似 &lt;table&gt;），表格前后没有换行符。 table-row-group 此元素会作为一个或多个行的分组来显示（类似 &lt;tbody&gt;）。 table-header-group 此元素会作为一个或多个行的分组来显示（类似 &lt;thead&gt;）。 table-footer-group 此元素会作为一个或多个行的分组来显示（类似 &lt;tfoot&gt;）。 table-row 此元素会作为一个表格行显示（类似 &lt;tr&gt;）。 table-column-group 此元素会作为一个或多个列的分组来显示（类似 &lt;colgroup&gt;）。 table-column 此元素会作为一个单元格列显示（类似 &lt;col&gt;） table-cell 此元素会作为一个表格单元格显示（类似 &lt;td&gt; 和 &lt;th&gt;） table-caption 此元素会作为一个表格标题显示（类似 &lt;caption&gt;） inherit 规定应该从父元素继承 display 属性的值。 这是一个小测试：123456789101112131415161718192021222324252627282930&lt;style&gt; div&#123; border: 1px solid blue; margin-bottom: 10px; &#125; span&#123; border: 1px solid red; height: 50px; margin: 40px; /* 可以发现对span这个行内元素设置了height属性但是其并没有生效 设置了margin，但只有左右margin生效，padding同理。 */ &#125; .div3&#123; display: inline; /* 将其设为行内元素，其只拥有行内元素的特性 */ &#125; .div4&#123; display: inline-block; /* 将其设置为行内块级元素，兼具二者特性 */ height: 50px; &#125;&lt;/style&gt;&lt;body&gt;&lt;div&gt;这是第一个div:div是块级元素，默认宽度是100%,可以设置宽度与高度，默认自动占一行&lt;/div&gt;&lt;div&gt;这是第二个div&lt;span&gt;这是一个块级元素:大小只与内容有关，不可以设置宽度与高度，但能设置行高，默认不占一行&lt;/span&gt;&lt;/div&gt;&lt;div"&gt;这是第三个div：通过display:inline将其变为行内元素&lt;/div&gt;&lt;div"&gt;这是第四个div:通过display:inline-block将其变为行内块级元素，兼具二者特性&lt;/div&gt;&lt;/body&gt; 效果图： 以上就是我的学习总结。]]></content>
  </entry>
  <entry>
    <title><![CDATA[一个简单的网页二级菜单]]></title>
    <url>%2F2019%2F05%2F09%2F%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%BD%91%E9%A1%B5%E4%BA%8C%E7%BA%A7%E8%8F%9C%E5%8D%95%2F</url>
    <content type="text"><![CDATA[前言 网页二级菜单十分常见，我学习到了写法，以下是我写的一个简单的demo当作练习，以及原理说明。 CSS代码12345678910111213.menu&#123; list-style: none;&#125;.menu&gt;li&#123; float: left;&#125;li&gt;ul&#123; display: none;&#125;.menu&gt;li:hover&gt;ul&#123; display: block;&#125; 实现二级菜单的主要原理部分还是在css部分，先将所有的二级菜单的内容通过display隐藏，当鼠标经过一级菜单则将二级菜单的内容显示出来。 html代码123456789101112131415161718192021222324252627&lt;body&gt; &lt;ul class="menu"&gt; &lt;li&gt;&lt;a href="#"&gt;菜单一&lt;/a&gt; &lt;ul&gt; &lt;li&gt;测试a1&lt;/li&gt; &lt;li&gt;测试a2&lt;/li&gt; &lt;li&gt;测试a3&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="#"&gt;菜单二&lt;/a&gt; &lt;ul&gt; &lt;li&gt;测试b1&lt;/li&gt; &lt;li&gt;测试b2&lt;/li&gt; &lt;li&gt;测试b3&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="#"&gt;菜单三&lt;/a&gt; &lt;ul&gt; &lt;li&gt;测试c1&lt;/li&gt; &lt;li&gt;测试c2&lt;/li&gt; &lt;li&gt;测试c3&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/body&gt; 效果图&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[css选择器总结]]></title>
    <url>%2F2019%2F05%2F08%2Fcss%E9%80%89%E6%8B%A9%E5%99%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前言 在编写css代码时合理使用选择器有助于提升编写效率以及缩短代码量，所以对常用的选择器熟练使用是十分有必要的，以下为一些选择器的使用总结。 基础的一些选择器标签选择器，以标签名作为选择器名类选择器，通过”.”+类名作为选择器名称如：.testid选择器，通过”#”+类名作为选择器名称如：#test 交集选择器标记选择器+类选择器或id选择器，中间不能有任何的空格如：p.aaa或p#aaa注意：后代选择器作用于所有后代。（与子代选择器的区分） 后代选择器：由两个标记选择器组成，第一个为父级，第二个为子代，中间一定要有空格div p注意：子代选择器作用于所有后代。（与后代选择器的区分） 子代选择器此时选择到的是作为子代的p 子代选择器与后代选择器的区别，子代选择器只作用于后一代儿子，而不会影响到孙子，后代选择器作用于所有后代div&gt;p 并集选择器：由若干个任意选择器组成，由逗号分隔开可以同时对多个目标生效。h1,.aaa,#bbb 属性选择器假设有html代码：1&lt;input name="test" placeholder="初始值" class="test" id="test" type="text" value=""&gt; E[att^=value] E可以省略，满足 属性值 等于valueinput[name^=test]E[att$=value] E可以省略，满足 属性值后缀 等于valueinput[name$=st]E[att*=value] E可以省略，满足 属性值包含 valueinput[name*=es] 兄弟选择器p+h2 选择到的是p后面的 相邻的 h2p~h2 选择到的是p后面的 不一定相邻的 h2 伪类选择器：:root 该选择器对页面所有元素的生效，可以用其他选择器将其覆盖:not 该选择器可以将选定内容排除在大选择器之外（body :not(p)）此时选择器就不会选择到p标记。冒号之前必须有空格 伪元素选择器：:first-letter 向文本的第一个字母添加样式:first-line 向文本的首行添加特殊样式。:before 在元素之前添加内容。:after 在元素之后添加内容。 链接伪类：a:link 未访问时的状态a:visited 访问后的状态a:active 鼠标单击不动时的状态a:hover 悬停时的状态 关于选择器的优先级比较同一级别的个数，数量多的优先级高，如果相同即比较下一级别的个数important &gt; 内联 &gt; ID &gt; 类 &gt; 标签 | 伪类 | 属性选择 &gt; 伪对象 &gt; 通配符 &gt; 继承]]></content>
  </entry>
  <entry>
    <title><![CDATA[markdown基本语法(在hexo中的使用)]]></title>
    <url>%2F2019%2F03%2F11%2Fmarkdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言 hexo使用markdown来书写博客，所以熟悉了解markdown十分有必要，这是markdown在hexo中的使用,这里介绍markdown的基础以及在hexo中的应用。 一、标题12345# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题 效果： 这是一级标题这是二级标题这是三级标题这是四级标题这是五级标题二、文字1234**这是加粗的文字** //用两个*将文字包起即加粗*这是斜体文字* //用一个*将文字包起即斜体***这是加粗同时斜体的文字*** //用三个*将文字包起即加粗斜体 ~~这是加删除线的文字~~ //要加删除线的文字左右分别用两个~~号包起来 效果： 这是加粗的文字这是斜体文字这是加粗同时斜体的文字这是加删除线的文字 三、引用在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;n个…123&gt;这是引用的内容&gt;&gt;这是引用的内容&gt;&gt;&gt;这是引用的内容 效果： 这是引用的内容 这是引用的内容 这是引用的内容 四、分割线几种样式，效果一样1234-------******** 五、图片图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加还可以用html标记来插入图片：1&lt;img width=200 src=&quot;../images/lm.jpg&quot;/&gt; 并且可以自定义大小但是hexo中使用以上两种方式会导致一些问题，所以在hexo中建议使用以下方法：1&#123;% asset_img example.jpg This is an example image %&#125; 六、超链接1[超链接名](超链接地址 &quot;超链接title&quot;) title可加可不加示例：1[百度](https://www.baidu.com) 百度一样的可以使用html标记来插入超链接： 百度并且可以设置在新窗口打开 七、列表无序：123- 列表内容+ 列表内容* 列表内容 注意：- + * 跟内容之间都要有一个空格 列表内容 列表内容 列表内容 用html标记也可以：12345&lt;ul&gt;&lt;li&gt;列表内容1&lt;/li&gt;&lt;li&gt;列表内容2&lt;/li&gt;&lt;li&gt;列表内容3&lt;/li&gt;&lt;/ul&gt; 有序：数字加点:1231. 列表内容2. 列表内容3. 列表内容 列表内容 列表内容 列表内容 注意：序号跟内容之间要有空格 八、表格1234表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容 表头 表头 表头 内容 内容 内容 内容 内容 内容 第二行分割表头和内容。-有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略同样，可以用html标记实现：12345&lt;table&gt;&lt;tr&gt;&lt;td&gt;表头&lt;/td&gt;&lt;td&gt;表头&lt;/td&gt;&lt;td&gt;表头&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;内容&lt;/td&gt;&lt;td&gt;内容&lt;/td&gt;&lt;td&gt;内容&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;内容&lt;/td&gt;&lt;td&gt;内容&lt;/td&gt;&lt;td&gt;内容&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 表头表头表头内容内容内容内容内容内容 九、代码单行代码：代码之间分别用一个反引号包起来代码内容代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行123代码...在开头的三个反引号后面加上语言名称还可以显示对应高亮代码... 代码高亮 十、流程图由于hexo不支持流程图所以不做演示]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F12%2F02%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
