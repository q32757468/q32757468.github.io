<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[vue.js的学习（vue中的动画）]]></title>
    <url>%2F2019%2F06%2F20%2Fvue-js%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%88vue%E4%B8%AD%E7%9A%84%E5%8A%A8%E7%94%BB%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一开始在使用vue中的动画的时候我没有太明白究竟是个怎么样的机制，以及如何高度的定义一些动画，经过我的尝试，现在终于算是弄明白时怎么一回事了这里时官方文档。 vue中动画的特点vue中的动画主要分为两部分，一是进场动画，二是离场动画，vue中的动画主要是监听了设置动画的元素的显示和隐藏，当元素在页面中被显示的时候就会执行进场动画，当元素被隐藏的时候就会执行离场动画，我们可以通过设置两组类来设置离场动画和进场动画。 一个简单的小例子12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;style&gt; /* 这两个类一个是进入时候的动画效果，一个是离开时候的动画效果 */ .dh1-enter-active, .dh1-leave-active &#123; opacity: 1; transition: all 1s ease; &#125; /* 这两个类一个是动画的起始位置,一个是动画结束的时候的位置 */ .dh1-enter, .dh1-leave-to &#123; transform: translateX(40px); opacity: 0; &#125;&lt;/style&gt;&lt;body&gt; &lt;!-- vue中的动画可以分为两部分，一部分是进入的动画，一部分是离开的动画，当元素被隐藏的时候会触发离开的动画，出现的时候会触发进入的动画 --&gt; &lt;div id="app"&gt; &lt;!-- 这是通过这种transition和两个种类来设置动画 --&gt; &lt;button @click="flag=!flag"&gt;点击切换状态&lt;/button&gt; &lt;button @click="flag2=!flag2"&gt;点击切换状态2&lt;/button&gt; &lt;!-- 通过添加appear 可以使动画在渲染到页面的时候就执行一次 --&gt; &lt;transition name="dh1" appear&gt; &lt;p v-show="flag"&gt;这是一段话第一段话&lt;/p&gt; &lt;/transition&gt; &lt;transition name="dh2"&gt; &lt;p v-show="flag2" :class="&#123;animated:true,bounce:true&#125;"&gt;这是一段话第二段话&lt;/p&gt; &lt;/transition&gt; &lt;/div&gt; &lt;script src="./../../js/vue.js"&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#app', data() &#123; return &#123; flag: 'true', flag2: 'false', &#125; &#125;, methods: &#123; &#125;, &#125;) &lt;/script&gt;&lt;/body&gt; 单元素过渡 可以看出其实vue中将动画主要分成了两部分 一部分是入场时的动画，也就是动画从隐藏到显示的这个过程中所执行的动画 另一部分是离场动画也就是元素从显示到隐藏这个过程中所执行的动画 可以通过4个类来分别控制动画，就像上面的例子中的那样 也可以通过vue来添加类来引用动画库中的动画 钩子函数vue中的钩子函数将进场动画和离场动画进行了细分，包括进场前和执行动画时，以及动画结束后，通过设置钩子函数就可以对动画的各个时机进行详细的设置。可以通过钩子函数来设置只进行进场动画或者离场动画，以及对外部引用的动画进行很好的控制。 可以通过这个例子看出来：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;style&gt; .ball &#123; width: 30px; height: 30px; background-color: bisque; border-radius: 50%; margin-top: 10px; &#125;&lt;/style&gt;&lt;body&gt; &lt;!-- 通过钩子函数来实现动画就不再是通过设置样式来实现动画效果，而是通过js来设置样式来实现动画效果 --&gt; &lt;!-- 也是分为几个阶段，主要是两部分，一是进场动画，一是离场动画 --&gt; &lt;!-- 进场动画又分为 --&gt; &lt;!-- 进场前：主要是通过设置style来设置起始时的样式位置之类的 --&gt; &lt;!-- 进场时：主要通过设置style来设置动画结束时的位置，以及动画属性的设置如动画时常 --&gt; &lt;!-- 进场后：动画完成后所执行的东西 --&gt; &lt;!-- 其实钩子函数的原理还是对单元素的过渡做了封装，只不过是可以通过js来控制只进行进场动画或者只进行离场动画 --&gt; &lt;div id="app"&gt; &lt;button @click="flag=!flag"&gt;单击&lt;/button&gt; &lt;transition v-on:before-enter="beforeEnter" v-on:enter="enter" v-on:after-enter="afterEnter"&gt; &lt;div v-show="flag" class="ball"&gt;&lt;/div&gt; &lt;/transition&gt; &lt;/div&gt; &lt;script src="./../../js/vue.js"&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#app', data() &#123; return &#123; flag: false, &#125; &#125;, methods: &#123; // 所有的钩子函数都必须传一个el参数，表示操作的原生dom对象 beforeEnter(el) &#123; el.style.transform = "translate(0,0)"; &#125;, enter(el, done) &#123; //在单纯的使用js钩子函数设置动画时必须传一个done参数来执行完成后的操作，这个done实际上是after-enter所绑定的方法 el.offsetWidth; //这个必须加，不加出bug，没有为什么 el.style.transform = "translate(40px,100px)"; el.style.transition = "all 1s ease"; done(); &#125;, afterEnter(el) &#123; // 这里因为只需要重复这个半场动画，这个从隐藏到出现从上到下的过程，所以将元素设置为不显示，下次再单击的时候就又是执行的是从上到下的动画了 this.flag = !this.flag; &#125; &#125;, &#125;) &lt;/script&gt;&lt;/body&gt; 列表动画在前面的所有例子都是设置的单元素动画，不能用于设置列表中的动画，但我们需要设置一个列表动画，让其中的所有元素都有动画效果的时候，我们就可以使用transition-group这个标签来包裹我们想要设置动画的列表。就像下面这个例子这样：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;style&gt; span &#123; margin: 5px; /* 这里要注意一件事情，必须设置为inline-block,不然元素不会从下面出来，或者使用弹性布局也可以 */ display: inline-block; &#125; .v-enter-active, .v-leave-active &#123; opacity: 1; transition: all 1s ease; &#125; .v-enter, .v-leave-to &#123; transform: translateY(30px); opacity: 0; &#125; /* 要实现其他元素位移时有动画必须添加下面这个类，并且设置动画 */ .v-move &#123; transition: all 1s ease; &#125; /* 而且还必须单独给v-leave-active这个类设置绝对定位才可以实现效果 */ .v-leave-active &#123; position: absolute; &#125;&lt;/style&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;button style="margin-left: 10px" @click="addnum"&gt;add&lt;/button&gt; &lt;button style="margin-left: 10px" @click="delnum"&gt;del&lt;/button&gt; &lt;transition-group tag="div" :style="&#123;margin:'10px'&#125;"&gt; &lt;!-- 如果要让原来元素再插入的过程中保持位置不变，就需要设置key --&gt; &lt;span v-for="(item,index) in list" :key="item"&gt;&#123;&#123;item&#125;&#125;&lt;/span&gt; &lt;/transition-group&gt; &lt;/div&gt; &lt;script src="./../../js/vue.js"&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue(&#123; el: "#app", data() &#123; return &#123; list: [1, 2, 3, 4, 5, 6, 7, 8, 9], num: 10, &#125; &#125;, methods: &#123; randomIndex() &#123; // Math.floor()的作用是返回一个小于等于参数的整数 return Math.floor(Math.random() * this.list.length) &#125;, addnum() &#123; // splice方法还可以用来在指定位置添加元素，第三个参数就是要添加的元素 this.list.splice(this.randomIndex(), 0, this.num++) &#125;, delnum() &#123; this.list.splice(this.randomIndex(), 1) &#125; &#125;, &#125;) &lt;/script&gt;&lt;/body&gt; 这里要注意的几件事是： 如果要使动画生效，必须将要设置动画的元素设置为块级元素或者行内块级元素，如果是行内元素则不会有动画效果。 如果要使其他元素在发生位置移动也拥有动画过渡的效果这需要添加一个v-move这个类，当然，这个名称也是一样可以修改的，然后在这个类中设置动画过渡效果，像上面的这个例子这样。 但是其实只v-move这个类其实是还不够的，还需要在v-leave-active中设置绝对定位，这里要注意的一件事情是，这里必须单独只给这一个类设置，否则也不会有动画效果，一开始的时候我贪图方便就直接在设置active这组动画的时候设置上绝对定位，也就是给两个类都加上了绝对定位，结果发现这样并没有效果，只有单独给一个类设置的时候才有效果。 总结要熟练设置vue中的动画就必须要理解vue中动画的运作机制，理解进场和离场这两个过程，然后可以通过设置两组类来设置动画的效果，当这种方法无法满足需求的时候就可以通过钩子函数来满足我们的需求。]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue.js的学习（vue实例的生命周期）]]></title>
    <url>%2F2019%2F06%2F18%2Fvue-js%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%88vue%E5%AE%9E%E4%BE%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过学习了解vue实例的生命周期对vue的学习十分的有帮助，所以这次来了解学习以下vue中vue实例的生命周期。 什么是生命周期：从Vue实例创建、运行、到销毁期间，总是伴随着各种各样的事件，这些事件，统称为生命周期！ 生命周期钩子：就是生命周期事件的别名而已； 生命周期钩子 = 生命周期函数 = 生命周期事件 主要的生命周期函数分类： 创建期间的生命周期函数： beforeCreate：实例刚在内存中被创建出来，此时，还没有初始化好 data 和 methods 属性 created：实例已经在内存中创建OK，此时 data 和 methods 已经创建OK，此时还没有开始 编译模板 beforeMount：此时已经完成了模板的编译，但是还没有挂载到页面中 mounted：此时，已经将编译好的模板，挂载到了页面指定的容器中显示 运行期间的生命周期函数： beforeUpdate：状态更新之前执行此函数， 此时 data 中的状态值是最新的，但是界面上显示的 数据还是旧的，因为此时还没有开始重新渲染DOM节点 updated：实例更新完毕之后调用此函数，此时 data 中的状态值 和 界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了！ 销毁期间的生命周期函数： beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。 destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 可以通过这张图来形象的了解以下生命周期的含义： 这次的vue的生命周期的学习就到这里了，通过这张图可以有比较完整的了解。]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue.js的学习（自定义指令）]]></title>
    <url>%2F2019%2F06%2F18%2Fvue-js%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%88%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在vue中很多时候现有的指令都是不够我们用的，那么vue中是允许我们自定义指令的，那么我们就可以通过自定义指令来实现我们想要的功能。通过 directive 来定义。 一个简单的例子123456789101112131415161718192021222324252627282930&lt;body&gt; &lt;div id="app"&gt; &lt;input type="text" v-focus='1+1'&gt; &lt;/div&gt; &lt;script src="./../../js/vue.js"&gt;&lt;/script&gt; &lt;script&gt; Vue.directive('focus',&#123; inserted:function(el,binding)&#123; el.focus(); console.log(binding.name); console.log(binding.value); console.log(binding.expression); &#125; &#125;); var vm = new Vue(&#123; el:'#app', data() &#123; return &#123; &#125; &#125;, methods: &#123; &#125;, &#125;) &lt;/script&gt;&lt;/body&gt; 可以看出这样就通过定义了一个全局指令来使一个文本框自动获得了焦点。 定义全局指令上面的例子就是定义的一个全局指令 ###定义局部指令12345678directives: &#123; focus: &#123; // 指令的定义 inserted: function (el) &#123; el.focus() &#125; &#125;&#125; 像这样就可以定义一个局部指令，局部指令是通过一个对象来定义。，并且名称后面带有s。 钩子函数在上面的例子中以下代码就是用的inserted这个钩子函数1inserted:function(el,binding)&#123; 钩子函数的类别： bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。这是在dom树还没有渲染到页面中之前，还在内存中的时候会调用，那么对于大部分js中的行为来说肯定是不会生效的，但对于比如像设置样式这种一直存在的东西来说，渲染到页面之后也还会有效 inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。当dom元素被插入到页面时触发，对于js中的行为也能触发 update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。 componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。 unbind：只调用一次，指令与元素解绑时调用。 钩子函数的参数 el：指令所绑定的元素，可以用来直接操作 DOM 。 binding：一个对象，包含以下属性： -name：指令名，不包括 v- 前缀。 -value：指令的绑定值，例如：v-my-directive=”1 + 1” 中，绑定值为 2。 -oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。 -expression：字符串形式的指令表达式。例如 v-my-directive=”1 + 1” 中，表达式为 “1 + 1”。 -arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 “foo”。 -modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。 vnode：Vue 编译生成的虚拟节点。移步 VNode API 来了解更多详情。 oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。 在上面的例子中就演示了这些参数：12345678Vue.directive(&apos;focus&apos;,&#123; inserted:function(el,binding)&#123; el.focus(); console.log(binding.name); //focus console.log(binding.value);//2 console.log(binding.expression);//1+1 &#125;&#125;);]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue.js的学习（按键修饰符及自定义按键修饰符）]]></title>
    <url>%2F2019%2F06%2F18%2Fvue%E4%B8%AD%E7%9A%84%E9%94%AE%E7%9B%98%E4%BF%AE%E9%A5%B0%E7%AC%A6%E4%BB%A5%E5%8F%8A%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%AE%E7%9B%98%E4%BF%AE%E9%A5%B0%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在vue中可以通过键盘修饰符来控制元素在按下相应按键时的动作。vue中提供了部分内置的键盘修饰符按键码的别名，但是不是很多，那么在vue中也是可以自定义的。 案件修饰符的使用在监听键盘事件时，我们经常需要检查详细的按键。Vue 允许为 v-on 在监听键盘事件时添加按键修饰符：1&lt;input v-on:keyup.enter=&quot;test()&quot;&gt; 可以通过按键码来实现1&lt;input v-on:keyup.13=&quot;test()&quot;&gt; enter键的按键码就是13，所以等同于上面那个例子。 vue中自带的别名 .enter .tab .delete (捕获“删除”和“退格”键) .esc .space .up .down .left .right 自定义案件修饰符可以通过这样的方式来自定义按键修饰符：12Vue.config.keyCodes.f2 = 113; 然后就可以通过按下f2来触发了。 系统修饰符 .ctrl .alt .shift .meta 通过系统修饰符可以控制系统按键与其他事件的组合：1&lt;input type=&quot;text&quot; @keyup.13.ctrl=&quot;test()&quot; &gt; 以上代码就需要同时按回车以及control键才能触发。 鼠标按钮修饰符2.2.0 新增 .left .right .middle 像是这样：1&lt;input type=&quot;text&quot; @click.left=&quot;test()&quot; &gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue.js的学习（七）过滤器filter的使用]]></title>
    <url>%2F2019%2F06%2F17%2Fvue-js%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%83%EF%BC%89%E8%BF%87%E6%BB%A4%E5%99%A8filter%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;filter过滤器可以用来格式化数据，只能用在插值表达式或者v-model之类的组件上面。分为全局过滤器和私有过滤器，在定义的方法上稍有区别。 定义全局过滤器Vue.js 允许你自定义过滤器，可被用于一些常见的文本格式化。过滤器可以用在两个地方：双花括号插值和 v-bind 表达式 (后者从 2.1.0+ 开始支持)。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符号指示：1&lt;td&gt;&#123;&#123;item.time | dateformat&#125;&#125;&lt;/td&gt; 12345678910Vue.filter('dateformat',function(date)&#123; var dt=new Date(date); var y=dt.getFullYear(); var m=dt.getMonth()+1; var d=dt.getDate(); var h=dt.getHours(); var min=dt.getMinutes(); var s=dt.getSeconds(); return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;h&#125;:$&#123;min&#125;:$&#123;s&#125;`; &#125;); 过滤器可以串联：1&#123;&#123; message | filterA | filterB &#125;&#125; 在这个例子中，filterA 被定义为接收单个参数的过滤器函数，表达式 message 的值将作为参数传入到函数中。然后继续调用同样被定义为接收单个参数的过滤器函数 filterB，将 filterA 的结果传递到 filterB 中。 过滤器是 JavaScript 函数，因此可以接收参数：1&lt;td&gt;&#123;&#123;item.time | dateformat(&apos;yyyy-mm-dd&apos;)&#125;&#125;&lt;/td&gt; 1234567891011121314Vue.filter('dateformat',function(date,agr='')&#123;//最好给参数设置一个默认值，防止出现bug var dt=new Date(date); var y=dt.getFullYear(); var m=dt.getMonth()+1; var d=dt.getDate(); var h=dt.getHours(); var min=dt.getMinutes(); var s=dt.getSeconds(); if(agr=='yyyy-mm-dd')&#123; return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;`; &#125; else return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;h&#125;:$&#123;min&#125;:$&#123;s&#125;`; &#125;); 定义私有过滤器123456789101112131415filters:&#123; dateformat(date,agr='')&#123; var y=dt.getFullYear(); var m=(dt.getMonth()+1).toString().padStart(2,'0'); var d=dt.getDate().toString().padStart(2,'0'); var h=dt.getHours().toString().padStart(2,'0'); var min=dt.getMinutes().toString().padStart(2,'0'); var s=dt.getSeconds().toString().padStart(2,'0'); if(agr=='yyyy-mm-dd')&#123; return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;`; &#125; else return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;h&#125;:$&#123;min&#125;:$&#123;s&#125;`; &#125;&#125;, 通过一个对象来设置，整体与全局设置的方法差不多。 学习到的一些知识 可以通过`${y}-${m}-${d} ${h}:${min}:${s}`像这样的方式来格式化数据，${}为占位符。 可以通过padStart(len, str)与padEnd(len, str)这两个方法来补全字符串，但是要注意只能补全字符串，所以通常需要先通过tostring()方法转化为字符串 根据给定长度自动在字符串的前面补充想补充的字符串（只返回修改后的字符串，不修改原字符串） len 给定的长度，转换后 str 想补充的字符串类似这样：1var s=dt.getSeconds().toString().padStart(2,&apos;0&apos;); 总结通过定义filter可以很方便的来格式化数据，这里还有一个小细节，就是带s的就是私有的，不带s的就是全局的。]]></content>
  </entry>
  <entry>
    <title><![CDATA[通过vue来做一个可以简单操作的页面]]></title>
    <url>%2F2019%2F06%2F17%2F%E9%80%9A%E8%BF%87vue%E6%9D%A5%E5%81%9A%E4%B8%80%E4%B8%AA%E5%8F%AF%E4%BB%A5%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C%E7%9A%84%E9%A1%B5%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;经过学习了vue的一些简单基本的东西，现在讲前面学过的这些东西简单的引用一下，做一个可以简单操作页面元素的页面，同时来熟悉vue的操作。 代码和效果图html:1234567891011121314151617181920212223242526272829303132333435363738394041&lt;div id="app"&gt; &lt;div class="container"&gt; &lt;div class="card"&gt; &lt;div class="card-header"&gt; 相关操作 &lt;/div&gt; &lt;div class="card-body"&gt; &lt;!-- 给表单添加v-model来实现数据的双向绑定 --&gt; &lt;form class="form-inline"&gt; &lt;label for=""&gt;id：&lt;/label&gt; &lt;input class="form-control mr-md-2 " type="text" name="" v-model="id"&gt; &lt;label for=""&gt;name：&lt;/label&gt; &lt;input class="form-control" type="text" name="" v-model="name"&gt; &lt;button class="btn btn-primary ml-md-1 mr-md-3" type="button" @click='add'&gt;添加&lt;/button&gt; &lt;!-- 实现搜索功能 --&gt; &lt;label for=""&gt;输入关键字进行搜索：&lt;/label&gt; &lt;input class="form-control" type="text" name=""&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;table class="table table-light mt-5 table-bordered table-striped"&gt; &lt;thead class="thead-light"&gt; &lt;tr&gt; &lt;th&gt;Id&lt;/th&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Time&lt;/th&gt; &lt;th&gt;opration&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;!-- 通过v-for的循环来将我们的数据来渲染到页面中 --&gt; &lt;tr v-for="(item) in info" :key="item.id"&gt; &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.time&#125;&#125;&lt;/td&gt; &lt;td&gt;&lt;a href="" @click.prevent='rm(item.id)'&gt;删除&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt; js:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 var vm = new Vue(&#123; el: '#app', data() &#123; return &#123; id: '', name: '', time: '', keywords:'', // 将我们页面中的数据放在这俩面 info: [&#123; id: '1', name: 'aaa', time: new Date() &#125;, &#123; id: '2', name: 'bbb', time: new Date() &#125;, ], &#125; &#125;, methods: &#123; // 通过自己构建函数来控制添加和删除 add() &#123;//这是添加的函数 this.info.push(&#123; id: this.id, name: this.name, time: new Date(), &#125;); this.id = this.name = ''; &#125;, rm(id) &#123;//这是删除的函数，我用了两种写法 // this.info.forEach((item,index) =&gt; &#123; // if(id=item.id)&#123; // this.info.splice(index,1) // return ; // &#125; // &#125;); // 这一种代码会更简便一些 this.info.splice(this.info.findIndex(item =&gt; &#123; return item.id == id; &#125;), 1); &#125;, searchList(keywords)&#123; return this.info.filter(item =&gt; &#123; return item.name.includes(keywords); &#125;) &#125; &#125;,&#125;) 最后的效果图： 通过页面上的增加和删除就可以实现页面的修改 实现原理在vue中更看重于业务逻辑，所以很多方面的工作我们不需要去关心，也不需要去操作dom对象就可以轻松的修改页面上的内容 我们通过v-for的循环将我们的数据渲染到页面中 我们通过v-model数据双向绑定来将用户在页面中输入的数据放到我们存放数据的地方，因为vue的特性，只要数据有更新，那么页面就会跟着一起更新，这是十分方便的一件事情 再通过数组的一些操作方法将我们想要删除的数据进行删除，那么页面中相应的内容也会被删除。 搜索功能是通过v-model数据的双向绑定来拿到用户需要搜索的数据，然后通过filter()这个方法来设置条件进行过滤，然后返回一个新的数组，过滤的条件可以通过inclues来设置。 学习到的一些知识正如我上一篇博客介绍的那样，在特定的情况下使用filter之类的方法会更加的便捷，这次在写搜索的那个函数的时候我就用到了filter这个方法，使代码更加的精简，这里可以使用foreach，但这会有更加多的代码量，所以我没有这么做。 我遇到的一些坑与问题 第一个花费时间比较久的地方是当我完成了数据的添加的这个功能之后发现了一个问题就是当我向页面中添加完数据之后，我再修改输入框中的数据，已经渲染在页面之中的数据也会跟着一起修改，很显然这不是我想要的效果，后面发现是我将一个带着变量的对象直接push到数组当中，而不是在单击事件的时候通过变量创建一个新的对象再push进去。也就是说应该需要一个中间的变量来将一个会实时变化的变量变成一个固定的变量。 第二个问题就是在使用findIndex方法的时候将return item.id == id写成了return item.id = id 导致在操作的时候出现了问题 总结这次写这些东西让我对vue有了更加清晰的概念，并且也用了一些以前没有用过的方法来使代码更加的简单，同时要记住写代码犯的一些错误，要记住在进行比较的时候判断是否相等要用==，千万不能永成赋值符号=]]></content>
  </entry>
  <entry>
    <title><![CDATA[js中的some、find、findindex、includes、filter的使用]]></title>
    <url>%2F2019%2F06%2F17%2Fjs%E4%B8%AD%E7%9A%84some%E3%80%81find%E3%80%81findindex%E3%80%81includes%E3%80%81filter%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最近在学习中学习到一些以前接触的比较少的一些方法，其中很多是es6新增的方法，这次就来对所有的这些方法来进行一个探究，看看这些方法究竟是什么作用。 类似于foreach的方法为什么把这类方法归到一起讲，因为我在使用的过程中发现其实这些方法的用法和参数其实都是一样的，底层应该都是和foreach差不多，差别只是在于返回的东西不一样，那么再来看看这些方法的差别以及用法。 语法 array.方法名(function(currentValue, index, arr),thisValue) 参数 参数 描述 function(currentValue, index,arr) 必需。数组每个元素需要执行的函数。函数参数: 参数 描述 currentValue 必需。当前元素 index 可选。当前元素的索引值 arr 可选。当前元素所属的数组对象 thisValue 可选。 传递给函数的值一般用 "this" 值。如果这个参数为空， "undefined" 会传递给 "this" 值 以上是这些方法共同的基本的语法以及参数 那么再来看看这些方法的不同点 forEach()forEach() 方法用于调用数组的每个元素，并将元素传递给回调函数。 注意: forEach() 对于空数组是不会执行回调函数的。 也就是说 forEach() 这个方法是没有任何限制的，回调函数最终返回的值是完全由自己决定的，也就是说其实后面介绍到的所有的方法其实也都可以通过forEach()来实现相同的功能，只不过要自己写更多的代码量。forEach()可以通过return来提前退出循环，同时返回相应的值 map()map() 方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。 map() 方法按照原始数组元素顺序依次处理元素。 注意： map() 不会对空数组进行检测。 注意： map() 不会改变原始数组。 map和foreach很像，差别就在于map所得到的所有符合条件的结果都会通过一个数组来返回。在我们需要将结果放到一个数组中的时候直接使用map就会更加的方便。在map()中return无论如何都会返回一个数组，可以通过return来对原数组进行操作返回一个新数组12345678 var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]; console.log(arr.map(item =&gt; &#123; return true; //[[true, true, true, true, true, true, true, true, true]]&#125;)); console.log(arr.map(item =&gt; &#123; return item*2; //[2, 4, 6, 8, 10, 12, 14, 16, 18]&#125;)); some()some() 方法用于检测数组中的元素是否满足指定条件（函数提供）。 some() 方法会依次执行数组的每个元素： 如果有一个元素满足条件，则表达式返回true , 剩余的元素不会再执行检测。 如果没有满足条件的元素，则返回false。注意： some() 不会对空数组进行检测。 注意： some() 不会改变原始数组。 也就是说some并不一定会遍历完数组中全部的元素，当遍历到由符合条件的元素时就会返回true并终止，否则返回false，所以也就可以通过利用此特性来对数组中特定一部分的元素进行操作。 123456var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];console.log(arr.some(item =&gt; &#123; // 通过some可以对数组中符合要求的之前的元素进行操作 console.log(item); return item &gt; 5; //可以通过return来设置返回值的条件&#125;)); 还有一个相对的方法叫做 every() ,条件时数组中所有的元素都满足条件。 find()find() 方法返回通过测试（函数内判断）的数组的第一个元素的值。 find() 方法为数组中的每个元素都调用一次函数执行： 当数组中的元素在测试条件时返回 true 时, find() 返回符合条件的元素，之后的值不会再调用执行函数。 如果没有符合条件的元素返回 undefined注意: find() 对于空数组，函数是不会执行的。 注意: find() 并没有改变数组的原始值。 123456var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];console.log(arr.find(item =&gt; &#123; // 通过find也可以对数组中符合要求的之前的元素进行操作 console.log(item); return item&gt;5;&#125;)); findIndex()findIndex() 方法返回传入一个测试条件（函数）符合条件的数组第一个元素位置。 findIndex() 方法为数组中的每个元素都调用一次函数执行： 当数组中的元素在测试条件时返回 true 时, findIndex() 返回符合条件的元素的索引位置，之后的值不会再调用执行函数。 如果没有符合条件的元素返回 -1注意: findIndex() 对于空数组，函数是不会执行的。 注意: findIndex() 并没有改变数组的原始值。 与find方法类似，区别只在于这个方法返回的时元素在数组中的索引。 12345var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];console.log(arr.findIndex(item =&gt; &#123; console.log(item); return item&gt;5; &#125;)); filter()filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。 注意： filter() 不会对空数组进行检测。 注意： filter() 不会改变原始数组。 这个方法与map方法类似，map方法没有返回的条件，而这个方法可以直接通过rerun来设置过滤条件。1234var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];console.log(arr.filter(item =&gt; &#123; return item &gt;2&#125;)); includes()这个方法是es6中新增的一个方法，可以用来判断一个数组或者是字符串中是否包含某一元素，如果是返回 true，否则false。 语法arr.includes(searchElement)arr.includes(searchElement, fromIndex) 参数searchElement 必须。需要查找的元素值。fromIndex 可选。从该索引处开始查找 searchElement。如果为负值，则按升序从 array.length + fromIndex 的索引开始搜索。默认为 0。 12var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];console.log(arr.includes(5)); //true 总结以前只是对这些方法有了解，但是了解的不是很多，也会使用foreach这样的方法，但是现在知道了这么多方法，就应该在适当的情况下用相应的方法来减少代码量和工作量。]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue.js的学习（六）v-if和v-show]]></title>
    <url>%2F2019%2F06%2F16%2Fvue-js%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AD%EF%BC%89v-if%E5%92%8Cv-show%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这次来学习vue中隐藏元素的两种方法，一种是v-if，另一种是v-show，同时明白二者之间的区别，一件分别适用于哪种情况。 示例1234567891011121314151617181920212223242526272829&lt;body&gt; &lt;div id="app"&gt; &lt;!-- 通过两种方式都可以实现元素的隐藏，但是我们从控制台检查元素就可以看出二者之间的区别 --&gt; &lt;button @click="flag=!flag"&gt;点击显示/不显示&lt;/button&gt; &lt;p v-if="flag"&gt; 这是用v-if控制的元素 &lt;/p&gt; &lt;p v-show="flag"&gt; 这是用v-show控制的元素 &lt;/p&gt; &lt;/div&gt; &lt;script src="./../../js/vue.js"&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#app', data() &#123; return &#123; flag:true, &#125; &#125;, methods: &#123; toggle ()&#123; this.flag=!this.flag; &#125; &#125;, &#125;) &lt;/script&gt;&lt;/body&gt; 通过以上代码，我们在页面中单击切换按钮就可以隐藏或者显示两个分别被v-if和v-show控制的元素。 二者之间的区别 通过检查元素我们可以清除的看到，当我们将元素进行隐藏的时候，v-if是将元素进行删除，而v-show是将元素的display设置为none，从而将元素隐藏。 那么我们什么时候用v-if什么时候用v-show呢 因为v-if是将元素进行添加和删除，所以在进行这个过程的时候会比较消耗资源，所以不推荐在频繁要触发v-if的时候使用 而v-show是设置元素的display，那么无论元素一开始是否显示在页面上都需要创建元素，所以在渲染页面的时候会相较于v-if更加占用资源，所以不推荐在很少需要用到v-show来进行切换的时候使用。 学到的一些新东西当我们需要频繁的在两种状态之间进行切换的时候我们可以使用下面这种方法来控制1flag:true, 1this.flag=!this.flag; 就不需要像以前的思路那样设置一个数字的循环，然后判断是否能被2整除来进行两种状态之间的切换。 当函数的代码连非常的小的时候我们就可以直接在调用的时候写，像下面这样：1&lt;button @click=&quot;flag=!flag&quot;&gt;点击显示/不显示&lt;/button&gt; 总结二者之间的区别在于渲染的方式不一样，在切换不频繁的情况下使用v-if，在切换频繁的情况下使用v-show]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue.js的学习（五）v-for 和key]]></title>
    <url>%2F2019%2F06%2F16%2Fvue-js%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89v-for%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这次学习一下vue中的循环v-for和key,以及通过他们来遍历数组以及遍历对象并且将他们渲染到页面中. v-for的使用12345678910111213141516171819202122232425262728293031&lt;body&gt;&lt;div id="app"&gt; &lt;!-- 遍历数组 --&gt; &lt;p v-for="(item, index) in arr"&gt; 数组中的值是:&#123;&#123;item&#125;&#125;---索引是:&#123;&#123;index&#125;&#125; &lt;/p&gt; &lt;br&gt; &lt;!-- 遍历对象 --&gt; &lt;p v-for="(item, key, index) in obj "&gt; &#123;&#123;key&#125;&#125;---&#123;&#123;item&#125;&#125;---索引是:&#123;&#123;index&#125;&#125; &lt;/p&gt;&lt;/div&gt; &lt;script src="./../../js/vue.js"&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue(&#123; el:'#app', data() &#123; return &#123; arr:[1,2,3,4,5,6], obj:&#123; name:'zs', age:18, gender:'男' &#125; &#125; &#125;, &#125;) &lt;/script&gt;&lt;/body&gt; 可以看出v-for的使用非常的简单 在遍历数组的时候传递两个参数，那么第一个参数就是数组里面的值，第二个参数就是索引 123&lt;p v-for=&quot;(item, index) in arr&quot;&gt; 数组中的值是:&#123;&#123;item&#125;&#125;---索引是:&#123;&#123;index&#125;&#125; &lt;/p&gt; 遍历对象的时候，传递两个参数，那么第一个参数是对象键值对中的值，第二个参数是对象中的键，如果有第三个参数那么第三个参数就是索引 123&lt;p v-for=&quot;(item, key, index) in obj &quot;&gt; &#123;&#123;key&#125;&#125;---&#123;&#123;item&#125;&#125;---索引是:&#123;&#123;index&#125;&#125;&lt;/p&gt; key的使用在遍历的时候可以不加key1&lt;p v-for=&quot;(item, index) in items&quot;&gt;&lt;/p&gt; 也可以加key1&lt;p v-for=&quot;(item, index) in items&quot; :key=&quot;index&quot;&gt;&lt;/p&gt; 那么二者之间有什么区别呢，在我上面的例子中没有什么区别， 具体的区别可以参考 这个帖子 。解释的十分形象 注意：key最好是唯一标识符1&lt;p v-for=&quot;(item, index) in items&quot; :key=&quot;index&quot;&gt;&lt;/p&gt; 并且最好不要像这样设置，因为在排序的时候索引也是跟着一起在变化的，那像这样设置了基本上也等于没设置。]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue.js的学习（四）添加样式]]></title>
    <url>%2F2019%2F06%2F16%2Fvue-js%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89%E6%B7%BB%E5%8A%A0%E6%A0%B7%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这次学习了通过vue来给元素添加样式,前面我们已经学习过了给元素绑定属性,我们就可以通过这种方法来给元素添加样式.主要通过两种方法,一种是给元素绑定class,一种是给元素绑定style. 先看页面代码:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;style&gt;.big&#123; font-size: 40px;&#125;.color&#123; color: red;&#125;.thin&#123; font-weight: 200;&#125;&lt;/style&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;!-- 第一种添加样式类 ,注意要加引号--&gt; &lt;p :class="['big','thin']"&gt;这是一段测试文字&lt;/p&gt; &lt;!-- 第二种 数组中嵌套对象，通过对象来控制是否引用相应的类 ,在对象中可以省略引号，除非有 - --&gt; &lt;p :class="['big',&#123;thin:true,color:flag&#125;]"&gt;这是一段测试文字&lt;/p&gt; &lt;!-- 第三种，直接使用对象 --&gt; &lt;p :class="&#123;thin:true,big:flag&#125;"&gt;这是一段测试文字&lt;/p&gt; &lt;!-- 也可以直接在变量中写对象,直接调用变量 --&gt; &lt;p :class="mclass"&gt;这是一段测试文字&lt;/p&gt; &lt;!-- 通过绑定style来添加样式 --&gt; &lt;p :style="&#123;color:'red','font-size':'40px'&#125;"&gt;这是一段测试文字&lt;/p&gt; &lt;p :style="mstyle"&gt;这是一段测试文字&lt;/p&gt; &lt;p :style="[mstyle,mstyle2]"&gt;这是一段测试文字&lt;/p&gt; &lt;/div&gt; &lt;script src="./../../js/vue.js"&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue(&#123; el:'#app', data:&#123; flag:true, mclass:&#123; thin:true, color:true, big:true, &#125;, mstyle:&#123; color:'red', 'font-size':'40px', 'font-weight':200, &#125; &#125;, methods: &#123; &#125;, &#125;) &lt;/script&gt;&lt;/body&gt; 绑定class来添加样式通过数组通过给元素绑定class来添加样式:1&lt;p :class=&quot;[&apos;big&apos;,&apos;thin&apos;]&quot;&gt;这是一段测试文字&lt;/p&gt; 给通过给class绑定一个数组来添加class样式 注意,数组里面的元素都需要加上引号 通过数组中嵌套对象1&lt;p :class=&quot;[&apos;big&apos;,&#123;thin:true,color:flag&#125;]&quot;&gt;这是一段测试文字&lt;/p&gt; 通过对象来添加class需要通过true或者是false来控制是否绑定相应class类 这里可以直接给true或者是false也可以通过变量来传递true或者是false,比如这里通过了一个变量flag 通过对象既然可以通过数组中嵌套对象,那么就可以直接使用对象来绑定class1&lt;p :class=&quot;&#123;thin:true,big:flag&#125;&quot;&gt;这是一段测试文字&lt;/p&gt; 直接通过对象来绑定class也可以将对象设置在一个变量中,通过直接绑定这个变量也可以实现.1&lt;p :class=&quot;mclass&quot;&gt;这是一段测试文字&lt;/p&gt; 在对象中的键值对中的键可以加引号也可以不加引号,但是名字中有-就必须要加引号. 绑定style来添加样式 通过对象来设置: 1&lt;p :style=&quot;&#123;color:&apos;red&apos;,&apos;font-size&apos;:&apos;40px&apos;&#125;&quot;&gt;这是一段测试文字&lt;/p&gt; 将对象设置到变量通过变量来设置 1&lt;p :style=&quot;mstyle&quot;&gt;这是一段测试文字&lt;/p&gt; 通过数组来同时设置多个变量 1&lt;p :style=&quot;[mstyle,mstyle2]&quot;&gt;这是一段测试文字&lt;/p&gt; 来看看设置之后的效果可以看到全部都生效了 总结以上就是在vue中设置样式的一些方法]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue.js的学习（三）数据的双向绑定]]></title>
    <url>%2F2019%2F06%2F16%2Fvue-js%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这次来学习vue中的双向数据绑定的一种方法，使用v-model来进行数据的双向绑定，并通过其来实现一个超级简单的计算器。 v-model通过v-model可以实现数据的双向绑定，我们前面学习过的v-text以及v-html都只能是实现数据的单项绑定，就是将M绑定到V，有时候需要实现数据的双向绑定，这个时候就需要用到v-model来实现，基本的用法：1&lt;input v-model="n1" type="text"&gt; 指的注意的一件事情就是v-model只对表单有效，对其他元素无效，因为其他元素无法双向修改数据，只有表单可以做到用户可以修改其中的数据。 通过v-model来实现一个简单的计算器12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;body&gt; &lt;div id="app"&gt; &lt;input v-model="n1" type="text"&gt; &lt;select v-model="sign" name="" id=""&gt; &lt;option value="+"&gt;+&lt;/option&gt; &lt;option value="-"&gt;-&lt;/option&gt; &lt;option value="*"&gt;*&lt;/option&gt; &lt;option value="/"&gt;/&lt;/option&gt; &lt;/select&gt; &lt;input v-model="n2" type="text"&gt; &lt;button @click="compute"&gt;=&lt;/button&gt; &lt;input v-model="res" type="text"&gt; &lt;/div&gt; &lt;script src="./../../js/vue.js"&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue(&#123; el:'#app', data:&#123; n1:0, n2:0, sign:'+', res:0, &#125;, methods: &#123; compute () &#123; // 这是一种方法，使用switch来判断条件 switch (this.sign)&#123; case "+" : this.res= parseFloat(this.n1) + parseFloat(this.n2); break; case "-" : this.res= parseFloat(this.n1) - parseFloat(this.n2); break; case "*" : this.res= parseFloat(this.n1) * parseFloat(this.n2); break; case "/" : this.res= parseFloat(this.n1) / parseFloat(this.n2); break; &#125; // 还有一种投机取巧的办法，但是不推荐使用 // var str=this.n1+this.sign+this.n2; // this.res=eval(str); &#125; &#125;, &#125;) &lt;/script&gt;&lt;/body&gt; 写的时候要注意不要把this给忘了。 通过两种方法都能成功实现了一个简单的计算器。 但是要注意的一件事情是尽量不要使用第二种方法，因为第二种方法中使用的eval()函数会将字符串解析成代码，所以其实这是很不安全的一件事情，坏人就有机可乘可以搞破坏。 总结这次学习的是vue中的v-model,使用这个方法可以十分轻松的实现数据的双向绑定。]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue.js的学习（二）事件修饰符]]></title>
    <url>%2F2019%2F06%2F16%2Fvue-js%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这次的笔记来学些一下vue中的事件修饰符，通过事件修饰符可是实现一些简单的功能，比如阻止冒泡之类的。 一下是一段运用了事件修饰符的代码：12345678910111213141516171819202122232425262728293031323334&lt;style&gt;div&#123; padding: 50px;&#125;&lt;/style&gt;&lt;body&gt; &lt;div @click='outerclick' id="app" style="background-color: blue"&gt; &lt;div @click='innerclick' style="background-color: red"&gt; &lt;button @click='btnclick'&gt;这是一个测试按钮&lt;/button&gt; &lt;/div&gt; &lt;a @click.prevent.once href="https://www.baidu.com"&gt;这是去百度的链接&lt;/a&gt; &lt;/div&gt; &lt;script src="./../../js/vue.js"&gt;&lt;/script&gt; &lt;script&gt; var vm=new Vue(&#123; el:'#app', data:&#123;// 通过在data中设置变量 msg:'这是一个测试内容', &#125;, methods: &#123; btnclick()&#123; alert('这是一个按钮'); &#125;, innerclick()&#123; alert('这是里面的div') &#125;, outerclick()&#123; alert('这是外面的div') &#125; &#125;, &#125;) &lt;/script&gt;&lt;/body&gt; .stop 通过.stop可以阻止事件向上冒泡 1&lt;button @click.stop=&apos;btnclick&apos;&gt;这是一个测试按钮&lt;/button&gt; 我们只需要这样设置就可以阻止事件向上冒泡 .self 通过.self可以阻止事件向上冒泡1&lt;div @click.self=&apos;innerclick&apos; style=&quot;background-color: red&quot;&gt; 我们只需要这样设置就使这个里面的div在按钮进行事件冒泡的时候不会触发它的单击事件，只会触发自己的事件。 .prevent通过.prevent就可以阻止默认行为1&lt;a @click.prevent href=&quot;https://www.baidu.com&quot;&gt;这是去百度的链接&lt;/a&gt; 通过以上代码就可以实现阻止默认行为，但我们单击超链接的时候就不会进行跳转 .once通过.once就可以使事件修饰符只起作用一次1&lt;a @click.prevent.once href=&quot;https://www.baidu.com&quot;&gt;这是去百度的链接&lt;/a&gt; 通过以上代码，当我们单击超链接的时候第一次不会进行跳转，但是再次单击的时候就会进行跳转了 其他事件修饰符也适用 总结这次学习了vue中的事件修饰符]]></content>
  </entry>
  <entry>
    <title><![CDATA[通过vue做一个简单的跑马灯]]></title>
    <url>%2F2019%2F06%2F15%2F%E9%80%9A%E8%BF%87vue%E5%81%9A%E4%B8%80%E4%B8%AA%E8%B7%91%E9%A9%AC%E7%81%AF%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前面简单的学习了vue中的一些简单的东西以及入门，这次通过vue来做一个简单的跑马灯来试一试. 实现原理其实实现原理非常的简单，只需要将我们需要跑起来的字符串的首个字符拼接到字符串尾部，再通过定时器将新的字符串渲染到页面就可以了，只不过这些都是通过vue框架来实现的。 代码12345678910111213141516171819202122232425262728293031323334&lt;body&gt; &lt;div v-cloak id="app"&gt; &lt;button @click='pmd'&gt;跑起来&lt;/button&gt; &lt;button @click='stoppmd'&gt;停止&lt;/button&gt; &lt;p v-text="msg"&gt; &lt;/p&gt; &lt;/div&gt; &lt;script src="./../../js/vue.js"&gt;&lt;/script&gt; &lt;script&gt; var vm=new Vue(&#123; el:'#app', data:&#123;// 通过在data中设置变量 msg:'这是一个测试内容', timer:null,//通过timer这个变量来控制只有第一次单击有效 &#125;, methods: &#123; pmd()&#123; if(this.timer!=null) return ; //如果timer为null，那么就直接调出函数 this.timer=setInterval(() =&gt; &#123; var start=this.msg.substr(0,1); var end=this.msg.substr(1); this.msg=end+start; // console.log(this.msg); &#125;, 500); &#125;, stoppmd()&#123; clearInterval(this.timer); this.timer=null; &#125; &#125;, &#125;) &lt;/script&gt;&lt;/body&gt; 学习到的一些知识以及遇到的一些问题 学习到的第一个就是箭头函数，通过使用es6中的箭头函数就可以解决this的问题，就不用重新去指定this 第二个就是return的使用，过去我只知道return只能够返回函数值，现在我知道了return不仅仅能够返回函数值，还能够提前跳出函数返回函数值，配合条件表达式就能很好的实现一些功能。 第三个就是可以设置一个变量将定时器函数传给这个变量，然后就可以通过比如清除函数来清空定时器之类的以及重新开启定时器。 遇到的一些问题一个就是对象中的this的指向问题，如果是对象中定义的方法，就可以直接通过this拿到当前对象，但是如果在对象中的方法中调用了其他方法，并在这个方法中写函数的话，那么这个时候的this就指向调用的外部函数，如果要重新让this指向对象就需要在自己定义的方法中声明this=this，或者使用es6中的箭头函数。 总结在这次的学习中学习到很多es6中的新知识，下次要系统的完整的去学习es6中的知识。]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue.js的学习（一）]]></title>
    <url>%2F2019%2F06%2F15%2Fvue-js%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最近开始学习现在最火的前端开发框架vue.js，这篇博客记录我的学习过程以及学习笔记。 vue.js的使用先去官网下载好vue.js的文件，然后在项目中引入js文件就可以开始使用vue来进行开发了，例如这样：1&lt;script src="./../../js/vue.js"&gt;&lt;/script&gt; 然后这是一个vue的基本模板：123456789101112131415&lt;body&gt; &lt;!-- 这是一个普通的块 --&gt; &lt;div v-cloak id="app"&gt; &lt;/div&gt; &lt;script src="./../../js/vue.js"&gt;&lt;/script&gt; &lt;script&gt; var vm=new Vue(&#123; el:'#app',// 在vue中对id为app的元素进行操作 data:&#123;//这里面写数据 &#125;, methods: &#123;//这里面写各种方法 &#125;, &#125;) &lt;/script&gt;&lt;/body&gt; 插值表达式和v-text在vue中想要对元素输入数值是非常简单的，不需要通过js或者jQuery拿到对象再通过函数进行传入数据，直接在dom元素中直接通过插值表达式就可以将vue中data中的值给到dom元素中。比如这样： 通过插值表达式123&lt;div v-cloak id="app"&gt; &#123;&#123;msg&#125;&#125;12314&lt;/div&gt; 123456789var vm=new Vue(&#123; el:'#app', data:&#123; //这里定义一个变量来我们想要的值 msg:'这是一个测试' &#125;, methods: &#123; &#125;, &#125;) 我们只需要通过插值表达式将我们创建的vue对象中的data中的变量写到dom元素中就可以将变量渲染出来。 可以看到我们定义的变量的值成功被渲染出来了 但是注意这样会有一个问题，就是在网速较慢的时候vue.js这个文件就会加载的比较慢，那么插值表达式就不会生效，而是直接将整个表达式当做字符串输出出来，那么这个时候我们可以通过给相应的dom元素加上v-cloak,然后再设置样式123[v-cloak] &#123;display: none;&#125; v-text使用v-text也可以将数据渲染到dom元素，但是用法不一样12 &lt;div v-text="msg+'123423'" id="app"&gt;&lt;/div&gt; 这样就可以实现了插值表达式一样的效果了。 注意：v-text 后面可以通过+来拼接字符串 v-html这个用法和v-text一致，作用也相似，只是v-html可以解析html标签，但是v-text不能 12&lt;div v-html="msg+'123423'" id="app"&gt;&lt;/div&gt; v-bindv-bind可以给dom元素绑定属性值 v-bind可以简写成: 123&lt;div v-cloak id="app"&gt; &lt;input type="button" value="这是一个按钮" v-bind:title="mtitle"&gt;&lt;/div&gt; 123456789var vm=new Vue(&#123; el:'#app', data:&#123; msg:'这是一个测试', mtitle:'这是一个测试' &#125;, methods: &#123; &#125;, &#125;) 可以看到，成功给这个按钮加上了一个我们在vue中定义的title v-bind:title=后面跟的是一个变量，所以后面也是可以拼接字符串的，许多vue中的属性也都是如此 v-onv-on与v-bind类似，只不过绑定的不是dom元素的属性，而是各种事件， v-on可以简写成@ 123&lt;div v-cloak id="app"&gt; &lt;button @click="mclick"&gt;这又是一个按钮&lt;/button&gt;&lt;/div&gt; 123456789101112var vm=new Vue(&#123; el:'#app', data:&#123; msg:'这是一个测试', mtitle:'这是一个测试' &#125;, methods: &#123; mclick () &#123; alert('单击了这个按钮'); &#125; &#125;,&#125;) 可以看到成功触发了我们自己定义的单击事件。 总结这篇博客记录学习了vue最简单初始的一些东西，一个小小的入门。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Chrome-调试大全]]></title>
    <url>%2F2019%2F06%2F15%2FChrome-%E8%B0%83%E8%AF%95%E5%A4%A7%E5%85%A8%2F</url>
    <content type="text"><![CDATA[引言 原文出处：&nbsp;&nbsp;&nbsp;&nbsp;Cayley的编程之路“工欲善其事，必先利其器” 没错，这句话个人觉得说的特别有道理，举个例子来说吧，厉害的化妆师都有一套非常专业的刷子，散粉刷负责定妆，眼影刷负责打眼影，各司其职，有了专业的工具才能干专业的事，这个灵感要来源于之前我想买化妆品时，店里的海报标语，由此联想到，如果你想在某个事情上做好，并且做的专业，那么你一定要把你的工具用好，这样才能事半功倍，我见过很多师兄师姐，写了很多代码，能够很快的完成工作，能够处理很多复杂的业务逻辑，但是对于浏览器的调试掌握的并不全面和深入，说说本姑娘吧，我的编程调试起源于自学滴前端课程，因为学习的时候看的都是基础的教学视频，对于调试也只是掌握了alert和console, 请大家别笑话，认真看完再说话，试问谁当初入门时候不是走的这条路呢，当你不再限于做静态页面，古老而经典的调试方式肯定不能帮你完成日常调试，日后我进入到了大公司去实习，才真正开始接触专业开发业务，开始跟着师兄和师傅一起上路，那时我才有了“js断点调试“的意识，开始一步步调试我的js代码~ 下面总结一下一些常用调试方法，这些方法能让开发的工作顺利并且高效，这里小女子拿出来总结一下，与各位程序猿同仁分享一下 ~ （此处应有掌声…… ^_^）一. 先来认识一下这些按钮 先来看这张图最上头的一行是一个功能菜单，每一个菜单都有它相应的功能和使用方法，依次从左往右来看 1.箭头按钮：用于在页面选择一个元素来审查和查看它的相关信息，当我们在Elements这个按钮页面下点击某个Dom元素时，箭头按钮会变成选择状态2.设备图标：点击它可以切换到不同的终端进行开发模式，移动端和pc端的一个切换，可以选择不同的移动终端设备，同时可以选择不同的尺寸比例，chrome浏览器的模拟移动设备和真实的设备相差不大，是非常好的选择 可选择的适配 3.Elements&nbsp;功能标签页：用来查看，修改页面上的元素，包括DOM标签，以及css样式的查看，修改，还有相关盒模型的图形信息，下图我们可以看到当我鼠标选择id 为lg_tar的div元素时，右侧的css样式对应的会展示出此id 的样式信息，此时可以在右侧进行一个修改，修改即可在页面上生效， 灰色的element.style样式同样可以进行添加和书写，唯一的区别是，在这里添加的样式是添加到了该元素内部，实现方式即：该div元素的style属性，这个页面的功能很强大，在我们做了相关的页面后，修改样式是一块很重要的工作，细微的差距都需要调整，但是不可能说做到每修改一点即编译一遍代码，再刷新浏览器查看效果，这样很低效，一次性在浏览器中修改之后，再到代码中进行修改 对应的样式 盒模型信息 同时，当我们浏览网站看到某些特别炫酷的效果和难做的样式时候，打开这个功能，我们即可看到别人是如何实现的，学会它这知识就是你的了，仔细钻研也会有意想不到的收获4.Console控制台：用于打印和输出相关的命令信息，其实console控制台除了我们熟知的报错，打印console.log信息外，还有很多相关的功能，下面简单介绍几个：a: 一些对页面数据的指令操作，比如打断点正好执行到获取的数据上，由于数据都是层层嵌套的对象，这个时候查看里面的key/value不是很方便，即可用这个指令开查看，obj的json string 格式的key/value，我们对于数据里面有哪些字段和属性即可一目了然 其他功能 b: 除了console.log还有其他相关的指令可用 console也有相关的API 5.Sources&nbsp;js资源页面：这个页面内我们可以找到当然浏览器页面中的js 源文件，方便我们查看和调试，在我还没有走出校园时候，我经常看一些大站的js代码，那时候其实基本都看不懂，但是最起码可以看看人家的代码风格，人家的命名方式，所有的代码都是压缩之后的代码，我们可以点击下面的{}大括号按钮将代码转成可读格式Sources Panel 的左侧分别是 Sources 和 Content scripts和Snippets 对应的源代码 格式化后的代码 关于打断点调试的内容，下面介绍，先来说一些，其他平时基本没人用但是很有用的小点，比如当我们想不起某个方法的具体使用时候，会打开控制台随意写一些测试代码，或者想测试一下刚刚写的方法是否会出现期待的样子，但是控制台一打回车本想换行但是却执行刚写的半截代码，所以推荐使用Sources下面的左侧的Sinppets代码片段按钮，这时候点击创建一个新的片段文件，写完测试代码后把鼠标放在新建文件上run，再结合控制台查看相关信息（新建了一个名叫：app.js的片段代码，在你的项目环境页面内，该片段可执行项目内的方法） 自己书写的片段 Content scripts 是 Chrome 的一种扩展程序，它是按照扩展的ID来组织的，这些文件也是嵌入在页面中的资源，这类文件可以读写和操作我们的资源，需要调试这些扩展文件，则可以在这个目录下打开相关文件调试，但是几乎我们的项目还没有相关的扩展文件，所以啥也看不到，平时也不需要关心这块 无结果 6.Network&nbsp;网络请求标签页：可以看到所有的资源请求，包括网络请求，图片资源，html,css，js文件等请求，可以根据需求筛选请求项，一般多用于网络请求的查看和分析，分析后端接口是否正确传输，获取的数据是否准确，请求头，请求参数的查看 所有的资源 以上我选择了All，就会把该页面所有资源文件请求下来，如果只选择XHR 异步请求资源，则我们可以分析相关的请求信息 请求的相关信息 打开一个Ajax异步请求，可以看到它的请求头信息，是一个POST请求，参数有哪些，还可以预览它的返回的结果数据，这些数据的使用和查看有利于我们很好的和后端工程师们联调数据，也方便我们前端更直观的分析数据 预览请求的数据 7.Timeline标签页可以显示JS执行时间、页面元素渲染时间，不做过多介绍8.Profiles标签页可以查看CPU执行时间与内存占用，不做过多介绍9.Resources标签页会列出所有的资源，以及HTML5的Database和LocalStore等，你可以对存储的内容编辑和删除 不做过多介绍10.Security标签页 可以告诉你这个网站的安全性，查看有效的证书等11.Audits标签页 可以帮你分析页面性能，有助于优化前端页面，分析后得到的报告 分析结果 二.Sources资源页面的断点调试1.如何调试：调试js代码，肯定是我们常用的功能，那么如何打断点，找到要调试的文件，然后在内容源代码左侧的代码标记行处点击即可打上一个断点 2.断点与 js代码修改看下面这张图，我在一个名为toggleTab的方法下打了两个断点，当开始执行我们的点击切换tab行为后，代码会在执行的断点出停下来，并把相关的数据展示一部分，此时可以在已经执行过得代码处，把鼠标放上去，即可查看相关的具体数据信息，同时我们可以使用右侧的功能键进行调试，右侧最上面一排分别是：暂停/继续、单步执行(F10快捷键)、单步跳入此执行块(F11快捷键)、单步跳出此执行块、禁用/启用所有断点。下面是各种具体的功能区 在代码中打断点 在当前的代码执行区域，在调试中如果发现需要修改的地方，也是可以立即修改的，修改后保存即可生效，这样就免去了再到代码中去书写，再刷新回看了 临时修改 3.快速进入调试的方法当我们的代码执行到某个程序块方法处，这个方法上可能你并没有设置相关的断点，此时你可以F11进入此程序块，但是往往我们的项目都是经过很多源代码封装好的方法，有时候进入后，会走很多底层的封装方法，需要很多步骤才能真正进入这个函数块，此时将鼠标放在此函数上，会出现相关提示，会告诉你在该文件的哪一行代码处，点击即可直接看到这个函数，然后临时打上断点，按F10或者点击右上角的第二个按钮即可直接进入此函数的断点处 4.调试的功能区域每一个功能区，都有它相关的左右，先来看一张图，它都有哪些功能 Call Stack调用栈：当断点执行到某一程序块处停下来后，右侧调试区的 Call Stack 会显示当前断点所处的方法调用栈，从上到下由最新调用处依次往下排列，Call Stack 列表的下方是Scope Variables列表可以查看此时局部变量和全局变量的值。图中可以看出，我们最先走了toggleTab这个方法，然后走到了一个更新对象的方法上，当前调用在哪里，箭头会帮你指向哪里，同时我们可以点击，调用栈列表上的任意一处，即可回头再去看看代码 但是若你想从新从某个调用方法出执行，可以右键Restart Frame， 断点就会跳到此处开头重新执行，Scope&nbsp;中的变量值也会依据代码从新更改，这样就可以回退来从新调试，错过的调试也可以回过头来反复查看 Breakpoints关于断点：所有当前js的断点都会展示在这个区域，你可以点击按钮用来“去掉/加上”此处断点，也可以点击下方的代码表达式，调到相应的程序代码处，来查看 XHR Breakpoints在XHR Breakpoints处，点击右侧的+号，可以添加请求的URL，一旦 XHR 调用触发时就会在 request.send() 的地方中断 DOM Breakpoints:可以给你的DOM元素设置断点，有时候真的需要监听和查看某个元素的变化情况，赋值情况，但是我们并是不太关心哪一段代码对它做的修改，只想看看它的变化情况，那么可以给它来个监听事件，这个时候DOM Breakpoints中会如图 当要给DOM添加断点的时候，会出现选择项分别是如下三种修改1.子节点修改2.自身属性修改3.自身节点被删除。选中之后，Sources Panel 中右侧的 DOM Breakpoints 列表中就会出现该 DOM 断点。一旦执行到要对该 DOM 做相应修改时，代码就会在那里停下来Event listener Breakpoints&nbsp;最后Event Listener 列表，这里列出了各种可能的事件类型。勾选对应的事件类型，当触发了该类型的事件的 JavaScript 代码时就会自动中断三.Post man你值得拥有的网络请求神器在我们的开发过程中，后端的接口都是由发起AJAX请求而获取到的相关数据，但是很多情况是我们的业务还没有做到那块时，后端的同学接口都已经准备好了，但是为了便于后期的工作，将接口请求的数据模拟访问，然后对接口联调很重要，也很方便，因为我们不可能把每个请求代码都写到文件里编译好了再去浏览器内查看，这时候可以安装一个post man网络请求插件，在谷歌应用商店下载，需要翻墙 该扩展程序使用非常简单，功能同时也非常强大，输入你的请求，选择好请求的method，需要请求参数的挨个填好，send之后，就可以看到返回的数据，这个小工具很利于我们的开发 完结写到这里这篇总结就结束了，也许有很多写的不到位的地方，也有一些专业用词不严谨的地方，希望看到的读者可以和我一起交流，我也非常乐意我的总结可以给 刚刚学会编程需要调试的同学受用，再此之前我一直在寻找一篇从头到尾的调试教学文章，我一直没有找到，要么是一点点的片段讲解，要么是专讲js断点调试，所以索性后来就直接看了 Chrome Developer Tools 的英文官方文档，并结合自己的一些小使用心得总结出此文，希望受到指点和修正 也希望可以帮助一些同学~]]></content>
  </entry>
  <entry>
    <title><![CDATA[Bootstrap4与Bootstrap3的区别]]></title>
    <url>%2F2019%2F06%2F14%2FBootstrap4%E4%B8%8EBootstrap3%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;刚接触bootstrap是学习的b3，但是b4已经出来了有一段时间了，而且试过b4之后我更加的喜欢b4，因为二者之间还是有很多差别的，所以这里介绍一下二者的差别。 Bootstrap4特点 新增网格层适配了移动端； 全面引入ES6新特性（重写所有JavaScript插件）； css文件减少了至少40%； 所有文档都用Markdown编辑器重写； 放弃对IE8的支持 Bootstrap3 Bootstrap4 Less Sass语言编写 4种栅格类 5种栅格类 使用px为单位 使用rem和em为单位（除部分margin和padding使用px） 使用push和pull向左右移动 偏移列通过offset-类设置 使用float的布局方式 选择弹性盒模型（flexbox） 栅格系统方面的区别Bootstrap3的4种栅格： 特小（col-xs-） 适配手机(&lt;768px) 小（col-sm-） 适配平板(≥768px) 中（col-md-） 适配电脑(≥992px) 大（col-lg-） 适配宽屏电脑(≥1200px) Bootstrap4的5种栅格： 特小（col-）(&lt;576px) 小（col-sm-）(≥576px) 中（col-md-）(≥768px) 大（col-lg-） (≥992px) 特大（col-xl-）（≥1200px） 一些类方面的区别img-circle与新版本中的rounded-circle老版本中img-circle只对图片 而新版本中rounded-circle对所有元素全部生效 媒体对象去除了media-left media-right 只有media-body 在其中会自适应 在body前写一个图片即使left,在body之后便是right display系列 / 偏移 / 外边距 / 内边距 用d-xx来设置display属性 偏移 不再使用 col-[尺寸]-offset-[x] 而是 offset-[尺寸]-[x] 内外边距可以使用m-5这种方式来书写例如：ml-3 pt-4 并且以上两项都可以通过设置对应分辨率来控制，如：ml-md-3 颜色badge-[] 对应 bs3 label可以设置outline比如btn-outline-success 新增flex类可以通过类来设置flex，名称与css样式的属性相同 导航栏这是bs3的tabs导航栏12345&lt;ul class="nav nav-tabs"&gt; &lt;li role="presentation" class="active"&gt;&lt;a href="#"&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li role="presentation"&gt;&lt;a href="#"&gt;Profile&lt;/a&gt;&lt;/li&gt; &lt;li role="presentation"&gt;&lt;a href="#"&gt;Messages&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; bs4是这样写：12345678&lt;ul class="nav nav-tabs"&gt; &lt;li class="nav-item"&gt; &lt;a class="nav-link active" href="#"&gt;Item 1&lt;/a&gt; &lt;/li&gt; &lt;li class="nav-item"&gt; &lt;a class="nav-link disabled" href="#" tabindex="-1" aria-disabled="true"&gt;Item 2&lt;/a&gt; &lt;/li&gt;&lt;/ul&gt; 可以看出导航的内容中不再需要添加role=&quot;presentation&quot;，并且bs4中使用nav-item来规定导航中的内容 导航栏中使用mr-auto ml-auto m-auto 来使导航栏中的内容居左/右/中]]></content>
  </entry>
  <entry>
    <title><![CDATA[Bootstrap的学习与使用]]></title>
    <url>%2F2019%2F06%2F13%2FBootstrap%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B8%8E%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实学习bootstrap是在写这篇博客很久之前的事情了，但是由于一些其他的很多事情，就没有第一时间写这篇博客，记录关于bootstrap中学习的一些事情。现在来写一下。bootstrap作为现在非常流行的响应式框架，必然是要学习的，起初我对bootstrap的了解并不是很多，只知道这算是一个框架，然后我就在网上看视频跟着学，然后等学习完了就清楚了，bootstrap其实是一个前端的css库，通过调用各种css演示可以很轻松的将一个响应式的网站给搭建起来，其实最另我没有想到的是使用bootstrap框架开发竟然如此便捷，甚至可以几乎不用自己写一点的css演示就可以有一个漂亮美观的页面，其实bootstrap要学的东西不多，大部分在文档中找到相应的使用方法就会用了,这篇博客记录一下我在学习之初所做的一些笔记。 字体图标的使用 bootstrap中有许多的字体图标，但是数量也是有限的，所以我们需要一些自定义的字体图标，图标网站有很多，我比较喜欢去阿里矢量图标库找 参考阿里矢量图标库给的使用文档所提供的三种使用图标的方法： 第一种：Unicode 引用Unicode 是字体在网页端最原始的应用方式，特点是： 兼容性最好，支持 IE6+，及所有现代浏览器。 支持按字体的方式去动态调整图标大小，颜色等等。 但是因为是字体，所以不支持多色。只能使用平台里单色的图标，就算项目里有多色图标也会自动去色。 注意：新版 iconfont 支持多色图标，这些多色图标在 Unicode 模式下将不能使用，如果有需求建议使用symbol 的引用方式 Unicode 使用步骤如下： 第一步：拷贝项目下面生成的 @font-face123456789@font-face &#123; font-family: 'iconfont'; src: url('iconfont.eot'); src: url('iconfont.eot?#iefix') format('embedded-opentype'), url('iconfont.woff2') format('woff2'), url('iconfont.woff') format('woff'), url('iconfont.ttf') format('truetype'), url('iconfont.svg#iconfont') format('svg');&#125; 第二步：定义使用 iconfont 的样式1234567.iconfont &#123; font-family: "iconfont" !important; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;&#125; 第三步：挑选相应图标并获取字体编码，应用于页面1&lt;span class="iconfont"&gt;&amp;#x33;&lt;/span&gt; “iconfont” 是你项目下的 font-family。可以通过编辑项目查看，默认是 “iconfont”。 第二种：font-class 引用font-class 是 Unicode 使用方式的一种变种，主要是解决 Unicode 书写不直观，语意不明确的问题。 与 Unicode 使用方式相比，具有如下特点： 兼容性良好，支持 IE8+，及所有现代浏览器。 相比于 Unicode 语意明确，书写更直观。可以很容易分辨这个 icon 是什么。 因为使用 class 来定义图标，所以当要替换图标时，只需要修改 class 里面的 Unicode 引用。 不过因为本质上还是使用的字体，所以多色图标还是不支持的。使用步骤如下： 第一步：引入项目下面生成的 fontclass 代码：1&lt;link rel="stylesheet" href="./iconfont.css"&gt; 第二步：挑选相应图标并获取类名，应用于页面：1&lt;span class="iconfont icon-xxx"&gt;&lt;/span&gt; “ iconfont” 是你项目下的 font-family。可以通过编辑项目查看，默认是 “iconfont”。 第三种：Symbol 引用这是一种全新的使用方式，应该说这才是未来的主流，也是平台目前推荐的用法。相关介绍可以参考这篇文章 这种用法其实是做了一个 SVG 的集合，与另外两种相比具有如下特点： 支持多色图标了，不再受单色限制。 通过一些技巧，支持像字体那样，通过 font-size, color 来调整样式。 兼容性较差，支持 IE9+，及现代浏览器。 浏览器渲染 SVG 的性能一般，还不如 png。使用步骤如下： 第一步：引入项目下面生成的 symbol 代码：1&lt;script src="./iconfont.js"&gt;&lt;/script&gt; 第二步：加入通用 CSS 代码（引入一次就行）：123456789&lt;style&gt;.icon &#123; width: 1em; height: 1em; vertical-align: -0.15em; fill: currentColor; overflow: hidden;&#125;&lt;/style&gt; 第三步：挑选相应图标并获取类名，应用于页面：123&lt;svg class=&quot;icon&quot; aria-hidden=&quot;true&quot;&gt; &lt;use xlink:href=&quot;#icon-xxx&quot;&gt;&lt;/use&gt;&lt;/svg&gt; 这里用第二种方法与第三种方法做一个演示：可以看到无论用哪种方法都能成功使用到字体图标，既然symbol的方法使未来趋势那就尽量多使用symbol吧，毕竟这种方式还可以支持多色图标 有一件事情要注意，就是在最开始的时候我通过symbol方式去设置图标的颜色发现并不成功，后面查阅资料后发现是因为当我在下载图标代码的时候这个图标本身使带有颜色的，这里有两种办法： 打开js文件，将fill=&quot;#......&quot;删除。 到iconfont.cn上，全选项目中的文件，应用批量操作–&gt;批量去色 当然啦，还有其他的特别多的图标库，像font awesome这种专门为bootstrap设计的之类的，看个人喜好用什么，这里就介绍了引用阿里矢量图标库中的图标 选项卡的适配 当页面的宽度缩小到一定的程度的时候，选项卡中的选项就会换行，有时这不是我们想要的效果，我们想要的效果是当所有选项的宽度之和大于外部的宽度的时候它就会出现一个横向的滚动条 那我们就可以通过overfow ：auto来实现，但是只设置overflow很显然是不能达到这种效果的，因为这个时候当我们把页面的宽度缩小选项卡的头部会进行换行 所以我们还需要使它不进行换行，因为b4相较于b3进行了重写，不再使用float布局而是使用flex布局，所以我们可以通过flex来进行设置不换行，先设置为flex布局，再设置为不换行，这时候就实现了我们想要的效果 1234567891011121314151617181920212223242526272829&lt;style&gt; a &#123; padding-right: 100px !important; &#125; .nav-tabs &#123; /* width: 400px; */ padding-bottom: 1px; margin-top: 0; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;ul class="nav nav-tabs d-flex overflow-auto flex-nowrap"&gt; &lt;li class="nav-item"&gt; &lt;a href="#" class="nav-link active"&gt;Active&lt;/a&gt; &lt;/li&gt; &lt;li class="nav-item"&gt; &lt;a href="#" class="nav-link"&gt;Link&lt;/a&gt; &lt;/li&gt; &lt;li class="nav-item disabled"&gt; &lt;a href="#" class="nav-link"&gt;Disabled&lt;/a&gt; &lt;/li&gt; &lt;li class="nav-item"&gt; &lt;a href="#" class="nav-link active"&gt;Active&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt; 再来看一下实现的效果：成功实现效果！ 一些小笔记 bootstrap自适应的底层是用媒体查询做的通过媒体查询来定义不同分辨率下容器的不同宽度，以及栅栏系统的宽度。 bootstrap是组件化开发，有很多的组件可以使用，包括像各种定义好样式的按钮，各种按钮可以用bbg来生成。 bootstrap中的容器container与container-fluid的作用就是当成一个容器，这个容器自带了响应式的布局。这两个容器的区别就是一个是固定的宽度，一个是百分之百的宽度，container用的比较多.container拥有15px的左右内边距，可以用row来抵消。 多套轮播图的处理在响应式的布局中可能会有两套轮播图，一套显示在pc端，一套显示在手机端，pc端的图片用背景图来处理，只显示中间的那一部分，只有在宽度在拉长的时候会把边上的纯色部分显示出来处理方式是通过 background:no-repeat center center 来将背景图片居中然后通过background-size:cover来让图片显示HTML元素自定义属性的方法是通过data来设置，比如设置 data-name=”hsl” 属性，然后通过jQuery中的data(“name”)就可以拿到我们想要的数据，然后通过 data(“name”,”sss”)就可以设置属性然后就可以通过这种方法来给标签设置属性，再通过jQuery动态的设置图片 在bootstrap中有很多的全局样式，能用bootstrap自带的样式就用自带的（比如颜色） 补充一个css样式的用法，设置背景颜色可以设置trans什么的来继承父级的颜色 使用bootstrap的时候，在布局的时候主要是使用栅格系统，就可以很轻松的将一大块内容分割成我们想要的部分。 bootstrap中的徽章可以用来做圆角边框并且自带颜色 bootstrap中的媒体对象可以用来处理图片加文字的并排情况 在容器栅格布局中尽量不要使用margin，而是使用padding，因为本身12份已经占满了，没有多余的空间来设置margin 使用栅栏系统的时候当满了12列，剩下的就会换行，比如有4个col-md-6,那么这里就会占满两行。 栅格系统中的内容居中的方法有很多，比如可以用text-align或者是flex布局，对于图片来说的话可以使用margin auto 来设置要注意的一点是图片是一个行内元素，不能直接设置上下边距，如果要设置则需要将其设置为块级元素或者是行内块级元素 如果要给整块内容添加超链接直接在内容最外层添加a标签即可 在很多时候可以不用设置高度，而是可以直接通过设置padding值来让内容撑开 在使用bootstrap进行响应式开发的时候一定要注意最外层应该不要设置固定高度，否则在自适应的时候可能会出现问题 通过full-left可以将本来占一行的元素浮动到一行,b4中使用offset-来设置向左或是向右，通过设置display为inline-block也能实现这样的效果 总结学习总结是一个漫长的过程，这篇博客还会持续记录一些问题。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Echarts中响应式的完善]]></title>
    <url>%2F2019%2F06%2F13%2Fecharts%E4%B8%AD%E5%93%8D%E5%BA%94%E5%BC%8F%E7%9A%84%E5%AE%8C%E5%96%84%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前面在学习echarts的时候，发现echarts中是自带响应式的功能的，但是这个响应式的功能和我之前学习的bootstrap有很大的区别，bootstrap中的响应式是会随着网页大小的改变而动态的改变网页的布局以及大小，但是echarts中的响应式虽然也是响应式，但是却没有bootstrap中那样的动态能力，只能是在网页加载或者刷新的时候网页的大小是多大就渲染相应的布局以及大小，虽然也能实现响应式的功能，但是我觉得这在bootstrap中使用的话会很不协调，所以我决定进行一些调整，让echarts中的响应式也能像bootstrap中那样。 开始构建思路起初我以为echarts中的响应式也会像bootstrap中的那样，因为在官网的演示的例子当中就能实现类似的效果，但是我后面发现，那只是官方为了方便演示而加了那样的功能，但是实际上是没有那样的效果的，我开始打算是按照自己的思路写，但是发现遇到很多问题，以及不知道echarts中的定位的实现机制是怎么样的，后面我就查看了一下官方给的示例中的一些代码的变化，随后推断出echarts中的百分比居中是通过对canvas画布的宽度来进行居中的，其他定位也是类似，所以就应该动态的变化canvas画布的宽度以及他父级的宽度，那么就按照这个思路来实现一下吧。 直接看结果 这一部分是用来控制响应式的代码： 123456789101112131415161718192021222324252627282930313233343536$(window).resize(function()&#123; // 先获取到页面中和画布部分有关的元素 // 以及要拿到响应式父级的宽度，并将画布也设置成一样的宽度 var $tw=$('#test').width(); var $fc=$('#test&gt;div:first'); var $canvas=$fc.children(0); $fc.css(&#123; "width":$tw+'px', &#125;); $canvas.css(&#123; "width":$tw+'px', &#125;); $canvas.attr(&#123; "width":$tw*1.25, &#125;) // 然后随着窗口大小的变化去设置图表内容的位置 $mychart.setOption(&#123; media:[ &#123; query:&#123; // maxWidth: 690 &#125;, option:&#123; series:[ &#123; type:'pie', // 这里最好用宽度乘小数来表示，到时候转化为百分比的时候比较方便 center:[$tw*0.5,"50%"] &#125;, ], &#125; &#125;, ] &#125;); &#125;) 这一部分是echarts配置部分的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647var $mychart = echarts.init($('#test')[0]); var option=&#123; baseOption:&#123; legend:&#123;&#125;, tooltip:&#123;&#125;, dataset:&#123; source:[ ['物品', '销量1', '销量2'], ["衬衫", '5', '20'], ['羊毛衫', '30', '40'], ['袜子', '60', '80'], ['裤子', '60', '50'] ] &#125;, series:[ &#123; type:'pie', // center:['50%','50%'] &#125;, ], &#125;, media:[ &#123; query:&#123; // maxWidth: 690 &#125;, option:&#123; legend:&#123; left: ($tw-280)*0.5, &#125;, series:[ &#123; type:'pie', center:['50%','50%'] &#125;, ], &#125; &#125;, ] &#125; $mychart.setOption(option); 这里可以直接先引入响应式部分的代码，再写配置部分的代码。 我所遇到的坑&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在一开始的时候我无从下手，因为没有接触过类似的东西，但是我想了一整天慢慢的整明白了，大概意思就是这他的位置是在生成的时候就固定住了，想要改变就必须通过动态的去设置他的位置，就需要用到resize方法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当时我遇到的第一个比较大的坑就时在我设置canvas宽度的时候我发现好像直接修改style里面的width会导致画布里面的内容失真，使得我在很长一段时间内认为不应该从这里下手，直到我查看了官方示例的代码里的元素变化情况之后我才发现原来是canvas画布本身其实还有一个width属性,且这个属性的值基本上是恒等于style里面的那个的1.25倍，那么真相就大白了，我又开始从这方面着手了。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当时我遇到的第二个比较大的坑就是我认为我只要动态的改变容器的宽度以及canvas画布的宽度，然后再把图表设置为居中或者将center:[&#39;50%&#39;,&#39;50%&#39;]就可以实现一直居中了，后面经过测试没有效果，百思不得其解，不知道我是哪里出了问题，以为是不是哪里写错了，后面我把百分比的位置改为固定的位置之后就发现其实是可以变化的，那么我就推测其实他里面的百分比的位置所算的宽度并不是当前容器或者canvas的宽度，而是在画布生成时就已经固定了，所以我就改成了我现在所用的这种方法。 总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽然成功的实现了我想要的效果，但是还是感觉不是很满意，还应该继续封装以便重复调用，并且解决这个问题花的时间有点多，思维还是不够灵敏，要继续努力。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Echarts.js的学习]]></title>
    <url>%2F2019%2F06%2F08%2F%E5%85%B3%E4%BA%8Eecharts-js%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最近在做期末的课程设计的时候需要做一个后台管理界面，所以需要用到一些图标插件，经过搜索我发现有好多的图标插件，最终我决定要使用echarts.js，其中一个很重要的原因就是它是有国内的百度的团队主导开发的一个项目，所以有中文文档，方便我查阅，文档查阅请看这里 快速上手echarts.js根据官方文档，上手使用echarts.js首先需要先引入js文件，js文件可是直接在官方网站直接下载，在引入js文件之后我们就可以开始使用了，使用之前我们要先创建一个容器，例如：&lt;div class=&quot;container&quot; id=&quot;test&quot; style=&quot;height: 400px;&quot;&gt;接着之后的就是进行初始化，var $mychart=echarts.init($(&#39;#test&#39;)[0]);注意，因为我这里是在jQuery中进行初始化的，但是自带的初始化方法必须传一个原生js对象，所以需要将jQuery对象转化为js对象 然后就可以开始制作图标了：12345678910111213141516171819202122$(function()&#123; var $mychart=echarts.init($('#test')[0]); var option=&#123; title:&#123; text:'这是一个测试的图表' //这是图表的标题 &#125;, tooltip:&#123;&#125;, legend:&#123; data:['销量'] //这个是告诉你表格上所有的数据的类型的那种，也就是右上角的那种东西，现在先这么理解好了，到时候查了文档再详细介绍。 &#125;, xAxis:&#123; data:["衬衫","羊毛衫","袜子"] //这个是x轴坐标，也就是横坐标的值 &#125;, yAxis:&#123;&#125;, series:[&#123; name:'销量', type:'bar', data:[5,30,60] //这里是第一个系列的值 &#125;] &#125;; $mychart.setOption(option); //将图表的设置应用 &#125;) 然后来看一下效果： 再来看看一个官方文档中给出的一个南丁格尔图我通过官方给出的在线编辑工具，一个个试了一下都是什么作用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647option = &#123; backgroundColor: '#2c343c', //这个是设置整个图表的背景颜色的。 visualMap: &#123; //通过visualmap组件来进行明暗度的映射达到一种有层次感的感觉 show: false, //将这个设置为true的话就会出来一个可以选择的小柱子 min: 60, //南丁格尔图每个区域的颜色过渡的最小值 max: 600, //南丁格尔图每个区域颜色过渡的最大值 inRange: &#123; colorLightness: [0, 1] //设置整个南丁格尔图的颜色的亮度 &#125; &#125;, series : [ &#123; name: '访问来源', type: 'pie', radius: '55%', //设置整个图的大小 data:[ &#123;value:235, name:'视频广告'&#125;, //通过键值对的形式来设置数值 &#123;value:274, name:'联盟广告'&#125;, &#123;value:310, name:'邮件营销'&#125;, &#123;value:335, name:'直接访问'&#125;, &#123;value:400, name:'搜索引擎'&#125; ], roseType: 'angle', //将普通的饼图切换成南丁格尔图 label: &#123; normal: &#123; textStyle: &#123; color: 'rgba(255, 255, 255, 0.3)' //文本颜色 &#125; &#125; &#125;, labelLine: &#123; normal: &#123; lineStyle: &#123; color: 'rgba(255, 255, 255, 0.3)' //线的颜色 &#125; &#125; &#125;, itemStyle: &#123; normal: &#123; color: '#c23531', //设置整体的颜色 shadowBlur: 300, //设置阴影的模糊度 shadowColor: 'rgba(0, 0, 0, 0.5)' 设置阴影的颜色 &#125; &#125; &#125; ]&#125;; 再来看一下官方的效果图：可以看到这个真的很酷！ 异步加载数据需要实现异步加载数据其实也很简单，只要利用相关方法就可以轻松实现，比如利用jQuery中的延迟对象中的 done()这个方法就可以轻松实现。以下是官方文档中的一个异步加载数据的实例：1234567891011121314151617181920212223242526272829303132333435var myChart = echarts.init(document.getElementById('main'));// 显示标题，图例和空的坐标轴myChart.setOption(&#123; title: &#123; text: '异步数据加载示例' &#125;, tooltip: &#123;&#125;, legend: &#123; data:['销量'] &#125;, xAxis: &#123; data: [] &#125;, yAxis: &#123;&#125;, series: [&#123; name: '销量', type: 'bar', data: [] &#125;]&#125;);// 异步加载数据$.get('data.json').done(function (data) &#123; // 填入数据 myChart.setOption(&#123; xAxis: &#123; data: data.categories &#125;, series: [&#123; // 根据名字对应到相应的系列 name: '销量', data: data.data &#125;] &#125;);&#125;); 以上例子就是先加载出空的图表，等待数据加载完毕就显示数据。 使用dataset来管理数据我们前面的例子都是普通的数据格式，设置在各个series当中，在数据共享方面存在不足，使用dataset就可以解决这些问题，下面是一个简单的dataset的例子：1234567891011121314151617181920212223242526var option=&#123; title:&#123; text:'这是一个测试的图表' &#125;, tooltip:&#123;&#125;, legend:&#123;&#125;, dataset:&#123; source:[ ['销量','销量1','销量2'], ["衬衫",'5','20'], ['羊毛衫','30','40'], ['袜子','60','80'], ['裤子','60','50'] ] &#125;, // 声明一个 X 轴，类目轴（category）。默认情况下，类目轴对应到 dataset 第一列。 xAxis:&#123; type: 'category' &#125;, yAxis:&#123;&#125;, // 声明多个 bar 系列，默认情况下，每个系列会自动对应到 dataset 的每一列。 series:[ &#123;type: 'bar'&#125;, &#123;type: 'bar'&#125;, ], &#125;; 通过以上代码也实现了一个简单的图表，但是好处在于数据可以共享，不用重复写，而且我个人更加喜欢这种方式来写数据。 按行还是按列映射dataset默认是按列来进行映射，通过比较两种映射的方法，我个人还是更加习惯喜欢默认的按列进行映射,这里就不过多的对二者的差异进行比较。想要详细了解可以前去文档进行查询。 维度 常用图表所描述的数据大部分是“二维表”结构，上述的例子中，我们都使用二维数组来容纳二维表。现在，当我们把系列（series）对应到“列”的时候，那么每一列就称为一个“维度（dimension）”，而每一行称为数据项（item）。反之，如果我们把系列（series）对应到表行，那么每一行就是“维度（dimension）”，每一列就是数据项（item）。 维度可以有单独的名字，便于在图表中显示。维度名（dimension name）可以在定义在 dataset 的第一行（或者第一列）。例如上面的例子中，’score’、’amount’、’product’ 就是维度名。从第二行开始，才是正式的数据。dataset.source 中第一行（列）到底包含不包含维度名，ECharts 默认会自动探测。当然也可以设置 dataset.sourceHeader: true 显示声明第一行（列）就是维度，或者 dataset.sourceHeader: false 表明第一行（列）开始就直接是数据。 维度的定义，也可以使用单独的 dataset.dimensions 或者 series.dimensions 来定义：第一种是在dataset中设置：12345678910111213var option1 = &#123; dataset: &#123; dimensions: [ &#123;name: 'score'&#125;, // 可以简写为 string，表示维度名。 'amount', // 可以在 type 中指定维度类型。 &#123;name: 'product', type: 'ordinal'&#125; ], source: [...] &#125;, ...&#125;; 第二种是在series中设置：1234567891011121314151617181920212223242526272829var option1 = &#123; dataset: &#123; dimensions: [ &#123;name: 'score'&#125;, // 可以简写为 string，表示维度名。 'amount', // 可以在 type 中指定维度类型。 &#123;name: 'product', type: 'ordinal'&#125; ], source: [...] &#125;, ...&#125;;var option2 = &#123; dataset: &#123; source: [...] &#125;, series: &#123; type: 'line', // 在系列中设置的 dimensions 会更优先采纳。 dimensions: [ null, // 可以设置为 null 表示不想设置维度名 'amount', &#123;name: 'product', type: 'ordinal'&#125; ] &#125;, ...&#125;; 大部分时候都不需要手动去设置维度类型。但是如果因为数据为空之类原因导致判断不足够准确时，可以手动设置维度类型。具体有哪些类型可以查询文档 数据到图形的映射（encode） encode 声明的基本结构如下，其中冒号左边是坐标系、标签等特定名称，如 ‘x’, ‘y’, ‘tooltip’ 等，冒号右边是数据中的维度名（string 格式）或者维度的序号（number 格式，从 0 开始计数），可以指定一个或多个维度（使用数组）。通常情况下，下面各种信息不需要所有的都写，按需写即可。 使用encode可以将数据按照需要映射到图形。 encode涉及到的知识很多，我们现在来看encode的一个简单的应用。123456789101112131415161718192021222324252627282930313233343536373839var option2=&#123; // 设置dataset dataset:&#123; // 设置好源数据，默认是以列的方式来进行映射，所以要注意好顺序 source:[ // 通过一个二维数组来设置数据 ['物品','销量1','销量2'], ["衬衫",'5','20'], ['羊毛衫','30','40'], ['袜子','60','80'], ['裤子','60','50'] ] &#125;, xAxis:&#123;&#125;, // 这里将图表设置为横向的柱状图 yAxis:&#123;type:'category'&#125;, // 设置了两个系列 series:[ &#123; type:'bar', // 通过encode来进行映射 encode:&#123; // 将销量映射到x轴 x:'销量1', // 将物品的类型映射到y轴 y:'物品', // 这里也可以通过索引来进行映射，就可以实现动态变更数据，但是要注意的一件事是索引是从0开始的。 tooltip: [1, 2] //也可以映射tooltip，现在还不知道是干什么的 &#125; &#125;, &#123; type:'bar', encode:&#123; x:'销量2', y:'物品', &#125; &#125; ] &#125; 这里还看一下效果： encode也还有很多其他的注意事项，这里就不一一介绍了，有需要可以查询文档 数据的各种格式 常见的图表中，保存数据的方式是通过二维表的形式来保存的，广为熟知的数据图表表格软件也都是通过二维表，这些数据也都可以转化为json格式，网络上有很多互相转换的方法，如果转化为csv格式的文件，那么可以使用一些 csv 工具如 dsv 或者 PapaParse 将 csv 转成 JSON。 在js中比较直观常见的二维格式就是二维数组了，之前前面的所有例子都是通过二维数组来存储数据的 除了二维数组之外比较常见的二维形式就是对象数组了，也就是键值对的形式，比如上面的例子可以这样写： 1234567source:[ // 按行的形式 &#123;'物品:'衬衫','销量1':5,'销量2':20&#125;, &#123;'物品:'羊毛衫','销量1':30,'销量2':40&#125;, &#123;'物品:'袜子','销量1':60,'销量2':80&#125;, &#123;'物品:'裤子','销量1':60,'销量2':50&#125;,] 还有按列的形式这里就不演示了 个人觉得二维数组的形式写起来会更加的简单方便一些，所以我更加的喜欢二维数组的方式 设置多个datase（设置多个source）可以同时设置多组数据，然后决定使用哪一组数据：12345678910111213141516171819var option = &#123; dataset: [&#123; // 序号为 0 的 dataset。 source: [...], &#125;, &#123; // 序号为 1 的 dataset。 source: [...] &#125;, &#123; // 序号为 2 的 dataset。 source: [...] &#125;], series: [&#123; // 使用序号为 2 的 dataset。 datasetIndex: 2 &#125;, &#123; // 使用序号为 1 的 dataset。 datasetIndex: 1 &#125;]&#125; 其他事项 根据官方文档，现在并不是所有的图表类型都支持dataset 官方还给了一个多个图表共享一个dataset的例子，并且有联动效果，目前还看不懂是怎么会是 想要了解更多可以前往官方文档进行查看 图表组件echarts中有很多组件，现在就按照官方文档中的示例来先介绍一下dataZoom组件，这个组件可以将图表进行放大缩小以及拖动查看，还是很有用的，现在按照官方文档中的例子来试一试:** 先是没有datazoom的散点图123456789101112131415var option3=&#123; xAxis:&#123; type:'value', &#125;, yAxis:&#123; type:'value' &#125;, series:[ &#123; name:'test', type:'scatter', //设置这个为散点图 data: [["14.616","7.241","0.896"],["3.958","5.701","0.955"],["2.768","8.971","0.669"],["9.051","9.710","0.171"],["14.046","4.182","0.536"],["12.295","1.429","0.962"],["4.417","8.167","0.113"],["0.492","4.771","0.785"],["7.632","2.605","0.645"],["14.242","5.042","0.368"]] &#125; ] &#125; 现在加上datazoom组件12345dataZoom: [&#123; // 这个dataZoom组件，默认控制x轴。 type: 'slider', // 这个 dataZoom 组件是 slider 型 dataZoom 组件 start: 10, // 左边在 10% 的位置。 end: 60 // 右边在 60% 的位置。 &#125;], 来看下效果图：可以看出现在有了一个可以拖动的条，但是还不能进行缩放 如果要可以进行缩放就需要再加上一个组件12345&#123; // 这个dataZoom组件，也控制x轴。 type: 'inside', // 这个 dataZoom 组件是 inside 型 dataZoom 组件 start: 10, // 左边在 10% 的位置。 end: 60 // 右边在 60% 的位置。 &#125; 加上以后就可以进行缩放了**这里只以x轴为例子进行了演示，y轴也是一样的方法。 响应式图表echarts中支持响应式图表，也是通过类似于媒体查询来实现的，这十分有用，因为我们的项目可能是用bootstrap来制作，那么在这种情况下响应式是必不可少的。 echarts组件的定位和布局echarts中有两种定位方式： left/right/top/bottom/width/height 定位方式：例如：{left: 23, height: 400}，可以不写单位，还可以写成百分比的形式，{left: 30%, height: 40%}可以设置 left: &#39;center&#39;，表示水平居中。可以设置 top: &#39;middle&#39;，表示垂直居中。 在横向，left、right、width 三个量中，只需两个量有值即可，因为任两个量可以决定组件的位置和大小，例如 left 和 right 或者 right 和 width 都可以决定组件的位置和大小。 纵向，top、bottom、height 三个量，和横向类同不赘述。 center / radius 定位方式：center是一个数组，表示 [x, y]，其中，x、y可以是『绝对值』或者『百分比』，含义和前述相同。radius是一个数组，表示 [内半径, 外半径]，其中，内外半径可以是『绝对值』或者『百分比』，含义和前述相同。在自适应容器大小时，百分比设置是很有用的。 图表的方向在echarts中有一些图表可能会很长，在pc端可以较好的显示，在移动端就不一定能够很好的显示了，所以就需要设置他们的方向：横纵向布局的设置，一般在『组件』或者『系列』的 orient 或者 layout 配置项上，设置为 &#39;horizontal&#39; 或者 &#39;vertical&#39;。 实现响应式前面有说到echarts中实现响应式是通过类似媒体查询来实现的，这就是echarts中的 Media Query在option中Media Query 的基本格式：123456789101112131415161718192021222324252627282930option = &#123; baseOption: &#123; // 这里是基本的『原子option』。也就是用来设置一些通用的基本的与响应式无关的选项 title: &#123;...&#125;, legend: &#123;...&#125;, series: [&#123;...&#125;, &#123;...&#125;, ...], ... &#125;, media: [ // 这里定义了 media query 的逐条规则。 &#123; query: &#123;...&#125;, // 这里写规则。 option: &#123; // 这里写此规则满足下的option。 legend: &#123;...&#125;, ... &#125; &#125;, &#123; query: &#123;...&#125;, // 第二个规则。 option: &#123; // 第二个规则对应的option。 legend: &#123;...&#125;, ... &#125; &#125;, &#123; // 这条里没有写规则，表示『默认』， option: &#123; // 即所有规则都不满足时，采纳这个option。 legend: &#123;...&#125;, ... &#125; &#125; ]&#125;; query的格式：12345&#123; minWidth: 200,//设置响应式的最小宽度，表示大于200px就是这个option maxHeight: 300,//设置响应式的最大宽度 minAspectRatio: 1.3//设置响应式的长宽比&#125; 多个query被满足时的优先级后面的覆盖前面的 默认 query：如果 media 中有某项不写 query，则表示『默认值』，即所有规则都不满足时，采纳这个option。 容器大小实时变化时的注意事项如果要一直动态的改变容器的大小并且让图表的大小也随之改变，那就必须注意query option中出现的配置项，其他query option也必须出现，防止出现回不去的情况。 关于Echarts响应式还有一件需要注意的事情Echarts.js中虽然有类似响应式的支持，但是这与bootstrap中的响应式有很大不同，echarts中自带的响应式不能像bootstrap中那样随着窗口大小的改变而实时的更改图表的位置以及大小，只有在网页刷新的时候或者再一次setoption的时候才会有位置或者大小的变更，虽然这也能达到响应式的目的，但是我觉得这在bootstrap中会显得十分的不协调，所以我针对这一方面进行了改进，下篇文章进行详细介绍。 echarts中的事件和行为echarts中自带了很多的事件和行为，我们可以通过on的方法来绑定。例如下面的代码：12345//这是一个echarts中的单击事件，单击图表之后在控制台打印数据myChart.on('click', function (params) &#123; // 控制台打印数据的名称 console.log(params.name);&#125;); echarts中还有很多的事件，这里就不一一介绍了，这里再说一下鼠标事件返回的参数params,这个参数是一个图形的数据信息对象，格式如下：12345678910111213141516171819202122232425&#123; // 当前点击的图形元素所属的组件名称， // 其值如 'series'、'markLine'、'markPoint'、'timeLine' 等。 componentType: string, // 系列类型。值可能为：'line'、'bar'、'pie' 等。当 componentType 为 'series' 时有意义。 seriesType: string, // 系列在传入的 option.series 中的 index。当 componentType 为 'series' 时有意义。 seriesIndex: number, // 系列名称。当 componentType 为 'series' 时有意义。 seriesName: string, // 数据名，类目名 name: string, // 数据在传入的 data 数组中的 index dataIndex: number, // 传入的原始数据项 data: Object, // sankey、graph 等图表同时含有 nodeData 和 edgeData 两种 data， // dataType 的值会是 'node' 或者 'edge'，表示当前点击在 node 还是 edge 上。 // 其他大部分图表中只有一种 data，dataType 无意义。 dataType: string, // 传入的数据值 value: number|Array // 数据图形的颜色。当 componentType 为 'series' 时有意义。 color: string&#125; **echarts中事件与行为更为详细的信息可以查阅相关的文档，这里就不详细说明了 总结到这里就介绍了echarts中的一些基本的概念以及信息，还不是特别全面，算是稍微认识了一下echarts，echarts的功能十分的强大可自定义的程度也是非常的高，官方文档有非常详细的配置项介绍，如果感兴趣的话可以慢慢去学习。]]></content>
  </entry>
  <entry>
    <title><![CDATA[关于animate.css与wow.js的使用]]></title>
    <url>%2F2019%2F06%2F05%2F%E5%85%B3%E4%BA%8Eanimate-css%E4%B8%8Ewow-js%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在实际的网站开发过程中或多或少的都会使用到一些动画功能，所以学会使用动画是必不可少的，前面我们已经学习过了jQuery中的一些动画相关方面的方法，并且学习了自定义动画，可以帮我们做出我们想要的动画，当时使用这些动画还是不够简单方便，其实在网上已经有很多动画相关的扩展，我们只需要调用即可简单的实现一些常用的动画，这次就来学习一下animate.css以及wow.js的使用。 animate.css animate.css是一款常见的css库，包含了很多的常见动画，使用起来也是十分的简单方便，只需要将animate.css文件引入到我们的项目中即可&lt;link rel=&quot;stylesheet&quot; href=&quot;./../../css/animate.css/animate.css&quot;&gt; 引入进来以后我们想要使用动画也是十分的简单，只需要给我们想要添加动画的元素添加上类即可，例如：1&lt;div class="col-md-6 p-5 bg-danger animated bounce"&gt; 这样我们就很轻松的给这个元素加上了一个弹起动画 那么我们要如何给动画设置一些属性呢，比如说像延时，动画时间之类的呢一种方法是通过css样式去覆盖原有的属性:例如： 1&lt;div class="col-md-6 p-5 bg-danger animated bounce" style="animation-delay: 5s;animation-duration: 3s"&gt; 以下是常用的设置： animation-duration 规定完成动画所花费的时间，以秒或毫秒计。 animation-timing-function 规定动画的速度曲线。 animation-delay 规定在动画开始之前的延迟。 animation-iteration-count 规定动画应该播放的次数。 通过这种办法我们就可以对动画进行一些设置 那么还有一种办法就是使用js对其进行设置在网上有一款js插件就是基于animate.css的js动画插件，用法其实是和animate.css是差不多的，但是可以直接设置动画相关的一些属性，使用起来可能会稍微方便那么一点点，因为不用特地再去设置css。 wow.js上面提到的那款js插件就是wow.js，它是基于animate.css制作的，所以使用它需要在网页中引入animate.css，用法与animate.css相似： 使用之前需要先进行初始化：new WOW().init(); 给需要设置动画的元素添加上wow、animate类即可添加上动画，此处的animate指的是animate.css中支持的动画名称。例如：1&lt;div class="col-md-6 p-5 bg-light wow fadeInLeft"&gt; 通过这样的设置就可以轻松的将动画轻松的应用到元素上面 通过wow.js对动画进行相关的设置是比较轻松的：data-wow-duration （动画持续时间）data-wow-delay （动画延迟时间）data-wow-offset（元素的位置露出后距离底部多少像素执行）data-wow-iteration（动画执行次数） 总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给元素添加动画的方法有很多，可以自己用css编写，或者js编写，也可以直接用网上众多的动画库，今天我这里就介绍了两款动画库。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么该用哪个呢，其实我个人更倾向于直接使用animate.css，因为不用引入其他更多的文件，虽然设置属性的时候不如wow.js方便，但是文件更少，并且可以只取自己想要的动画。]]></content>
  </entry>
  <entry>
    <title><![CDATA[锚点动画的实现以及其他相关]]></title>
    <url>%2F2019%2F06%2F05%2F%E9%94%9A%E7%82%B9%E5%8A%A8%E7%94%BB%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%BB%A5%E5%8F%8A%E5%85%B6%E4%BB%96%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在单页面中导航大多数都是直接使用锚点来进行导航，因为使用起来比较方便，但是单纯的锚点导航没有动画看起来比较生硬，所以基本上涉及到单页面导航都会给锚点跳转加上动画，那么实现起来也十分的简单方便。通过现在这么多的练习与学习，我发现很多功能如果每次都要自己写的话会比较麻烦，是否可以像各种框架一样封装起来成为自己的一个框架，每次只要通过特定的方法来调用就好了，那么这次我就将这个锚点动画的功能封装在我自己的一个js当中。同时这次涉及到锚点，又使我想起了前一段时间接触到的js中的hash，总感觉二者很像，再来探讨一下二者之间的关系。 实现锚点动画代码：123456789101112(function anchor_animate() &#123; // 可传递上下偏移量 var $offsetY = parseInt(-$(".my.anchor-animate").data('moffset')) || 0; // 可传递动画时间 var $time = parseInt($(".my.anchor-animate").data('mtime')) || 500; $(".my.anchor-animate a").click(function () &#123; $('html,body').animate(&#123; // 拿到锚点对应所在对象并给其设置动画 scrollTop: ($($(this).attr('href')).offset().top + $offsetY) &#125;, $time); &#125;); &#125;)(); 通过这些简单的代码就可以实现锚点动画了，值得注意的是这是我已经封装好的锚点动画，如果想要调用只需要给想要实现锚点动画的导航栏加上.my 、 .anchor-animate 这两个类就可以了，还可以通过data来设置参数，下次想要使用的时候就很方便了，以后把更多的功能封装进来。 关于hash起初我在学习一些知识的时候有使用过hash，不过当时是使用在实现给不同页面加上hash值，然后实现页面刷新在固定页面的功能上，因为hash也是在地址栏中加上#的原因，所以我觉得这和锚点很像，然后我去查了一下，其实hash的定义就是：hash 属性是一个可读可写的字符串，该字符串是 URL 的锚部分（从 # 号开始的部分）。其实就是一家人，再记录一下hash的用法：location.hash=anchorname当设置之后当前页面的url地址栏中就会出现#anchorname了。 总结以后尽可能的将一些常用的功能都封装到自己的js之中，然后向一些框架学习，学习他们是如何封装的，让自己的js也更加的规范。]]></content>
  </entry>
  <entry>
    <title><![CDATA[php中页面分页的实现]]></title>
    <url>%2F2019%2F06%2F03%2Fphp%E4%B8%AD%E9%A1%B5%E9%9D%A2%E5%88%86%E9%A1%B5%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;今天老师上课给我们讲了一下php中的翻页功能的实现，，主要是通过数据库中的limit方法实现，这一点和我预想的差不多，但是通过给页面设置id的这种办法是我没有想到的，我一开始的设想是，能不能作到不用给每个页面设置一个id，根据这个id进行跳转，而是直接设置一个变量，当进行翻页的时候这个变量的数值发生变化，然后根据这个变量来获取数据库中的内容。这个想法应该可以实现，但是可能会比较麻烦，因为在php中还是必须要刷新页面才能更新数据的，所以目前来看还是这种方法应该是最好的，那么就来看看究竟是怎么实现分页功能的。 代码 先是连接数据库： 123456&lt;?php// 一个正常的连接数据库的页面$conn=mysqli_connect('localhost','root','','test') or die('失败');mysqli_set_charset($conn,'utf8');$res=mysqli_query($conn,'select * from stu');?&gt; 实现功能的页面 12345678910111213141516171819202122232425262728293031323334353637&lt;body&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;id&lt;/td&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;年龄&lt;/td&gt; &lt;td&gt;性别&lt;/td&gt; &lt;/tr&gt; &lt;?php include 'conn.php'; $data_count=mysqli_num_rows($res); //获取数据表中有多少条数据 $data_num=2; //设置一页显示多少条数据 $id=empty($_GET['id'])?1:$_GET['id']; //判断当前页面的url栏中的id参数是否为空，如果为空则默认为1，否则则为url中id的数值 $pg_count=ceil($data_count/$data_num); //计算总共有多少页，ceil的用法是往上取整 //通过limit来获取每一个页面该显示的数据 $datas=mysqli_query($conn,"select * from stu limit ".($id-1)*2 . ','. $data_num); //用来排错的方法 // if (!$datas) &#123; // printf("Error: %s\n", mysqli_error($conn)); // exit(); // &#125; // 输出最终获取到的页面的数据 while($row=mysqli_fetch_array($datas))&#123; echo "&lt;tr&gt;&lt;td&gt;$row[id]&lt;/td&gt;&lt;td&gt;$row[name]&lt;/td&gt;&lt;td&gt;$row[age]&lt;/td&gt;&lt;td&gt;$row[sex]&lt;/td&gt;&lt;/tr&gt;"; &#125; ?&gt; &lt;!-- 在href中设置id的值 --&gt; &lt;tr&gt; &lt;td&gt;&lt;a href="?id=1"&gt;首页&lt;/a&gt;&lt;/td&gt; 实现上一页的功能，先判断是否是第一页，否则id-1 &lt;td&gt;&lt;a href="?id=&lt;?php echo $id==1?1:$id-1 ?&gt;"&gt;上一页&lt;/a&gt;&lt;/td&gt; 实现上一页的功能，先判断是否是最后一页，否则id+1 &lt;td&gt;&lt;a href="?id=&lt;?php echo $id==$pg_count?$pg_count:$id+1 ?&gt;"&gt;下一页&lt;/a&gt;&lt;/td&gt; &lt;td&gt;&lt;a href="?id=&lt;?php echo $pg_count ?&gt; "&gt;尾页&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt; 其实代码还是很好理解的，但是自己在写的过程中还是遇到了一些问题，下面记录一下这些问题 我自己在编写过程中遇到的一些问题首先就是在我基本上已经写完代码之后一测试就爆出了一个警告，并且最终没有出现我想要的结果，于是我上网查询解决办法，于是找到了下面这一段代码：1234if (!$datas) &#123; printf("Error: %s\n", mysqli_error($conn)); exit(); &#125; 通过上述代码就没有再出现警告了，而是直接报错，提示问题在哪，我就在附近排查问题， $datas=mysqli_query($conn,&quot;select * from stu limit ($id-1)*2 , $data_num&quot;); 我一开始想会不会因为是没有拼接字符串的原因,于是我修改代码改成后面是拼接字符串的形式。 $datas=mysqli_query($conn,&quot;select * from stu limit&quot;.($id-1)*2 . &#39;,&#39;. $data_num); 但是一直都是出现一样的错误提示，后面经过我的测试发现是$datas中没有数据，但是我直接不写变量，把变量写死就能出来数据。反复比较自己那部分的代码和老师给的代码，但是直接比对并没有发现什么不一样，后面复制老师的这行代码稍加修改结果却是正常的。最后我终于发现了问题所在，其实我尝试的两种写法都存在问题： 首先是我一开始没有拼接变量，而是直接将变量写在字符串之中，我发现也是数据库在处理语句的时候出现的问题，我猜测应该是在使用变量的时候变量会把前面的空格给吞掉，导致语句执行错误。 后面我尝试拼接字符串的时候又出现了问题是因为我在limit后面少拼接了一个空格导致语句执行出错。 总结写php还是不是特别的熟练，所以经常出现各种问题，所以要总结错误，加深印象，以后越写越熟练以后的错误就会越来越少]]></content>
  </entry>
  <entry>
    <title><![CDATA[写一个简单的五星评分系统]]></title>
    <url>%2F2019%2F05%2F27%2F%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%BA%94%E6%98%9F%E8%AF%84%E5%88%86%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最近在写期末的课程设计，网站有要求写一个五星评分的功能，我按照我的思路写了一下，经过一下午的时间，把这个功能实现的比较完善了。 一开始的第一种尝试放代码：HTML部分：1234567891011121314151617*&#123; list-style: none;&#125;.all&#123; display: flex;&#125;&lt;/style&gt;&lt;body&gt; &lt;ul class="all"&gt; &lt;li&gt;&lt;img index=0 src="./images/wxz.png" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img index=1 src="./images/wxz.png" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img index=2 src="./images/wxz.png" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img index=3 src="./images/wxz.png" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img index=4 src="./images/wxz.png" alt=""&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt; JS部分：12345678910111213141516171819202122232425262728&lt;script&gt; $(function()&#123; var $stars=$('img'); console.log($stars); // 最外面的循环是给所有img添加事件 for(var i=0;i&lt;$stars.length;i++)&#123; $stars.eq(i).mouseenter(function()&#123; // 第二层的循环是判断是否是当前正在操作的元素 for(var i=0;i&lt;$stars.length;i++)&#123; if($stars[i]==this)&#123; $(this).click(function()&#123; console.log(i); &#125;) // 第三层的循环是给所有的星星设置相应的图片,让它显示出应有的效果 for(var j=0;j&lt;$stars.length;j++)&#123; if(j&lt;=i)&#123; $stars.eq(j).attr("src","./images/xz.png") &#125; else&#123; $stars.eq(j).attr("src","./images/wxz.png") &#125; &#125; &#125; &#125; &#125;) &#125; &#125;) &lt;/script&gt; 最终是实现了效果,但是我觉得这不是最好最简单的写法,于是我将其改进了一下，有了下面的这种写法。 第二种写法第二种写法原理其实也是一样的，只不过是代码更加的简介和简单1234567891011121314151617&lt;style&gt;*&#123; list-style: none;&#125;.all&#123; display: flex;&#125;&lt;/style&gt;&lt;body&gt; &lt;ul class="all"&gt; &lt;li&gt;&lt;img index="0" src="./images/wxz.png" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img index="1" src="./images/wxz.png" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img index="2" src="./images/wxz.png" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img index="3" src="./images/wxz.png" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img index="4" src="./images/wxz.png" alt=""&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt; 12345678910111213141516171819202122&lt;script&gt; $(function()&#123; var $stars=$('img');//获取所有的星星 // 鼠标移入事件 $stars.mouseenter(function()&#123; var $star_index=parseInt($(this).attr("index")); for(var i=0;i&lt;$stars.length;i++)&#123; if(i&lt;=$star_index)&#123; $stars.eq(i).attr("src","./images/xz.png"); &#125; else&#123; $stars.eq(i).attr("src","./images/wxz.png"); &#125; &#125; &#125;) // 单击事件，向服务器提交数据 $stars.click(function()&#123; var $star_index=parseInt($(this).attr("index")); console.log($star_index+1); &#125;) &#125;) &lt;/script&gt; 可以看出第二种写法要简单很多，主要是没有这么多的循环嵌套，这也是我最终所采用的写法。 总结虽然这个评分系统的原理以及思路是挺简单的，但其实在实现的过程中还是遇到了一些困难的，不过经过不断的思考排错，最终还是将其完善了，相信只要不断的学习，以后一定能越来越得心应手。]]></content>
  </entry>
  <entry>
    <title><![CDATA[HTML中DOM的hash属性的使用]]></title>
    <url>%2F2019%2F05%2F26%2Fhash%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hash在网站中的使用也是十分的常见，使用hash也可以带来便利，这次我们来看看hash究竟该如何让使用。 如何设置hash我们可以通过在js中设置hash的值123&lt;script&gt;window.location.hash=3;&lt;/script&gt; 这样就可以设置hash值，那么设置过后我们就可以在地址栏看到多了一个#3 如何获取hash的值12345678910111213141516&lt;script&gt; window.location.hash=3; console.log(window.location.hash); //#3 &lt;/script&gt;``` 直接就能获取hash的值，但是这样获取到的值带有``#``我们要获取的一般都是不带``#``的值所以我们可以这样处理```javasript&lt;script&gt; window.location.hash=3; console.log(window.location.hash); //#3 console.log(window.location.hash.substring(1)); //3 &lt;/script&gt; 使用字符串截取函数，截取不带#的这一部分 总结hash的使用十分的简单，但是hash的使用频率很高，通过hash我们就可以实现例如翻页还在同一页的效果。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Ajax的学习]]></title>
    <url>%2F2019%2F05%2F26%2FAjax%E7%9A%84%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ajax技术可以说是随处可见，在网页的交互方面基本上都用到了Ajax，可以说Ajax作用是十分的强大，通过 Ajax，因特网应用程序可以变得更完善，更友好。所以作为正在学习的我来说，完整学习Ajax以及完全掌握Ajax是十分重要的。 什么是Ajax呢？ Ajax 即“Asynchronous Javascript And XML”（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。 Ajax = 异步 JavaScript 和 XML 或者是 HTML（标准通用标记语言的子集）。 Ajax 是一种用于创建快速动态网页的技术。 Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。 Ajax所涉及的相关知识 get方式提交数据与post方式提交数据的异同点1、通过get方式提交数据会把数据放在url地址栏中，而使用post方式提交数据则会把数据放到请求头中，可以在调试工具的network栏中看到这些数据2、get请求由于浏览器对于url地址栏长度的限制，所以导致get1请求发送数据会有长度限制，要支持ie，那么最大长度就为2083byte 原生js实现Ajax可以参考这里 由于原生js实现Ajax过程比较多，这里不做过多介绍，了解即可，通常使用jQuery中的ajax方法，比较方便快捷的使用Ajax。 jQuery中的Ajax jQuery 提供多个与 AJAX 有关的方法。 通过 jQuery AJAX 方法，您能够使用 HTTP Get 和 HTTP Post 从远程服务器上请求文本、HTML、XML 或 JSON - 同时能够把这些外部数据直接载入网页的被选元素中。 jQuery.ajax([settings]) 这是jQuery中的Ajax的基本用法。 settings最常用的参数 type类型：String默认值: “GET”)。请求方式 (“POST” 或 “GET”)， 默认为 “GET”。注意：其它 HTTP 请求方法，如 PUT 和 DELETE 也可以使用，但仅部分浏览器支持。 url类型：String默认值: 当前页地址。发送请求的地址。 data类型：String发送到服务器的数据。将自动转换为请求字符串格式。GET 请求中将附加在 URL 后。查看 processData 选项说明以禁止此自动转换。必须为 Key/Value 格式。如果为数组，jQuery 将自动为不同值对应同一个名称。如 {foo:[“bar1”, “bar2”]} 转换为 ‘&amp;foo=bar1&amp;foo=bar2’。 error类型：Function默认值: 自动判断 (xml 或 html)。请求失败时调用此函数。有以下三个参数：XMLHttpRequest 对象、错误信息、（可选）捕获的异常对象。如果发生了错误，错误信息（第二个参数）除了得到 null 之外，还可能是 “timeout”, “error”, “notmodified” 和 “parsererror”。这是一个 Ajax 事件。 success类型：Function请求成功后的回调函数。参数：由服务器返回，并根据 dataType 参数进行处理后的数据；描述状态的字符串。这是一个 Ajax 事件。 除了以上这些外，jQuery中Ajax的settings还有很多参数，具体可以参考这里 通过jQuery中的Ajax来写两个简单的例子 通过get方式来向远程服务器提交数据。html代码123456789101112131415161718192021222324&lt;body&gt; &lt;!-- 通过一个按钮的单击事件来触发ajax --&gt; &lt;button&gt;这是一个按钮，点击发送Ajax请求&lt;/button&gt; &lt;script&gt; $(function()&#123; var $bt=$('button'); // 为按钮绑定单击事件 $bt.click(function()&#123; // 调用jQuery中的Ajax $.ajax(&#123; type:'get', url:'./php/ajax-get.php', data:'name=hsl&amp;age=18', success:function(msg)&#123; alert(msg) &#125;, error:function(xhr)&#123; alert(xhr) &#125; &#125;) &#125;) &#125;) &lt;/script&gt;&lt;/body&gt; php代码1234&lt;?php echo '这是返回的名字'.$_GET['name']; echo '这是返回的年龄'.$_GET['age'];?&gt; 根据代码我们可以看出当我们单击按钮的时候就会触发单击事件调用ajax，给我们返回后端处理过后的数据，那结果究竟会是怎样呢。通过图片我们可以看出Ajax成功返回了我们想要的数据，并且我们可以看到这个php文件的url附加了我们的参数信息。 通过post方式来向远程服务器提交数据。html代码1234567891011121314151617181920&lt;body&gt; &lt;button&gt;这是一个发送post请求的按钮&lt;/button&gt; &lt;script&gt; $(function()&#123; $('button').click(function()&#123; $.ajax(&#123; url:'./php/ajax-post.php', type:'post',//这里的传输方式改成了post data:'name=hsl&amp;age=18', success:function(msg)&#123; alert(msg); &#125;, error:function(xhr)&#123; alert(xhr); &#125; &#125;) &#125;) &#125;) &lt;/script&gt;&lt;/body&gt; php代码1234&lt;?phpecho $_POST['name'];echo $_POST['age'];?&gt; 可以看出上面的代码主要就是将type 从get改成了post，那效果会怎样呢.从图片中我们可以看出使用post方式也成功获取了我们想要的数据，但是我们不能在url中看见我们传过去的参数，但是能在报文头中看见这些参数，因为不像get方式会在url栏传参数，所以也没有长度的限制。 总结通过这次的学习，掌握了Ajax的基本用法，也通过实例了解了get方式与post方式的一些差别，二者以后要根据实际情况来使用。]]></content>
  </entry>
  <entry>
    <title><![CDATA[关于使用flex布局遇到的一个小问题]]></title>
    <url>%2F2019%2F05%2F23%2F%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8flex%E5%B8%83%E5%B1%80%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;昨天在给我的课程设计的网站做底部信息的时候遇到了一个问题，就是我给一个子元素div设置了固定的宽度，但是当我页面宽度发生变化的时候，这个div的宽度也会发生变化，毕竟我设置的是固定的宽度，所以这肯定不是我想要的效果，今天和昨天经过测试，现在终于把问题解决了，问题是由于flex引起的。让我们先看我的一个测试的代码：123456789101112131415161718192021222324&lt;style&gt;.big&#123; width: 100%; height: 500px; background-color: blue; display: flex; border: 2px solid #000; justify-content: center; align-items: center; margin: 0 auto;&#125;.sm&#123; width: 1200px;//这里是一个固定的宽度 height: 400px; background-color: red; text-align: center; border: 3px solid yellow;//加了一个黄色边框，方便观察&#125;&lt;/style&gt;&lt;body&gt; &lt;div class="big"&gt; &lt;div class="sm"&gt;这是测试的内容&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 按照我一开始的想法，既然设置了固定的宽度，应该就不会再发生改变了，即使是flex也不能改变它可是我们再看看效果图：很明显，里面的子元素的宽度也因为父元素的宽度变小了而变小了。 我的第一次尝试是给它加一个min-width=1200px，我们再看看效果：还是一样，没有发生任何变化。那究竟要怎么解决这个问题呢，经过我的各种尝试和猜想，最终还是把问题解决了：那么要如何解决这个问题呢，看我解决后的代码：1234567891011121314151617181920212223242526&lt;style&gt;.big&#123; width: 100%; height: 500px; background-color: blue; display: flex; border: 2px solid #000; /* justify-content: center; */ //1、首先就是不能用这个属性 align-items: center; margin: 0 auto;&#125;.sm&#123; width: 1200px; min-width: 1200px; //3、同时要加上最小宽度 height: 400px; background-color: red; text-align: center; margin: 0 auto; //2、只能使用这个来使子元素居中 border: 3px solid yellow;&#125;&lt;/style&gt;&lt;body&gt; &lt;div class=&quot;big&quot;&gt; &lt;div class=&quot;sm&quot;&gt;21413423&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 我们再来看看解决后的效果图：这次我们就可以看到，里面的内容没有被缩小了，问题终于得到了解决。 其实还有一种办法可以避免这种问题，就是最外层子元素不使用flex布局，或者是不设置百分比的宽度，这样也不会出现这种问题，但是在有些情况下使用flex明显要方便很多，看实际情况选择哪种处理办法吧。 更新补充后来我又想到了一个相对较好的解决办法，那就使最外层的div可以设置为百分比的宽度，但是不设置flex，我们对要布局的子div给它再加一个父元素，让它变成孙子，我们给他加的这个div让他成为父元素，并且给这个父元素设置flex和固定的我们想要的宽度，这个时候通过父元素的flex给孙子元素flex布局就也不会出现这种问题了，这也是一种不错的解决办法（推荐） 总结flex虽然好用，很多方面用起来很方便，但是也存在很多问题我还不知道，所以使用的时候要提前做好规划，避免出现问题，我的轮播图bug就是由于flex布局引起的，但是不知道是不是这个原因。]]></content>
  </entry>
  <entry>
    <title><![CDATA[初识cookie]]></title>
    <url>%2F2019%2F05%2F21%2F%E5%88%9D%E8%AF%86cookie%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;即使在我学习前端知识前，作为一个网络用户，我也见过cookie，但是它究竟是干什么的，有什么用，这是我以前所不知道的，但是我现在作为一名前端学习者，那么就要了解并学习cookie的相关知识，并且会使用它。 什么是cookie？这是百度百科上的一段话：Cookie，有时也用其复数形式 Cookies，指某些网站为了辨别用户身份、进行 session 跟踪而储存在用户本地终端上的数据（通常经过加密）。定义于 RFC2109 和 2965 中的都已废弃，最新取代的规范是 RFC6265 [1] 。（可以叫做浏览器缓存） 我们就可以了解到cookie的作用，cookie就是存储了一些信息在本地，并且有一定的存在时间，cookie有这样的功能，就能给用户带来很多遍历，包括不用重复登录之类的。 cookie的一些特点 cookie的生命周期：·默认情况下是一次会话，也就是直到浏览器被关闭。·如果通过expires设置了时间，并且时间还没有过期，那么关闭浏览器后下次再打开浏览器，cookie还是存在的。·如果通过expires设置了时间，但是过期了，那么就会立即删除这个cookie，所以要删除一个cookie，只要让他过期就好了。 cookie数据的格式·cookie默认是不会保存任何数据的。document.cookie=&quot;name=hsl&quot;可以通过这种方式来添加cookie·在设置cookie时只能一条一条的设置，不能一条命令设置多条cookie。cookie有大小和个数的限制：个数：20~50大小：4kb左右 cookie的作用范围·不同浏览器之间的cookie不能共用·同一浏览器中，存放cookie的路径的子目录可以访问保存的cookie，但是父目录不能。document.cookie=&quot;name=hsl;path=/;&quot;但是可以通过加上path等于根目录使网站下的所有目录都能访问cookie。·默认情况下二级域名之间的cookie不能相互访问，但是设置了主域名之后就可以，domain=hslweb.net。 实际操作一下12345&lt;script&gt; var data=new Date(); data.setDate(data.getDate()+1);//设置时间 document.cookie="name=hsl;path=/;expires="+data.toGMTString()+";";//创建一个cookie，设置了路径以及过期的时间为后一天。&lt;/script&gt; 总结：cookie的创建与设置还是很简单的，但是哦cookie的作用却很强大，要好好使用。]]></content>
  </entry>
  <entry>
    <title><![CDATA[通过post方式上传文件]]></title>
    <url>%2F2019%2F05%2F21%2F%E9%80%9A%E8%BF%87post%E6%96%B9%E5%BC%8F%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这次学习一下通过表单得到post方式来向后端上传文件，以及使用表单来上传文件的注意点及注意事项。先上代码：123456&lt;body&gt; &lt;form action="post上传文件.php" method="POST" enctype="multipart/form-data"&gt; &lt;input type="file" name="upFile" id=""&gt;&lt;br&gt; &lt;input type="submit" name="tj"&gt; &lt;/form&gt;&lt;/body&gt; 这里之所以使用post方式上传而不使用get方式上传是因为get方式上传有文件大小方面的限制，最多2000个字符，所以使用post 很正常的一个表单，设置了控件类型以及与后端交互时要用到的name 但是要注意的是上传文件时除了要设置表单类型为 file之外，还需要给form添加一个enctype属性，并且把它的值设为multipart/form-data，只有这样才能正常上传。 我们再来看看php部分的代码：123456&lt;?phpprint_r($_FILES);echo '&lt;br&gt;';$fileInfo=$_FILES['upFile'];print_r($fileInfo);?&gt; 这个时候我们就不能再使用post方式来获取文件的内容了，我们需要用file方式。我么再来看看打印的结果：1234Array ( [tj] =&gt; 提交 ) //这个时候post变量获取到的东西就不是我们想要的东西了。Array ( [upFile] =&gt; Array ( [name] =&gt; 后面问题.png [type] =&gt; image/png [tmp_name] =&gt; E:\xampp\tmp\phpDC76.tmp [error] =&gt; 0 [size] =&gt; 32458 ) ) //而通过file变量获取到的数组里面就有我们想要的东西Array ( [name] =&gt; 后面问题.png [type] =&gt; image/png [tmp_name] =&gt; E:\xampp\tmp\phpDC76.tmp [error] =&gt; 0 [size] =&gt; 32458 )//然后再从数组中取出我们想要的文件，就可以得到文件的信息。 但是其实这个时候也不是我们想要的结果，因为我们会发现 E:\xampp\tmp\这个目录下是空的，并没有我们上传的文件 这是因为这其实是一个临时文件夹，如果我们需要永久保存我们想要的内容我们需要将文件保存到我们自己建立的一个文件夹中。 这个时候我们就需要使用到这个函数move_uploaded_file(file,newloc)第一个参数规定文件的原路径，第二个参数规定文件的新路径已经文件名。 下面将代码改进一下：加上一行代码：1move_uploaded_file($fileInfo['tmp_name'],"./test_imgs/".$fileInfo['name']); 这个时候我们再看设置的那个新路径，就已经成功将文件移动过来了。 总结：上传文件的表单与其他表单有些许不一样，要多注意，获取内容的方法也不太一样，并且要注意move_uploaded_file函数的使用，第二个参数写相对路径的时候，如果是相对与当前路径开始的话一定不能遗漏了./来表示当前路径，比如我刚开始这样写就报错：&quot;test_imgs/&quot;,而这样写就是对的:&quot;./test_imgs/&quot;所以以后要多注意。]]></content>
  </entry>
  <entry>
    <title><![CDATA[jQuery中eq与get的区别]]></title>
    <url>%2F2019%2F05%2F20%2FjQuery%E4%B8%ADeq%E4%B8%8Eget%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在刚开始学习使用jQuery的时候就遇到过类似的问题，没有完全理解到什么是jQuery对象以它与Element对象的区别。而jQuery中的eq方法与get方法正好也是这方面的区别，这次来好好把他们区分一下。先上一段html代码1234&lt;body&gt; &lt;div class="test1"&gt;这是一个测试div &lt;span&gt;这是一个子元素&lt;/span&gt;&lt;/div&gt; &lt;div class="test2"&gt;这是第二个测试div&lt;/div&gt;&lt;/body&gt; js代码12345678910111213141516171819202122232425262728&lt;script&gt; $(function()&#123; // 通过这个可以看出使用核心函数选择div会将它转化成一个jQuery对象，jQuery对象的本质是一个数组对象，有length属性 console.log( $('div') ); // 而我们通过get方法获取到的对象其实是一个Element对象 console.log( $('div').get(0) ); // 所以我们就可以对它使用js原生的方法来获取它的子节点 console.log( $('div').get(0).children[0] ); // 而这种写法获取到的东西是和get所获取到的东西是一模一样的 console.log( $('div')[1] ); // 而通过eq获取到的其实是一个jQuery对象 console.log( $('div').eq(0) ); // 我们亦可以通过jQuery的核心函数将Element对象转化成jQuery对象 console.log( $($('div').get(0)) ); &#125;) &lt;/script&gt; 我们再来看看输出的结果: 总结:eq与get的区别十分的明显,一个获取到的是jQuery对象,一个获取到的是Element对象,而我们的jQuery的方法只能对jQuery对象使用,所以我们要特别注意我们获取到的是什么对象,当然我们也可以通过jQuery核心函数将Element对象转化为jQuery对象.]]></content>
  </entry>
  <entry>
    <title><![CDATA[flex使用的小demo]]></title>
    <url>%2F2019%2F05%2F18%2Fflex%E4%BD%BF%E7%94%A8%E7%9A%84%E5%B0%8Fdemo%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前面学习了flex的相关知识，现在就这些知识运用到实例，通过写一个导航栏和一个搜索框试试效果怎么样。 通过flex布局一个等分的导航栏代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;style&gt;*&#123; margin: 0; padding: 0; list-style: none;&#125;nav&#123; width: 40%; height: 50px; background: #ccc; margin: 0 auto;&#125;nav&gt;ul&#123; display: flex; height: 100%; width: 100%; flex-flow: row nowrap; /* justify-content: space-around; */ align-items: center;&#125;/* 通过给子元素使用flex-grow会影响到父元素设置的justify-content，但是无论使用哪种方法都能达到相同的效果 */ul&gt;li&#123; text-align: center;&#125;/* 以下代码其实都可以不用，只通过一个justify-content: space-between就能达到这种效果 */ul&gt;li:nth-child(1)&#123; flex: 0 0 auto; text-align: center;&#125;ul&gt;li:nth-child(2)&#123; flex: auto; text-align: center;&#125;ul&gt;li:nth-child(3)&#123; flex: auto; text-align: center;&#125;ul&gt;li:nth-child(4)&#123; flex: auto; flex: 0 0 auto;&#125;&lt;/style&gt;&lt;body&gt; &lt;nav&gt; &lt;ul&gt; &lt;li&gt;栏目一&lt;/li&gt; &lt;li&gt;栏目二&lt;/li&gt; &lt;li&gt;栏目三&lt;/li&gt; &lt;li&gt;栏目四&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt;&lt;/body&gt; 效果图： 通过flex布局一个搜索框代码：12345678910111213141516171819202122232425262728293031323334&lt;style&gt;*&#123; margin: 0; padding: 0; list-style: none;&#125;.search&#123; margin: 0 auto; margin-top: 20px; width: 500px; display: flex;&#125;input&#123; /* 因为默认另一个button的flex-grow为0， 只要设置这个输入框的flex-grow为1则可以占满剩下的宽度 */ flex-grow: 1;&#125;button&#123; border: 0; background-color: red; outline: none; height: 30px; /* 当我们把button的高度调高之后，可以发现输入框的高度也一起随之升高了 如果想要改变这种效果可以对输入框设置align-self */&#125;&lt;/style&gt;&lt;body&gt; &lt;div class="search"&gt; &lt;input type="text"&gt; &lt;button&gt;点击搜索&lt;/button&gt; &lt;/div&gt;&lt;/body&gt; 效果图： 总结使用flex布局真的好轻松，好方便啊，再也不用为各种繁琐的事情改开改去了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[CSS3_flex的使用]]></title>
    <url>%2F2019%2F05%2F18%2FCSS3-flex%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前段时间有了解到flex布局，flex布局是W3C再2009年提出的一种新的方案，且现在已经兼容所有的浏览器，传统的布局方式在有些时候会比较麻烦，且兼容性不是特别好，那么使用flex布局就能解决很多问题，这次来学习以下flex布局，并加以使用，以后熟练使用就能大大提高我们的布局效率。 Flex布局是什么？Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。123.box&#123; display: flex;&#125; 行内元素也可以使用Flex布局。123.box&#123; display: inline-flex;&#125; Webkit内核的浏览器，必须加上-webkit前缀。1234.box&#123; display: -webkit-flex; /* Safari */ display: flex;&#125; 注意:设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。 基本概念采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 容器的属性容器有以下6个属性： flex-direction flex-wrap flex-flow justify-content align-items align-content flex-direction属性flex-direction属性决定主轴的方向（即项目的排列方向）。123.box &#123; flex-direction: row | row-reverse | column | column-reverse;&#125; 可能有4个值： row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 flex-wrap属性默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。123.box&#123; flex-wrap: nowrap | wrap | wrap-reverse;&#125; 它可能取三个值: nowrap（默认）：不换行。 wrap：换行，第一行在上方。 wrap-reverse：换行，第一行在下方。 flex-flowflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。123.box &#123; flex-flow: &lt;flex-direction&gt; &lt;flex-wrap&gt;;&#125; justify-content属性justify-content属性定义了项目在主轴上的对齐方式。123.box &#123; justify-content: flex-start | flex-end | center | space-between | space-around;&#125; 可能取5个值，与主轴方向有关（以下假设主轴从左向右）： flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 （在做菜单栏导航栏等需要间隔相等的项目中十分有用） space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 align-items属性align-items属性定义项目在交叉轴上如何对齐。123.box &#123; align-items: flex-start | flex-end | center | baseline | stretch;&#125; 可能取5个值，与交叉轴方向有关（以下假设主轴从上向下） flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 align-content属性align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。123.box &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125; 该属性可能取6个值： flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 项目的属性以下6个属性设置在项目上。 order flex-grow flex-shrink flex-basis flex align-self order属性order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。123.item &#123; order: &lt;integer&gt;;&#125; flex-grow属性flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。123.item &#123; flex-grow: &lt;number&gt;; /* default 0 */&#125; 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 flex-shrink属性flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。123.item &#123; flex-shrink: &lt;number&gt;; /* default 1 */&#125; 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。负值对该属性无效。 flex-basis属性flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。123.item &#123; flex-basis: &lt;length&gt; | auto; /* default auto */&#125; 它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。 flex属性flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。123.item &#123; flex: none | [ &lt;&apos;flex-grow&apos;&gt; &lt;&apos;flex-shrink&apos;&gt;? || &lt;&apos;flex-basis&apos;&gt; ]&#125; 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 align-self属性align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。123.item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch;&#125; 该属性可能取6个值，除了auto，其他都与align-items属性完全一致。 文章转载自：http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[jQuery学习（动画效果）]]></title>
    <url>%2F2019%2F05%2F15%2FjQuery%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这次总结以下jQuery中所有自带的动画效果以及jQuery中的自定义动画，以及动画1的其他一些相关方法，帮助我们更好的学习和使用jQuery中的动画。前面已经学习使用过大部分自带动画了，这次着重讲一下自定义动画与其他方法。 显示、隐藏动画show([s,[e],[fn]]) 显示动画 内部实现原理根据当前操作的元素是块级还是行内决定, 块级内部调用display:block;,行内内部调用display:inline; hide([s,[e],[fn]]) 隐藏动画 toggle([spe],[eas],[fn]) 切换动画(显示变隐藏,隐藏变显示) 注意事项: show(1000, function () {};) 第一个参数单位是毫秒, 1000毫秒等于1秒 默认的动画时长是400毫秒 除了指定毫秒以外还可以指定三个预设参数 slow、normal、fast slow本质是600毫秒 normal本质是400毫秒 fast本质是200毫秒 展开、收起动画参数、注意事项和显示隐藏动画一模一样, 只不过动画效果不一样而已 slideDown([s],[e],[fn])展开动画 slideUp([s,[e],[fn]])收起动画 slideToggle([s],[e],[fn])切换动画(展开变收起,收起变展开)参数、注意事项和显示隐藏动画一模一样, 只不过动画效果不一样而已 fadeIn([s],[e],[fn])淡入动画 fadeOut([s],[e],[fn])淡出动画 fadeToggle([s,[e],[fn]])切换动画(显示变淡出,不显示变淡入) fadeTo([[s],o,[e],[fn]])淡入到指定透明度动画可以通过第二个参数,淡入到指定的透明度(取值范围0~1) 自定义动画有时候自带的这些动画不能完全满足我们的需求，我们就需要使用到自定义动画来帮助我们完成动画。 animate(p,[s],[e],[fn]) 第一个参数: 接收一个对象, 可以在对象中修改属性 第二个参数: 指定动画时长 第三个参数: 指定动画节奏, 默认就是swing 第四个参数: 动画执行完毕之后的回调函数下面是一个自定义动画的例子：123456789101112131415161718192021222324252627282930313233&lt;style&gt;.test&#123; background: red; width: 200px; height: 200px; border-radius: 50%;&#125;&lt;/style&gt;&lt;body&gt; &lt;div class="test"&gt;&lt;/div&gt; &lt;script&gt; $(function()&#123; // 使圆变大 $('.test').animate(&#123; // 可以同时设置多个值的变化 width:400, height:400, // 可以设置动画节奏 &#125;,2000,'Linear',function()&#123; // 可以链式设置多个动画 alert('变大执行完毕') &#125;).animate(&#123; marginLeft:200 &#125;,2000,function()&#123; alert('右移执行完毕') &#125;).animate(&#123; marginLeft:"800" &#125;,2000,function()&#123; alert('完成') &#125;); &#125;) &lt;/script&gt;&lt;/body&gt; 要注意的一点:每次开始运动都必须是初始位置或者初始状态,如果想在上一次位置或者状态下再次进行动画可以使用累加动画,上面这个例子就是圆先变大,然后在变大之前的圆心处右移,然后再回到圆心处再次右移,所以要使用累计动画的方式来设置参数比如说{marginLeft:&quot;+=200&quot;} 动画队列 多个动画方法链式编程,会等到前面的动画执行完毕再依次执行后续动画 但是如果后面紧跟一个非动画方法则会被立即执行 如果想颜色再动画执行完毕之后设置, 1.使用回调 2.使用动画队列 注意点:动画队列方法queue()后面不能继续直接添加queue()如果想继续添加必须在上一个queue()方法中next()方法 动画相关方法 delay(d,[q])设置动画延迟时长 stop([c],[j])停止指定元素上正在执行的动画1234567891011121314// 立即停止当前动画, 继续执行后续的动画// $(&quot;div&quot;).stop();// $(&quot;div&quot;).stop(false);// $(&quot;div&quot;).stop(false, false);// 立即停止当前和后续所有的动画// $(&quot;div&quot;).stop(true);// $(&quot;div&quot;).stop(true, false);// 立即完成当前的, 继续执行后续动画// $(&quot;div&quot;).stop(false, true);// 立即完成当前的, 并且停止后续所有的$(&quot;div&quot;).stop(true, true);]]></content>
  </entry>
  <entry>
    <title><![CDATA[Chrome插件(扩展)开发全攻略]]></title>
    <url>%2F2019%2F05%2F15%2FChrome%E6%8F%92%E4%BB%B6(%E6%89%A9%E5%B1%95)%E5%BC%80%E5%8F%91%E5%85%A8%E6%94%BB%E7%95%A5%2F</url>
    <content type="text"><![CDATA[写在前面 这篇文章来自于转载，作者花了许多时间编写，写的也很详细，也很辛苦，我已经在文章尾部标明，也感谢作者的分享，这是文章原地址以下是作者原文：来源我花了将近一个多月的时间断断续续写下这篇博文，并精心写下完整demo，写博客的辛苦大家懂的，所以转载务必保留出处。本文所有涉及到的大部分代码均在这个demo里面：https://github.com/sxei/chrome-plugin-demo ，大家可以直接下载下来运行。 另外，本文图片较多，且图片服务器带宽有限，右下角的目录滚动监听必须等到图片全部加载完毕之后才会触发，所以请耐心等待加载完毕。 本文目录： demo部分截图： 前言 2.1. 什么是Chrome插件 严格来讲，我们正在说的东西应该叫Chrome扩展(Chrome Extension)，真正意义上的Chrome插件是更底层的浏览器功能扩展，可能需要对浏览器源码有一定掌握才有能力去开发。鉴于Chrome插件的叫法已经习惯，本文也全部采用这种叫法，但读者需深知本文所描述的Chrome插件实际上指的是Chrome扩展。 Chrome插件是一个用Web技术开发、用来增强浏览器功能的软件，它其实就是一个由HTML、CSS、JS、图片等资源组成的一个.crx后缀的压缩包. 个人猜测crx可能是Chrome Extension如下3个字母的简写： 另外，其实不只是前端技术，Chrome插件还可以配合C++编写的dll动态链接库实现一些更底层的功能(NPAPI)，比如全屏幕截图。 由于安全原因，Chrome浏览器42以上版本已经陆续不再支持NPAPI插件，取而代之的是更安全的PPAPI。 2.2. 学习Chrome插件开发有什么意义 增强浏览器功能，轻松实现属于自己的“定制版”浏览器，等等。 Chrome插件提供了很多实用API供我们使用，包括但不限于： 书签控制； 下载控制； 窗口控制； 标签控制； 网络请求控制，各类事件监听； 自定义原生菜单； 完善的通信机制； 等等； 2.3. 为什么是Chrome插件而不是Firefox插件 Chrome占有率更高，更多人用； 开发更简单； 应用场景更广泛，Firefox插件只能运行在Firefox上，而Chrome除了Chrome浏览器之外，还可以运行在所有webkit内核的国产浏览器，比如360极速浏览器、360安全浏览器、搜狗浏览器、QQ浏览器等等； 除此之外，Firefox浏览器也对Chrome插件的运行提供了一定的支持； 开发与调试 Chrome插件没有严格的项目结构要求，只要保证本目录有一个manifest.json即可，也不需要专门的IDE，普通的web开发工具即可。 从右上角菜单-&gt;更多工具-&gt;扩展程序可以进入 插件管理页面，也可以直接在地址栏输入 chrome://extensions 访问。 勾选开发者模式即可以文件夹的形式直接加载插件，否则只能安装.crx格式的文件。Chrome要求插件必须从它的Chrome应用商店安装，其它任何网站下载的都无法直接安装，所以，其实我们可以把crx文件解压，然后通过开发者模式直接加载。 开发中，代码有任何改动都必须重新加载插件，只需要在插件管理页按下Ctrl+R即可，以防万一最好还把页面刷新一下。 核心介绍 4.1. manifest.json 这是一个Chrome插件最重要也是必不可少的文件，用来配置所有和插件相关的配置，必须放在根目录。其中，manifest_version、name、version3个是必不可少的，description和icons是推荐的。 下面给出的是一些常见的配置项，均有中文注释，完整的配置文档请戳这里。 { // 清单文件的版本，这个必须写，而且必须是2 "manifest_version": 2, // 插件的名称 "name": "demo", // 插件的版本 "version": "1.0.0", // 插件描述 "description": "简单的Chrome扩展demo", // 图标，一般偷懒全部用一个尺寸的也没问题 "icons": { "16": "img/icon.png", "48": "img/icon.png", "128": "img/icon.png" }, // 会一直常驻的后台JS或后台页面 "background": { // 2种指定方式，如果指定JS，那么会自动生成一个背景页 "page": "background.html" //"scripts": ["js/background.js"] }, // 浏览器右上角图标设置，browser_action、page_action、app必须三选一 "browser_action": { "default_icon": "img/icon.png", // 图标悬停时的标题，可选 "default_title": "这是一个示例Chrome插件", "default_popup": "popup.html" }, // 当某些特定页面打开才显示的图标 /*"page_action": { "default_icon": "img/icon.png", "default_title": "我是pageAction", "default_popup": "popup.html" },*/ // 需要直接注入页面的JS "content_scripts": [ { //"matches": ["http://*/*", "https://*/*"], // "&lt;all_urls&gt;" 表示匹配所有地址 "matches": ["&lt;all_urls&gt;"], // 多个JS按顺序注入 "js": ["js/jquery-1.8.3.js", "js/content-script.js"], // JS的注入可以随便一点，但是CSS的注意就要千万小心了，因为一不小心就可能影响全局样式 "css": ["css/custom.css"], // 代码注入的时间，可选值： "document_start", "document_end", or "document_idle"，最后一个表示页面空闲时，默认document_idle "run_at": "document_start" }, // 这里仅仅是为了演示content-script可以配置多个规则 { "matches": ["*://*/*.png", "*://*/*.jpg", "*://*/*.gif", "*://*/*.bmp"], "js": ["js/show-image-content-size.js"] } ], // 权限申请 "permissions": [ "contextMenus", // 右键菜单 "tabs", // 标签 "notifications", // 通知 "webRequest", // web请求 "webRequestBlocking", "storage", // 插件本地存储 "http://*/*", // 可以通过executeScript或者insertCSS访问的网站 "https://*/*" // 可以通过executeScript或者insertCSS访问的网站 ], // 普通页面能够直接访问的插件资源列表，如果不设置是无法直接访问的 "web_accessible_resources": ["js/inject.js"], // 插件主页，这个很重要，不要浪费了这个免费广告位 "homepage_url": "https://www.baidu.com", // 覆盖浏览器默认页面 "chrome_url_overrides": { // 覆盖浏览器默认的新标签页 "newtab": "newtab.html" }, // Chrome40以前的插件配置页写法 "options_page": "options.html", // Chrome40以后的插件配置页写法，如果2个都写，新版Chrome只认后面这一个 "options_ui": { "page": "options.html", // 添加一些默认的样式，推荐使用 "chrome_style": true }, // 向地址栏注册一个关键字以提供搜索建议，只能设置一个关键字 "omnibox": { "keyword" : "go" }, // 默认语言 "default_locale": "zh_CN", // devtools页面入口，注意只能指向一个HTML文件，不能是JS文件 "devtools_page": "devtools.html" } 4.2. content-scripts 所谓content-scripts，其实就是Chrome插件中向页面注入脚本的一种形式（虽然名为script，其实还可以包括css的），借助content-scripts我们可以实现通过配置的方式轻松向指定页面注入JS和CSS（如果需要动态注入，可以参考下文），最常见的比如：广告屏蔽、页面CSS定制，等等。 示例配置： { // 需要直接注入页面的JS "content_scripts": [ { //"matches": ["http://*/*", "https://*/*"], // "&lt;all_urls&gt;" 表示匹配所有地址 "matches": ["&lt;all_urls&gt;"], // 多个JS按顺序注入 "js": ["js/jquery-1.8.3.js", "js/content-script.js"], // JS的注入可以随便一点，但是CSS的注意就要千万小心了，因为一不小心就可能影响全局样式 "css": ["css/custom.css"], // 代码注入的时间，可选值： "document_start", "document_end", or "document_idle"，最后一个表示页面空闲时，默认document_idle "run_at": "document_start" } ], } 特别注意，如果没有主动指定run_at为document_start（默认为document_idle），下面这种代码是不会生效的： document.addEventListener('DOMContentLoaded', function() { console.log('我被执行了！'); }); content-scripts和原始页面共享DOM，但是不共享JS，如要访问页面JS（例如某个JS变量），只能通过injected js来实现。content-scripts不能访问绝大部分chrome.xxx.api，除了下面这4种： chrome.extension(getURL , inIncognitoContext , lastError , onRequest , sendRequest) chrome.i18n chrome.runtime(connect , getManifest , getURL , id , onConnect , onMessage , sendMessage) chrome.storage 其实看到这里不要悲观，这些API绝大部分时候都够用了，非要调用其它API的话，你还可以通过通信来实现让background来帮你调用（关于通信，后文有详细介绍）。 好了，Chrome插件给我们提供了这么强大的JS注入功能，剩下的就是发挥你的想象力去玩弄浏览器了。 4.3. background 后台（姑且这么翻译吧），是一个常驻的页面，它的生命周期是插件中所有类型页面中最长的，它随着浏览器的打开而打开，随着浏览器的关闭而关闭，所以通常把需要一直运行的、启动就运行的、全局的代码放在background里面。 background的权限非常高，几乎可以调用所有的Chrome扩展API（除了devtools），而且它可以无限制跨域，也就是可以跨域访问任何网站而无需要求对方设置CORS。 经过测试，其实不止是background，所有的直接通过chrome-extension://id/xx.html这种方式打开的网页都可以无限制跨域。 配置中，background可以通过page指定一张网页，也可以通过scripts直接指定一个JS，Chrome会自动为这个JS生成一个默认的网页： { // 会一直常驻的后台JS或后台页面 "background": { // 2种指定方式，如果指定JS，那么会自动生成一个背景页 "page": "background.html" //"scripts": ["js/background.js"] }, } 需要特别说明的是，虽然你可以通过chrome-extension://xxx/background.html直接打开后台页，但是你打开的后台页和真正一直在后台运行的那个页面不是同一个，换句话说，你可以打开无数个background.html，但是真正在后台常驻的只有一个，而且这个你永远看不到它的界面，只能调试它的代码。 4.4. event-pages 这里顺带介绍一下event-pages，它是一个什么东西呢？鉴于background生命周期太长，长时间挂载后台可能会影响性能，所以Google又弄一个event-pages，在配置文件上，它与background的唯一区别就是多了一个persistent参数： { "background": { "scripts": ["event-page.js"], "persistent": false }, } 它的生命周期是：在被需要时加载，在空闲时被关闭，什么叫被需要时呢？比如第一次安装、插件更新、有content-script向它发送消息，等等。 除了配置文件的变化，代码上也有一些细微变化，个人这个简单了解一下就行了，一般情况下background也不会很消耗性能的。 4.5. popup popup是点击browser_action或者page_action图标时打开的一个小窗口网页，焦点离开网页就立即关闭，一般用来做一些临时性的交互。 popup可以包含任意你想要的HTML内容，并且会自适应大小。可以通过default_popup字段来指定popup页面，也可以调用setPopup()方法。 配置方式： { "browser_action": { "default_icon": "img/icon.png", // 图标悬停时的标题，可选 "default_title": "这是一个示例Chrome插件", "default_popup": "popup.html" } } 需要特别注意的是，由于单击图标打开popup，焦点离开又立即关闭，所以popup页面的生命周期一般很短，需要长时间运行的代码千万不要写在popup里面。 在权限上，它和background非常类似，它们之间最大的不同是生命周期的不同，popup中可以直接通过chrome.extension.getBackgroundPage()获取background的window对象。 4.6. injected-script 这里的injected-script是我给它取的，指的是通过DOM操作的方式向页面注入的一种JS。为什么要把这种JS单独拿出来讨论呢？又或者说为什么需要通过这种方式注入JS呢？ 这是因为content-script有一个很大的“缺陷”，也就是无法访问页面中的JS，虽然它可以操作DOM，但是DOM却不能调用它，也就是无法在DOM中通过绑定事件的方式调用content-script中的代码（包括直接写onclick和addEventListener2种方式都不行），但是，“在页面上添加一个按钮并调用插件的扩展API”是一个很常见的需求，那该怎么办呢？其实这就是本小节要讲的。 在content-script中通过DOM方式向页面注入inject-script代码示例： // 向页面注入JS function injectCustomJs(jsPath) { jsPath = jsPath || 'js/inject.js'; var temp = document.createElement('script'); temp.setAttribute('type', 'text/javascript'); // 获得的地址类似：chrome-extension://ihcokhadfjfchaeagdoclpnjdiokfakg/js/inject.js temp.src = chrome.extension.getURL(jsPath); temp.onload = function() { // 放在页面不好看，执行完后移除掉 this.parentNode.removeChild(this); }; document.head.appendChild(temp); } 你以为这样就行了？执行一下你会看到如下报错： Denying load of chrome-extension://efbllncjkjiijkppagepehoekjojdclc/js/inject.js. Resources must be listed in the web_accessible_resources manifest key in order to be loaded by pages outside the extension. 意思就是你想要在web中直接访问插件中的资源的话必须显示声明才行，配置文件中增加如下： { // 普通页面能够直接访问的插件资源列表，如果不设置是无法直接访问的 "web_accessible_resources": ["js/inject.js"], } 至于inject-script如何调用content-script中的代码，后面我会在专门的一个消息通信章节详细介绍。 4.7. homepage_url 开发者或者插件主页设置，一般会在如下2个地方显示： Chrome插件的8种展示形式 5.1. browserAction(浏览器右上角) 通过配置browser_action可以在浏览器的右上角增加一个图标，一个browser_action可以拥有一个图标，一个tooltip，一个badge和一个popup。 示例配置如下： "browser_action": { "default_icon": "img/icon.png", "default_title": "这是一个示例Chrome插件", "default_popup": "popup.html" } 5.1.1. 图标 browser_action图标推荐使用宽高都为19像素的图片，更大的图标会被缩小，格式随意，一般推荐png，可以通过manifest中default_icon字段配置，也可以调用setIcon()方法。 5.1.2. tooltip 修改browser_action的manifest中default_title字段，或者调用setTitle()方法。 5.1.3. badge 所谓badge就是在图标上显示一些文本，可以用来更新一些小的扩展状态提示信息。因为badge空间有限，所以只支持4个以下的字符（英文4个，中文2个）。badge无法通过配置文件来指定，必须通过代码实现，设置badge文字和颜色可以分别使用setBadgeText()和setBadgeBackgroundColor()。 chrome.browserAction.setBadgeText({text: 'new'}); chrome.browserAction.setBadgeBackgroundColor({color: [255, 0, 0, 255]}); 效果： 5.2. pageAction(地址栏右侧) 所谓pageAction，指的是只有当某些特定页面打开才显示的图标，它和browserAction最大的区别是一个始终都显示，一个只在特定情况才显示。 需要特别说明的是早些版本的Chrome是将pageAction放在地址栏的最右边，左键单击弹出popup，右键单击则弹出相关默认的选项菜单： 而新版的Chrome更改了这一策略，pageAction和普通的browserAction一样也是放在浏览器右上角，只不过没有点亮时是灰色的，点亮了才是彩色的，灰色时无论左键还是右键单击都是弹出选项： 具体是从哪一版本开始改的没去仔细考究，反正知道v50.0的时候还是前者，v58.0的时候已改为后者。 调整之后的pageAction我们可以简单地把它看成是可以置灰的browserAction。 chrome.pageAction.show(tabId) 显示图标； chrome.pageAction.hide(tabId) 隐藏图标； 示例(只有打开百度才显示图标)： // manifest.json { "page_action": { "default_icon": "img/icon.png", "default_title": "我是pageAction", "default_popup": "popup.html" }, "permissions": ["declarativeContent"] } // background.js chrome.runtime.onInstalled.addListener(function(){ chrome.declarativeContent.onPageChanged.removeRules(undefined, function(){ chrome.declarativeContent.onPageChanged.addRules([ { conditions: [ // 只有打开百度才显示pageAction new chrome.declarativeContent.PageStateMatcher({pageUrl: {urlContains: 'baidu.com'}}) ], actions: [new chrome.declarativeContent.ShowPageAction()] } ]); }); }); 效果图： 5.3. 右键菜单 通过开发Chrome插件可以自定义浏览器的右键菜单，主要是通过chrome.contextMenusAPI实现，右键菜单可以出现在不同的上下文，比如普通页面、选中的文字、图片、链接，等等，如果有同一个插件里面定义了多个菜单，Chrome会自动组合放到以插件名字命名的二级菜单里，如下： 5.3.1. 最简单的右键菜单示例 // manifest.json {"permissions": ["contextMenus"]} // background.js chrome.contextMenus.create({ title: "测试右键菜单", onclick: function(){alert('您点击了右键菜单！');} }); 效果： 5.3.2. 添加右键百度搜索 // manifest.json {"permissions": ["contextMenus"， "tabs"]} // background.js chrome.contextMenus.create({ title: '使用度娘搜索：%s', // %s表示选中的文字 contexts: ['selection'], // 只有当选中文字时才会出现此右键菜单 onclick: function(params) { // 注意不能使用location.href，因为location是属于background的window对象 chrome.tabs.create({url: 'https://www.baidu.com/s?ie=utf-8&amp;wd=' + encodeURI(params.selectionText)}); } }); 效果如下： 5.3.3. 语法说明 这里只是简单列举一些常用的，完整API参见：https://developer.chrome.com/extensions/contextMenus chrome.contextMenus.create({ type: 'normal'， // 类型，可选：["normal", "checkbox", "radio", "separator"]，默认 normal title: '菜单的名字', // 显示的文字，除非为“separator”类型否则此参数必需，如果类型为“selection”，可以使用%s显示选定的文本 contexts: ['page'], // 上下文环境，可选：["all", "page", "frame", "selection", "link", "editable", "image", "video", "audio"]，默认page onclick: function(){}, // 单击时触发的方法 parentId: 1, // 右键菜单项的父菜单项ID。指定父菜单项将会使此菜单项成为父菜单项的子菜单 documentUrlPatterns: 'https://*.baidu.com/*' // 只在某些页面显示此右键菜单 }); // 删除某一个菜单项 chrome.contextMenus.remove(menuItemId)； // 删除所有自定义右键菜单 chrome.contextMenus.removeAll(); // 更新某一个菜单项 chrome.contextMenus.update(menuItemId, updateProperties); 5.4. override(覆盖特定页面) 使用override页可以将Chrome默认的一些特定页面替换掉，改为使用扩展提供的页面。 扩展可以替代如下页面： 历史记录：从工具菜单上点击历史记录时访问的页面，或者从地址栏直接输入 chrome://history 新标签页：当创建新标签的时候访问的页面，或者从地址栏直接输入 chrome://newtab 书签：浏览器的书签，或者直接输入 chrome://bookmarks 注意： 一个扩展只能替代一个页面； 不能替代隐身窗口的新标签页； 网页必须设置title，否则用户可能会看到网页的URL，造成困扰； 下面的截图是默认的新标签页和被扩展替换掉的新标签页。 代码（注意，一个插件只能替代一个默认页，以下仅为演示）： "chrome_url_overrides": { "newtab": "newtab.html", "history": "history.html", "bookmarks": "bookmarks.html" } 5.5. devtools(开发者工具) 5.5.1. 预热 使用过vue的应该见过这种类型的插件： 是的，Chrome允许插件在开发者工具(devtools)上动手脚，主要表现在： 自定义一个和多个和Elements、Console、Sources等同级别的面板； 自定义侧边栏(sidebar)，目前只能自定义Elements面板的侧边栏； 先来看2张简单的demo截图，自定义面板（判断当前页面是否使用了jQuery）： 自定义侧边栏（获取当前页面所有图片）： 5.5.2. devtools扩展介绍 主页：https://developer.chrome.com/extensions/devtools 来一张官方图片： 每打开一个开发者工具窗口，都会创建devtools页面的实例，F12窗口关闭，页面也随着关闭，所以devtools页面的生命周期和devtools窗口是一致的。devtools页面可以访问一组特有的DevTools API以及有限的扩展API，这组特有的DevTools API只有devtools页面才可以访问，background都无权访问，这些API包括： chrome.devtools.panels：面板相关； chrome.devtools.inspectedWindow：获取被审查窗口的有关信息； chrome.devtools.network：获取有关网络请求的信息； 大部分扩展API都无法直接被DevTools页面调用，但它可以像content-script一样直接调用chrome.extension和chrome.runtimeAPI，同时它也可以像content-script一样使用Message交互的方式与background页面进行通信。 5.5.3. 实例：创建一个devtools扩展 首先，要针对开发者工具开发插件，需要在清单文件声明如下： { // 只能指向一个HTML文件，不能是JS文件 "devtools_page": "devtools.html" } 这个devtools.html里面一般什么都没有，就引入一个js： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript" src="js/devtools.js"&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 可以看出来，其实真正代码是devtools.js，html文件是“多余”的，所以这里觉得有点坑，devtools_page干嘛不允许直接指定JS呢？ 再来看devtools.js的代码： // 创建自定义面板，同一个插件可以创建多个自定义面板 // 几个参数依次为：panel标题、图标（其实设置了也没地方显示）、要加载的页面、加载成功后的回调 chrome.devtools.panels.create('MyPanel', 'img/icon.png', 'mypanel.html', function(panel) { console.log('自定义面板创建成功！'); // 注意这个log一般看不到 }); // 创建自定义侧边栏 chrome.devtools.panels.elements.createSidebarPane("Images", function(sidebar) { // sidebar.setPage('../sidebar.html'); // 指定加载某个页面 sidebar.setExpression('document.querySelectorAll("img")', 'All Images'); // 通过表达式来指定 //sidebar.setObject({aaa: 111, bbb: 'Hello World!'}); // 直接设置显示某个对象 }); setPage时的效果： 以下截图示例的代码： // 检测jQuery document.getElementById('check_jquery').addEventListener('click', function() { // 访问被检查的页面DOM需要使用inspectedWindow // 简单例子：检测被检查页面是否使用了jQuery chrome.devtools.inspectedWindow.eval("jQuery.fn.jquery", function(result, isException) { var html = ''; if (isException) html = '当前页面没有使用jQuery。'; else html = '当前页面使用了jQuery，版本为：'+result; alert(html); }); }); // 打开某个资源 document.getElementById('open_resource').addEventListener('click', function() { chrome.devtools.inspectedWindow.eval("window.location.href", function(result, isException) { chrome.devtools.panels.openResource(result, 20, function() { console.log('资源打开成功！'); }); }); }); // 审查元素 document.getElementById('test_inspect').addEventListener('click', function() { chrome.devtools.inspectedWindow.eval("inspect(document.images[0])", function(result, isException){}); }); // 获取所有资源 document.getElementById('get_all_resources').addEventListener('click', function() { chrome.devtools.inspectedWindow.getResources(function(resources) { alert(JSON.stringify(resources)); }); }); 5.5.4. 调试技巧 修改了devtools页面的代码时，需要先在 chrome://extensions 页面按下Ctrl+R重新加载插件，然后关闭再打开开发者工具即可，无需刷新页面（而且只刷新页面不刷新开发者工具的话是不会生效的）。 由于devtools本身就是开发者工具页面，所以几乎没有方法可以直接调试它，直接用 chrome-extension://extid/devtools.html"的方式打开页面肯定报错，因为不支持相关特殊API，只能先自己写一些方法屏蔽这些错误，调试通了再放开。 5.6. option(选项页) 所谓options页，就是插件的设置页面，有2个入口，一个是右键图标有一个“选项”菜单，还有一个在插件管理页面： 在Chrome40以前，options页面和其它普通页面没什么区别，Chrome40以后则有了一些变化。 我们先看老版的options： { // Chrome40以前的插件配置页写法 "options_page": "options.html", } 这个页面里面的内容就随你自己发挥了，配置之后在插件管理页就会看到一个选项按钮入口，点进去就是打开一个网页，没啥好讲的。 效果: 再来看新版的optionsV2： { "options_ui": { "page": "options.html", // 添加一些默认的样式，推荐使用 "chrome_style": true }, } options.html的代码我们没有任何改动，只是配置文件改了，之后效果如下： 看起来是不是高大上了？ 几点注意： 为了兼容，建议2种都写，如果都写了，Chrome40以后会默认读取新版的方式； 新版options中不能使用alert； 数据存储建议用chrome.storage，因为会随用户自动同步； 5.7. omnibox omnibox是向用户提供搜索建议的一种方式。先来看个gif图以便了解一下这东西到底是个什么鬼： 注册某个关键字以触发插件自己的搜索建议界面，然后可以任意发挥了。 首先，配置文件如下： { // 向地址栏注册一个关键字以提供搜索建议，只能设置一个关键字 "omnibox": { "keyword" : "go" }, } 然后background.js中注册监听事件： // omnibox 演示 chrome.omnibox.onInputChanged.addListener((text, suggest) =&gt; { console.log('inputChanged: ' + text); if(!text) return; if(text == '美女') { suggest([ {content: '中国' + text, description: '你要找“中国美女”吗？'}, {content: '日本' + text, description: '你要找“日本美女”吗？'}, {content: '泰国' + text, description: '你要找“泰国美女或人妖”吗？'}, {content: '韩国' + text, description: '你要找“韩国美女”吗？'} ]); } else if(text == '微博') { suggest([ {content: '新浪' + text, description: '新浪' + text}, {content: '腾讯' + text, description: '腾讯' + text}, {content: '搜狐' + text, description: '搜索' + text}, ]); } else { suggest([ {content: '百度搜索 ' + text, description: '百度搜索 ' + text}, {content: '谷歌搜索 ' + text, description: '谷歌搜索 ' + text}, ]); } }); // 当用户接收关键字建议时触发 chrome.omnibox.onInputEntered.addListener((text) =&gt; { console.log('inputEntered: ' + text); if(!text) return; var href = ''; if(text.endsWith('美女')) href = 'http://image.baidu.com/search/index?tn=baiduimage&amp;ie=utf-8&amp;word=' + text; else if(text.startsWith('百度搜索')) href = 'https://www.baidu.com/s?ie=UTF-8&amp;wd=' + text.replace('百度搜索 ', ''); else if(text.startsWith('谷歌搜索')) href = 'https://www.google.com.tw/search?q=' + text.replace('谷歌搜索 ', ''); else href = 'https://www.baidu.com/s?ie=UTF-8&amp;wd=' + text; openUrlCurrentTab(href); }); // 获取当前选项卡ID function getCurrentTabId(callback) { chrome.tabs.query({active: true, currentWindow: true}, function(tabs) { if(callback) callback(tabs.length ? tabs[0].id: null); }); } // 当前标签打开某个链接 function openUrlCurrentTab(url) { getCurrentTabId(tabId =&gt; { chrome.tabs.update(tabId, {url: url}); }) } 5.8. 桌面通知 Chrome提供了一个chrome.notificationsAPI以便插件推送桌面通知，暂未找到chrome.notifications和HTML5自带的Notification的显著区别及优势。 在后台JS中，无论是使用chrome.notifications还是Notification都不需要申请权限（HTML5方式需要申请权限），直接使用即可。 最简单的通知： 代码： chrome.notifications.create(null, { type: 'basic', iconUrl: 'img/icon.png', title: '这是标题', message: '您刚才点击了自定义右键菜单！' }); 通知的样式可以很丰富： 这个没有深入研究，有需要的可以去看官方文档。 5种类型的JS对比 Chrome插件的JS主要可以分为这5类：injected script、content-script、popup js、background js和devtools js， 6.1. 权限对比 {% raw %} JS种类 可访问的API DOM访问情况 JS访问情况 直接跨域 injected script 和普通JS无任何差别，不能访问任何扩展API 可以访问 可以访问 不可以 content script 只能访问 extension、runtime等部分API 可以访问 不可以 不可以 popup js 可访问绝大部分API，除了devtools系列 不可直接访问 不可以 可以 background js 可访问绝大部分API，除了devtools系列 不可直接访问 不可以 可以 devtools js 只能访问 devtools、extension、runtime等部分API 可以 可以 不可以 6.2. 调试方式对比 JS类型 调试方式 图片说明 injected script 直接普通的F12即可 懒得截图 content-script 打开Console,如图切换 popup-js popup页面右键审查元素 background 插件管理页点击背景页即可 devtools-js 暂未找到有效方法 - {% endraw %} 消息通信 通信主页：https://developer.chrome.com/extensions/messaging 前面我们介绍了Chrome插件中存在的5种JS，那么它们之间如何互相通信呢？下面先来系统概况一下，然后再分类细说。需要知道的是，popup和background其实几乎可以视为一种东西，因为它们可访问的API都一样、通信机制一样、都可以跨域。 7.1. 互相通信概览 注：-表示不存在或者无意义，或者待验证。 injected-script content-script popup-js background-js injected-script - window.postMessage - - content-script window.postMessage - chrome.runtime.sendMessage chrome.runtime.connect chrome.runtime.sendMessage chrome.runtime.connect popup-js - chrome.tabs.sendMessage chrome.tabs.connect - chrome.extension. getBackgroundPage() background-js - chrome.tabs.sendMessage chrome.tabs.connect chrome.extension.getViews - devtools-js chrome.devtools. inspectedWindow.eval - chrome.runtime.sendMessage chrome.runtime.sendMessage 7.2. 通信详细介绍 7.2.1. popup和background popup可以直接调用background中的JS方法，也可以直接访问background的DOM： // background.jsfunction test(){ alert(‘我是background！’);} // popup.jsvar bg = chrome.extension.getBackgroundPage();bg.test(); // 访问bg的函数alert(bg.document.body.innerHTML); // 访问bg的DOM 小插曲，今天碰到一个情况，发现popup无法获取background的任何方法，找了半天才发现是因为background的js报错了，而你如果不主动查看background的js的话，是看不到错误信息的，特此提醒。 至于background访问popup如下（前提是popup已经打开）： var views = chrome.extension.getViews({type:‘popup’});if(views.length &gt; 0) { console.log(views[0].location.href);} 7.2.2. popup或者bg向content主动发送消息 background.js或者popup.js： function sendMessageToContentScript(message, callback){ chrome.tabs.query({active: true, currentWindow: true}, function(tabs) { chrome.tabs.sendMessage(tabs[0].id, message, function(response) { if(callback) callback(response); }); });}sendMessageToContentScript({cmd:‘test’, value:‘你好，我是popup！’}, function(response){ console.log(‘来自content的回复：’+response);}); content-script.js接收： chrome.runtime.onMessage.addListener(function(request, sender, sendResponse){ // console.log(sender.tab ?”from a content script:” + sender.tab.url :”from the extension”); if(request.cmd == ‘test’) alert(request.value); sendResponse(‘我收到了你的消息！’);}); 双方通信直接发送的都是JSON对象，不是JSON字符串，所以无需解析，很方便（当然也可以直接发送字符串）。 网上有些老代码中用的是chrome.extension.onMessage，没有完全查清二者的区别(貌似是别名)，但是建议统一使用chrome.runtime.onMessage。 7.2.3. content-script主动发消息给后台 content-script.js： chrome.runtime.sendMessage({greeting: ‘你好，我是content-script呀，我主动发消息给后台！’}, function(response) { console.log(‘收到来自后台的回复：’ + response);}); background.js 或者 popup.js： // 监听来自content-script的消息chrome.runtime.onMessage.addListener(function(request, sender, sendResponse){ console.log(‘收到来自content-script的消息：’); console.log(request, sender, sendResponse); sendResponse(‘我是后台，我已收到你的消息：’ + JSON.stringify(request));}); 注意事项： content_scripts向popup主动发消息的前提是popup必须打开！否则需要利用background作中转； 如果background和popup同时监听，那么它们都可以同时收到消息，但是只有一个可以sendResponse，一个先发送了，那么另外一个再发送就无效； 7.2.4. injected script和content-script content-script和页面内的脚本（injected-script自然也属于页面内的脚本）之间唯一共享的东西就是页面的DOM元素，有2种方法可以实现二者通讯： 可以通过window.postMessage和window.addEventListener来实现二者消息通讯； 通过自定义DOM事件来实现； 第一种方法（推荐）： injected-script中： window.postMessage({“test”: ‘你好！’}, ‘*’); content script中： window.addEventListener(“message”, function(e){ console.log(e.data);}, false); 第二种方法： injected-script中： var customEvent = document.createEvent(‘Event’);customEvent.initEvent(‘myCustomEvent’, true, true);function fireCustomEvent(data) { hiddenDiv = document.getElementById(‘myCustomEventDiv’); hiddenDiv.innerText = data hiddenDiv.dispatchEvent(customEvent);}fireCustomEvent(‘你好，我是普通JS！’); content-script.js中： var hiddenDiv = document.getElementById(‘myCustomEventDiv’);if(!hiddenDiv) { hiddenDiv = document.createElement(‘div’); hiddenDiv.style.display = ‘none’; document.body.appendChild(hiddenDiv);}hiddenDiv.addEventListener(‘myCustomEvent’, function() { var eventData = document.getElementById(‘myCustomEventDiv’).innerText; console.log(‘收到自定义事件消息：’ + eventData);}); 7.3. 长连接和短连接 其实上面已经涉及到了，这里再单独说明一下。Chrome插件中有2种通信方式，一个是短连接（chrome.tabs.sendMessage和chrome.runtime.sendMessage），一个是长连接（chrome.tabs.connect和chrome.runtime.connect）。 短连接的话就是挤牙膏一样，我发送一下，你收到了再回复一下，如果对方不回复，你只能重新发，而长连接类似WebSocket会一直建立连接，双方可以随时互发消息。 短连接上面已经有代码示例了，这里只讲一下长连接。 popup.js： getCurrentTabId((tabId) =&gt; { var port = chrome.tabs.connect(tabId, {name: ‘test-connect’}); port.postMessage({question: ‘你是谁啊？’}); port.onMessage.addListener(function(msg) { alert(‘收到消息：’+msg.answer); if(msg.answer &amp;&amp; msg.answer.startsWith(‘我是’)) { port.postMessage({question: ‘哦，原来是你啊！’}); } });}); content-script.js： // 监听长连接chrome.runtime.onConnect.addListener(function(port) { console.log(port); if(port.name == ‘test-connect’) { port.onMessage.addListener(function(msg) { console.log(‘收到长连接消息：’, msg); if(msg.question == ‘你是谁啊？’) port.postMessage({answer: ‘我是你爸！’}); }); }}); 其它补充 8.1. 动态注入或执行JS 虽然在background和popup中无法直接访问页面DOM，但是可以通过chrome.tabs.executeScript来执行脚本，从而实现访问web页面的DOM（注意，这种方式也不能直接访问页面JS）。 示例manifest.json配置： { “name”: “动态JS注入演示”, … “permissions”: [ “tabs”, “http:///“, “https:///“ ], …} JS： // 动态执行JS代码chrome.tabs.executeScript(tabId, {code: ‘document.body.style.backgroundColor=”red”‘});// 动态执行JS文件chrome.tabs.executeScript(tabId, {file: ‘some-script.js’}); 8.2. 动态注入CSS 示例manifest.json配置： { “name”: “动态CSS注入演示”, … “permissions”: [ “tabs”, “http:///“, “https:///“ ], …} JS代码： // 动态执行CSS代码，TODO，这里有待验证chrome.tabs.insertCSS(tabId, {code: ‘xxx’});// 动态执行CSS文件chrome.tabs.insertCSS(tabId, {file: ‘some-style.css’}); 8.3. 获取当前窗口ID chrome.windows.getCurrent(function(currentWindow){ console.log(‘当前窗口ID：’ + currentWindow.id);}); 8.4. 获取当前标签页ID 一般有2种方法： // 获取当前选项卡IDfunction getCurrentTabId(callback){ chrome.tabs.query({active: true, currentWindow: true}, function(tabs) { if(callback) callback(tabs.length ? tabs[0].id: null); });} 获取当前选项卡id的另一种方法，大部分时候都类似，只有少部分时候会不一样（例如当窗口最小化时） // 获取当前选项卡IDfunction getCurrentTabId2(){ chrome.windows.getCurrent(function(currentWindow) { chrome.tabs.query({active: true, windowId: currentWindow.id}, function(tabs) { if(callback) callback(tabs.length ? tabs[0].id: null); }); });} 8.5. 本地存储 本地存储建议用chrome.storage而不是普通的localStorage，区别有好几点，个人认为最重要的2点区别是： chrome.storage是针对插件全局的，即使你在background中保存的数据，在content-script也能获取到； chrome.storage.sync可以跟随当前登录用户自动同步，这台电脑修改的设置会自动同步到其它电脑，很方便，如果没有登录或者未联网则先保存到本地，等登录了再同步至网络； 需要声明storage权限，有chrome.storage.sync和chrome.storage.local2种方式可供选择，使用示例如下： // 读取数据，第一个参数是指定要读取的key以及设置默认值chrome.storage.sync.get({color: ‘red’, age: 18}, function(items) { console.log(items.color, items.age);});// 保存数据chrome.storage.sync.set({color: ‘blue’}, function() { console.log(‘保存成功！’);}); 8.6. webRequest 通过webRequest系列API可以对HTTP请求进行任性地修改、定制，这里通过beforeRequest来简单演示一下它的冰山一角： //manifest.json{ // 权限申请 “permissions”: [ “webRequest”, // web请求 “webRequestBlocking”, // 阻塞式web请求 “storage”, // 插件本地存储 “http:///“, // 可以通过executeScript或者insertCSS访问的网站 “https:///“ // 可以通过executeScript或者insertCSS访问的网站 ],} // background.js// 是否显示图片var showImage;chrome.storage.sync.get({showImage: true}, function(items) { showImage = items.showImage;});// web请求监听，最后一个参数表示阻塞式，需单独声明权限：webRequestBlockingchrome.webRequest.onBeforeRequest.addListener(details =&gt; { // cancel 表示取消本次请求 if(!showImage &amp;&amp; details.type == ‘image’) return {cancel: true}; // 简单的音视频检测 // 大部分网站视频的type并不是media，且视频做了防下载处理，所以这里仅仅是为了演示效果，无实际意义 if(details.type == ‘media’) { chrome.notifications.create(null, { type: ‘basic’, iconUrl: ‘img/icon.png’, title: ‘检测到音视频’, message: ‘音视频地址：’ + details.url, }); }}, {urls: [“&lt;all_urls&gt;”]}, [“blocking”]); 8.7. 国际化 插件根目录新建一个名为_locales的文件夹，再在下面新建一些语言的文件夹，如en、zh_CN、zh_TW，然后再在每个文件夹放入一个messages.json，同时必须在清单文件中设置default_locale。 _locales\en\messages.json内容： { “pluginDesc”: {“message”: “A simple chrome extension demo”}, “helloWorld”: {“message”: “Hello World!”}} _locales\zh_CN\messages.json内容： { “pluginDesc”: {“message”: “一个简单的Chrome插件demo”}, “helloWorld”: {“message”: “你好啊，世界！”}} 在manifest.json和CSS文件中通过MSG_messagename引入，如： { “description”: “MSG_pluginDesc“, // 默认语言 “default_locale”: “zh_CN”,} JS中则直接chrome.i18n.getMessage(“helloWorld”)。 测试时，通过给chrome建立一个不同的快捷方式chrome.exe –lang=en来切换语言，如： 英文效果： 中文效果： 8.8. API总结 比较常用用的一些API系列： chrome.tabs chrome.runtime chrome.webRequest chrome.window chrome.storage chrome.contextMenus chrome.devtools chrome.extension 经验总结 9.1. 查看已安装插件路径 已安装的插件源码路径：C:\Users\用户名\AppData\Local\Google\Chrome\User Data\Default\Extensions，每一个插件被放在以插件ID为名的文件夹里面，想要学习某个插件的某个功能是如何实现的，看人家的源码是最好的方法了： 如何查看某个插件的ID？进入 chrome://extensions ，然后勾线开发者模式即可看到了。 9.2. 特别注意background的报错 很多时候你发现你的代码会莫名其妙的失效，找来找去又找不到原因，这时打开background的控制台才发现原来某个地方写错了导致代码没生效，正式由于background报错的隐蔽性(需要主动打开对应的控制台才能看到错误)，所以特别注意这点。 9.3. 如何让popup页面不关闭 在对popup页面审查元素的时候popup会被强制打开无法关闭，只有控制台关闭了才可以关闭popup，原因很简单：如果popup关闭了控制台就没用了。这种方法在某些情况下很实用！ 9.4. 不支持内联JavaScript的执行 也就是不支持将js直接写在html中，比如： &lt;input id=“btn” type=“button” value=“收藏” onclick=“test()”/&gt; 报错如下： Refused to execute inline event handler because it violates the following Content Security Policy directive: “script-src ‘self’ blob: filesystem: chrome-extension-resource:”. Either the ‘unsafe-inline’ keyword, a hash (‘sha256-…’), or a nonce (‘nonce-…’) is required to enable inline execution. 解决方法就是用JS绑定事件： $(‘#btn’).on(‘click’, function(){alert(‘测试’)}); 另外，对于A标签，这样写href=”javascript:;”然后用JS绑定事件虽然控制台会报错，但是不受影响，当然强迫症患者受不了的话只能写成href=”#”了。 如果这样写： &lt;a href=“javascript:;” id=“get_secret”&gt;请求secret&lt;/a&gt; 报错如下： Refused to execute JavaScript URL because it violates the following Content Security Policy directive: “script-src ‘self’ blob: filesystem: chrome-extension-resource:”. Either the ‘unsafe-inline’ keyword, a hash (‘sha256-…’), or a nonce (‘nonce-…’) is required to enable inline execution. 9.5. 注入CSS的时候必须小心 由于通过content_scripts注入的CSS优先级非常高，几乎仅次于浏览器默认样式，稍不注意可能就会影响一些网站的展示效果，所以尽量不要写一些影响全局的样式。 之所以强调这个，是因为这个带来的问题非常隐蔽，不太容易找到，可能你正在写某个网页，昨天样式还是好好的，怎么今天就突然不行了？然后你辛辛苦苦找来找去，找了半天才发现竟然是因为插件里面的一个样式影响的！ 打包与发布 打包的话直接在插件管理页有一个打包按钮： 然后会生成一个.crx文件，要发布到Google应用商店的话需要先登录你的Google账号，然后花5个$注册为开发者，本人太穷，就懒得亲自验证了，有发布需求的自己去整吧。 参考 11.1. 官方资料 推荐查看官方文档，虽然是英文，但是全且新，国内的中文资料都比较旧（注意以下全部需要FQ）： Chrome插件官方文档主页 Chrome插件官方示例 manifest清单文件 permissions权限 chrome.xxx.api文档 模糊匹配规则语法详解 11.2. 第三方资料 部分中文资料，不是特别推荐： 360安全浏览器开发文档 360极速浏览器Chrome扩展开发文档 Chrome扩展开发极客系列博客 附图 附图：Chrome高清png格式logo：个人网站：https://haoji.megithub：https://github.com/sxei博客园：http://www.cnblogs.com/liuxianancopyright ©2012-2018 小茗同学 【转载文章务必保留出处和署名，谢谢！】文章来源： 【干货】Chrome插件(扩展)开发全攻略]]></content>
  </entry>
  <entry>
    <title><![CDATA[jQuery动画做一个折叠菜单]]></title>
    <url>%2F2019%2F05%2F14%2FjQuery%E5%8A%A8%E7%94%BB%E5%81%9A%E4%B8%80%E4%B8%AA%E6%8A%98%E5%8F%A0%E8%8F%9C%E5%8D%95%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前面利用了jQuery动画做了一个对联广告，这次再次利用jQuery的其他动画做一个折叠菜单，做出一个较为美观的折叠菜单。直接上代码： css部分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;style&gt; * &#123; margin: 0; padding: 0; list-style: none; &#125; .l1&#123; width: 400px; margin: 0 auto; margin-top: 10px; &#125; .l1&gt;li&#123; /* border: 1px solid #000; border-collapse: collapse!important; */ outline: 1px solid black; font-size: 20px; /* height: 40px; line-height: 40px; */ &#125; .l1&gt;li&gt;div&#123; outline: 1px solid black; border-top: 1px solid #000; position: relative; &#125; .l1&gt;li&gt;div&gt;span&#123; display: inline-block; position: absolute; right: 10px; &#125; .l2&#123; display: none; &#125; .l2&gt;li&#123; /* outline: 1px solid black; */ /* border: 1px solid #000; */ border-collapse: collapse!important; font-size: 16px; height: 40px; line-height: 40px; &#125; .trans&#123; transform: rotate(90deg); -ms-transform: rotate(90deg); /* IE 9 */ -webkit-transform: rotate(90deg); /* Safari and Chrome */ -o-transform: rotate(90deg); /* Opera */ -moz-transform: rotate(90deg); /* Firefox */ &#125;&lt;/style&gt; html部分 12345678910111213141516171819202122232425262728293031323334353637383940&lt;body&gt; &lt;ul class="l1"&gt; &lt;li&gt; &lt;div&gt;一级菜单&lt;span&gt;&gt;&lt;/span&gt;&lt;/div&gt; &lt;ul class="l2"&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;div&gt;一级菜单&lt;span&gt;&gt;&lt;/span&gt;&lt;/div&gt; &lt;ul class="l2"&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;div&gt;一级菜单&lt;span&gt;&gt;&lt;/span&gt;&lt;/div&gt; &lt;ul class="l2"&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;div&gt;一级菜单&lt;span&gt;&gt;&lt;/span&gt;&lt;/div&gt; &lt;ul class="l2"&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/body&gt; js部分 12345678910111213141516&lt;script&gt; var index=1; $(function()&#123; $('.l1&gt;li&gt;div').click(function()&#123; index++; // 因为动画队列的存在，所以在执行新的动画之前要停止之前的动画 $(this).next().stop().slideToggle(); if(index%2==0)&#123; $(this).children().addClass('trans'); &#125; else&#123; $(this).children().removeClass('trans'); &#125; &#125;) &#125;) &lt;/script&gt; 效果图： 总结 要注意要找对执行动画的元素，可以用next(),chidren()等方法来找。 要注意动画队列，当我们快速多次的触发动画的时候，每触发一次就会加入动画队列，并且按照顺序会全部执行完毕，如果在执行新的动画之前我们不先停止之前的动画，那么就不会立即执行我们想要的动画，并且在我们不触发动画之后很有可能还会有很长一段的动画要执行。]]></content>
  </entry>
  <entry>
    <title><![CDATA[jQuery动画之写一个对联广告]]></title>
    <url>%2F2019%2F05%2F14%2FjQuery%E5%86%99%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%81%94%E5%B9%BF%E5%91%8A%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jQuery自带了许多动画效果，我们可以利用这些动画效果比较方便的做出一个对联广告。直接上代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;style&gt; body &#123; margin: 0; padding: 0; height: 2000px; &#125; .left, .right &#123; width: 80px; height: 200px; background: red; position: fixed; top: 260px; &#125; .right &#123; right: 0px; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class="left"&gt; &lt;/div&gt; &lt;div class="right"&gt; &lt;/div&gt; &lt;script&gt; $(function () &#123; $('.left,.right').hide(); // 在网页往下滚动之前先隐藏 var $height = $('body,html').scrollTop(); $(window).scroll(function () &#123; // 这里用到了scroll事件来监听网页的滚动 // 通过scrollTop方法来获取滚动的值 $height = $('body,html').scrollTop(); // 如果大于500就通过动画显示出来，否则隐藏 if ($height &gt;= 500) &#123; $('.left,.right').show(1000); &#125; else &#123; $('.left,.right').hide(1000); &#125; &#125;) &#125;) &lt;/script&gt;&lt;/body&gt; 总结： 这里一定要用到scroll事件，否则无法动态获取到滚动了多少 在使用scrollTop方法获取网页的滚动的值时一定要这样写$(&#39;body,html&#39;).scrollTop();既要写body，也要写html，兼容处理，如果只写一个可能会获取到不正确的值]]></content>
  </entry>
  <entry>
    <title><![CDATA[jQuery写一个简单的选项卡]]></title>
    <url>%2F2019%2F05%2F14%2FjQuery%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E9%80%89%E9%A1%B9%E5%8D%A1%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这次通过jQuery的方法来写一个小小的选项卡功能，通过jQuery实现起来也是十分的简单。直接上代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;style&gt; * &#123; margin: 0; padding: 0; list-style: none; &#125; div &#123; border: 1px solid #000; width: 800px; height: 400px; margin: 0 auto; position: relative; &#125; .ch &#123; top: 320px; left: 650px; position: absolute; &#125; .ch&gt;li &#123; display: inline-block; width: 20px; height: 20px; background-color: #ccc; margin-right: 10px; &#125; img &#123; width: 100%; height: 400px; display: none; &#125; .current &#123; display: block; background-color: red !important; &#125;&lt;/style&gt;&lt;body&gt; &lt;div&gt; &lt;ul class="imgs"&gt; &lt;li&gt;&lt;img class="current" src="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2489492398,1961915359&amp;fm=26&amp;gp=0.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1287814793,457485829&amp;fm=26&amp;gp=0.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1501075685,574908757&amp;fm=11&amp;gp=0.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=3662540589,314327097&amp;fm=11&amp;gp=0.jpg" alt=""&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ul class="ch"&gt; &lt;li class="current"&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; $(function () &#123; $('.ch&gt;li').mouseenter(function () &#123; $(this).addClass('current').siblings().removeClass('current'); // 给当前操作的小方块添加样式，其他的兄弟小方块去除样式 var index = $(this).index(); // 获取当前是第几个小方块，用来确定是第几张图片 $('.imgs&gt;li&gt;img').eq(index).addClass('current').parent().siblings().children() .removeClass('current'); // 给对应的图片添加样式，其他的图片删除样式 &#125;) &#125;) &lt;/script&gt;&lt;/body&gt; 效果图： 总结 写这个选项卡思路很简单，但是在布局的时候没有考虑好导致在给img标签删除样式的时候会比较麻烦，需要先找到父级li，然后找到他的兄弟，再找到他们的儿子，下次要注意避免出现这种情况。]]></content>
  </entry>
  <entry>
    <title><![CDATA[jQuery学习（事件处理）]]></title>
    <url>%2F2019%2F05%2F14%2FjQuery%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jQuery中也有许多事件处理的函数，功能强大，使用起来也比原声js要更加的简单和方便，这次学习以下jQuery的事件处理函数与冒泡行为以及自定义事件等等，以及动手实践，编写实例。 事件绑定jQuery中事件绑定有两种方式 eventName(function(){}) 绑定对应事件名的监听, 例如：$(‘#div’).click(function(){});优缺点：编写方便，但是不支持所有事件与自定义事件，但常用的事件基本上都是支持的。 on(eventName, funcion(){}) 通用的绑定事件监听, 例如：$(‘#div’).on(‘click’, function(){});优缺点：支持所有事件，但是编码的时候事件名要自己敲，但是最强大，支持所有事件与自定义事件。 事件解绑 jQuery中可以通过off(eventName,function);解绑事件 获取事件坐标当事件被触发时,系统会将事件对象(event)传递给回调函数,通过event对象我们就能获取时间的坐标，获取坐标有三种方式： event.offsetX, event.offsetY 相对于事件元素左上角 event.pageX, event.pageY 相对于页面的左上角 event.clientX, event.clientY 相对于视口的左上角 实例示例代码123456789101112131415161718192021222324252627&lt;style&gt;button&#123; margin-top: 600px;&#125;&lt;/style&gt;&lt;body&gt; &lt;button&gt;这是按钮一&lt;/button&gt; &lt;button&gt;这是按钮二&lt;/button&gt; &lt;button&gt;这是按钮三&lt;/button&gt; &lt;button&gt;这是按钮四&lt;/button&gt; &lt;script&gt; $(function()&#123; $('button').eq(0).click(function(Event)&#123; alert(Event.offsetY); // 结果：10 &#125;) $('button').eq(1).click(function(Event)&#123; alert(Event.pageY); // 结果：626 &#125;) $('button').eq(2).click(function(Event)&#123; alert(Event.clientY); // 结果：630 &#125;) &#125;) &lt;/script&gt;&lt;/body&gt; 阻止事件冒泡 什么是事件冒泡·事件冒泡就是同属说就是事件从里往外的一个触发过程1234567891011121314151617181920212223242526272829303132&lt;style&gt; .father &#123; width: 400px; height: 400px; background-color: red; &#125; .son &#123; width: 200px; height: 200px; background-color: blue; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class="father"&gt; 这是爸爸 &lt;div class="son"&gt; 这是儿子 &lt;/div&gt; &lt;/div&gt; &lt;script&gt; $(function () &#123; $('.father').click(function()&#123; alert('这是爸爸'); &#125;) $('.son').click(function()&#123; alert('这是儿子'); &#125;) &#125;) &lt;/script&gt;&lt;/body&gt; 当我单击了儿子之后，由于事件冒泡，事件会由里往外触发，所以先弹出儿子，再弹出爸爸，很多时候这都不是我们想要的结果，我们通常只是需要触发儿子的事件，所以这个时候我们就需要阻止事件冒泡。 如何阻止事件冒泡?event.stopPropagation()1234567891011$(function () &#123; $('.father').click(function()&#123; alert('这是爸爸'); &#125;) &lt;!-- 传递了事件对象 --&gt; $('.son').click(function(event)&#123; event.stopPropagation(); &lt;!-- 组阻止了事件冒泡 --&gt; alert('这是儿子'); &#125;) &#125;) 此时我们再次单击儿子就会发现就只弹出了儿子的单击事件，并没有触发父亲的事件，就达到了我们的效果 阻止默认行为 什么是默认行为·就是一些元素默认自带的行为，比如单击超链接会自动跳转等等。 如何阻止默认行为event.preventDefault()123456789&lt;a href="www.baidu.com"&gt;这是一个跳转到百度的超链接&lt;/a&gt;&lt;script&gt;$(function()&#123; $('a').click(function(event)&#123; event.preventDefault(); // 此时单击超链接时就不会进行跳转了 &#125;)&#125;)&lt;/script&gt; 自动触发事件 什么是自动触发事件?·通过代码控制事件, 不用人为点击/移入/移除等事件就能被触发 自动触发事件方式$(“selector”).trigger(“eventName”);触发事件的同时会触发事件冒泡触发事件的同时会触发事件默认行为$(“selector”).triggerHandler(“eventName”);触发事件的同时不会触发事件冒泡触发事件的同时不会触发事件默认行为 以triggerHandler()为例：12345678910111213&lt;body&gt; &lt;button&gt;这是一个按钮&lt;/button&gt; &lt;script&gt; $(function()&#123; $('button').eq(0).click(function()&#123; alert('我单击了按钮'); // 原本要单击才会弹出内容 &#125;) $('button').triggerHandler('click'); // 现在在网页出现后就会弹出 &#125;) &lt;/script&gt;&lt;/body&gt; 事件命名空间我们都知道jQuery可以给同一元素绑定多个相同的事件，且都能够触发，那么在多人开发中就可能会遇到多人对同意元素操作的情况，那么为了方便管理与区分，我们就可以在注册事件的时候使用命名空间 格式：eventName.命名空间，如 click.hsl() 添加事件命名空间的前提条件1、事件是通过on来绑定的，也就是这种方法on(eventName, funcion(){})2、通过trigger触发事件 注意点(面试题):·不带命名空间事件被trigger调用,会触发带命名空间事件·带命名空间事件被trigger调用,只会触发带命名空间事件·下级不带命名空间事件被trigger调用,会冒泡触发上级不带命名空间和带命名空间事件·下级带命名空间事件被trigger调用,不会触发上级不带命名空间事件·下级带命名空间事件被trigger调用,会触发上级带命名空间事件 自定义事件 什么是自定义事件？自定义事件，可以自己定义事件的名称，然后通过这个名称还能触发相应的功能 自定义事件的前提1、事件是通过on来绑定的，也就是这种方法on(eventName, funcion(){})2、通过trigger触发事件例如：12345678910111213&lt;body&gt; &lt;button&gt;这是一个按钮&lt;/button&gt; &lt;script&gt; $(function()&#123; $('button').on('hsl',function()&#123; alert('这是一个自定义事件！'); // 自定义了一个名为hsl的事件 &#125;) $('button').triggerHandler('hsl'); // 通过trigger来触发 &#125;) &lt;/script&gt;&lt;/body&gt; 事件委托 事件委托的原理&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;事件委托是通过冒泡机制来实现的，例如有一个父元素，里面有许多子元素，我们无需给这众多的子元素都添加单击事件，我们只需给父级元素添加一个单击事件，那么我们在单击子元素的时候，就会网上冒泡，执行父元素的事件，就相当于是委托父级元素来执行一样。 事件委托的好处&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;减少监听数量：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能，因为需要不断的与dom节点进行交互，访问dom的次数越多，引起浏览器重绘与重排的次数也就越多，就会延长整个页面的交互就绪时间每个监听的函数都是一个对象，是对象就会占用内存，对象越多，内存占用率就越大，自然性能就越差… …&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;新增元素自动有事件响应处理：默认的情况下新增元素是无法相应增添前就有的事件。就可以通过冒泡到原本就有的父级元素来触发事件。 jQuery中如何添加事件委托：delegate(selector,[type],[data],fn)下面看一个例子： 1234567891011121314151617181920&lt;body&gt; &lt;ul class="father"&gt; &lt;li class="son"&gt;这是内容&lt;/li&gt; &lt;li class="son"&gt;这是内容&lt;/li&gt; &lt;li class="son"&gt;这是内容&lt;/li&gt; &lt;/ul&gt; &lt;button&gt;增加li&lt;/button&gt; &lt;script&gt; $(function()&#123; $('.son').click(function()&#123; alert('我是原本就有的li'); // 单击li时应该会有弹窗 &#125;) $('button').click(function()&#123; $('.father').append('&lt;li&gt;我是新增的li&lt;/li&gt;') // 单击新增li &#125;) &#125;) &lt;/script&gt;&lt;/body&gt; 运行以上代码，我们可以发现一个问题，单击原有的li时会有弹窗，但是单击后面新创建的li时却并没有弹窗，因为我们没有给后面创建的li添加单击事件。 此时我们使用事件委托就可以解决问题：123456789101112131415161718192021222324&lt;body&gt; &lt;ul class="father"&gt; &lt;li class="son"&gt;这是内容&lt;/li&gt; &lt;li class="son"&gt;这是内容&lt;/li&gt; &lt;li class="son"&gt;这是内容&lt;/li&gt; &lt;/ul&gt; &lt;button&gt;增加li&lt;/button&gt; &lt;script&gt; $(function()&#123; // $('.son').click(function()&#123; // alert('我是原本就有的li'); // &#125;) // 原本的单击事件也可以不需要了 $('button').click(function()&#123; $('.father').append('&lt;li&gt;我是新增的li&lt;/li&gt;') &#125;) // 通过事件委托，新添加的也能有弹窗 $('.father').delegate('li','click',function()&#123; alert('我是li'); &#125;) &#125;) &lt;/script&gt;&lt;/body&gt; 改用事件委托后，不管是新添加的还是本身就存在的li，都能成功的弹窗(原理是向上冒泡，所以要支持冒泡的事件才能有效果)]]></content>
  </entry>
  <entry>
    <title><![CDATA[jQuery实现轮播图]]></title>
    <url>%2F2019%2F05%2F13%2FjQuery%E5%AE%9E%E7%8E%B0%E8%BD%AE%E6%92%AD%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最近开始尝试着自己写轮播图，知道轮播图的原理，通过js顶死器不断的重复的给要轮播的图片添加和删除样式，在css样式中通过display中的 none 和block 来切换显示的图片，再加上过渡效果即可实现好看的轮播图，我准备用递归函数写，但是却不知道在哪出现了问题，能够实现第一轮的正常轮播，但是后面的轮播却会出现问题，不断的检查问题，还是没有找出问题，最后放弃用递归的写法，再参考别人的代码，成功实现了轮播图功能。直接放上代码: html部分：12345678910111213141516171819202122232425&lt;div class="lunbo"&gt; &lt;div class="imgs"&gt; &lt;!-- 两个左右切换的按钮 --&gt; &lt;span class="left"&gt;&lt;&lt;/span&gt; &lt;span class="right"&gt;&gt;&lt;/span&gt; &lt;!-- 需要轮播的六张图片 --&gt; &lt;ul&gt; &lt;li class="current"&gt;&lt;img src="img/a.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="img/b.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="img/c.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="img/d.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="img/e.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="img/f.jpg" alt=""&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;!-- 图片下面部分可以用来切换图片的圆点 --&gt; &lt;ul class="dot"&gt; &lt;li class="current"&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; html部分比较简单。 css部分1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980*&#123; margin: 0; padding: 0; list-style: none; text-decoration: none;&#125;.lunbo&#123; width: 100%; height:400px; position: relative;&#125;.lunbo img&#123; width: 100%; height: 450px; position: absolute; top: 0px;&#125;.left&#123; position: absolute; display: inline-block; font-weight: bolder; z-index: 99; left: 0px; width: 50px; height: 100px; line-height: 100px; background: #ccc;; top: 135px; font-size: 60px; text-align: center; opacity: 0.3;&#125;.right&#123; position: absolute; display: inline-block; font-weight: bolder; z-index: 99; right: 0px; width: 50px; height: 100px; line-height: 100px; background: #ccc;; top: 135px; font-size: 60px; text-align: center; opacity: 0.3;&#125;.imgs&gt;ul li&#123; /* 先设置所有的图片都不显示 */ display: none;&#125;.imgs .current&#123; /* 让第一张图片显示 */ display: block;&#125;.dot .current&#123; /* 通过给小圆点来添加current类来使其变为红点 */ background:red;&#125;.dot&#123; z-index: 99; position: absolute; top:300px; /* 可以使所有的小圆点整体居中 */ left: 50%; transform: translate(-50%, -50%);&#125;.dot li&#123; /* 小圆点的默认样式 */ background: white; width: 15px; height: 15px; border-radius:50%; display: inline-block; margin-right: 20px;&#125;.dot&gt;li:hover&#123; /* 使鼠标经过左右切换的按钮变为一只手 */ cursor: pointer;&#125; 很正常的css样式设置，很多地方还不是特别的熟练，不是完美，代码还有很多可以优化的地方。 js部分 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950$(function () &#123; var timer = null; var cur = 0; var len = $(".imgs&gt;ul li").length; // 右切换 $('.right').click(function chr() &#123; cur = $('.dot&gt;.current').index(); if (cur == 5) &#123; $(".imgs&gt;ul li").eq(0).fadeIn(400).siblings("li").fadeOut(400); $(".dot&gt;li").eq(0).addClass("current").siblings().removeClass("current"); &#125; $(".dot&gt;li").eq(cur + 1).addClass("current").siblings().removeClass("current"); $(".imgs&gt;ul li").eq(cur + 1).fadeIn(400).siblings("li").fadeOut(400); &#125;); // 左切换 $('.left').click(function chl() &#123; cur = $('.dot&gt;.current').index(); if (cur == 0) &#123; $(".imgs&gt;ul li").eq(5).fadeIn(400).siblings("li").fadeOut(400); $(".dot&gt;li").eq(5).addClass("current").siblings().removeClass("current"); &#125; $(".dot&gt;li").eq(cur - 1).addClass("current").siblings().removeClass("current"); $(".imgs&gt;ul li").eq(cur - 1).fadeIn(400).siblings("li").fadeOut(400); &#125;); //鼠标滑过容器停止播放 $(".imgs").hover(function () &#123; clearInterval(timer); &#125;, function () &#123; showImg(); &#125;); // 遍历所有圆点导航实现划过切换至对应的图片 $(".dot&gt;li").click(function () &#123; clearInterval(timer); cur = $(this).index(); $(this).addClass("current").siblings().removeClass("current"); $(".imgs&gt;ul li").eq(cur).fadeIn(400).siblings("li").fadeOut(400); &#125;); //定义图片切换函数 function showImg() &#123; timer = setInterval(function () &#123; cur++; if (cur &gt;= len) &#123; cur = 0; &#125; $(".imgs&gt;ul li").eq(cur).fadeIn(400).siblings("li").fadeOut(400); $(".dot&gt;li").eq(cur).addClass("current").siblings().removeClass("current"); &#125;, 2000); &#125; showImg();&#125;); 最后整体思路没有变，但图片的切换就没有通过切换类来实现，而是使用了更加方便的jQuery的fadeIn()方法和fadeOut()，可以直接实现淡入淡出效果。 小圆点切换的实现还是通过切换类的方法 鼠标移到图片上自动停止播放则是通过jQuery的hover方法来实现的，移入的时候清除定时器，移出的时候再次执行切换函数的图片 点击小圆点切换图片这是通过，获取点击的那个小圆点的索引来定向切换图片 左右切换是获取当前小圆点的索引来定位，然后单击切换到下一张图片写这个花了很多时间，不过最后还是完成了，也学会了很多其他的东西。 最后是效果图]]></content>
  </entry>
  <entry>
    <title><![CDATA[关于float与inlie-block的使用]]></title>
    <url>%2F2019%2F05%2F13%2F%E5%85%B3%E4%BA%8Efloat%E4%B8%8Einlie-block%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽然之前有使用过float来把元素进行布局，但是发现这种方法存在缺点，后面发现还有display:inlie-block也能用来布局，但是在实际使用过后同样也发现一些问题，这次来讲一下这两种方式存在的问题以及解决办法。 关于float的使用使用float时存在的问题 可以看出当我们对子元素的div使用了float的时候，子元素成功浮动在了一行，但是父元素却出现了问题，父元素的宽度并没有被撑起，而是高度塌陷了，成为了一条线，这是因为使用了float之后会使文档脱离标准流，从而没有元素撑起父元素的高度。那么为了解决这个问题也有许多办法。 解决办法给父级元素设置一个固定的高度123.father&#123; height: 400px;&#125; 缺点：不够灵活 也给父级加上浮动123.father&#123; float: left;&#125; 缺点：会使父级与其他元素的关系发生变化，不推荐使用 给父级使用overflow + zoom1234.father&#123; overflow: hidden; zoom:1; /* 兼容处理,触发IE6/7的haslayout */&#125; 缺点：如果使用了定位，或者设置了边距的话，超出了父级的话将被隐藏但是使用起来比较方便，副作用也比较小比较好控制，推荐使用 在父级中加上一个div 兼容性较强 但是代码较多，且不利于维护优化 使用after伪元素1234567.father:after&#123; content: "."; /*生成内容作为最后一个元素，至于content里面是什么没有影响*/ display: block; /*使得生成的元素以块级元素显示，占满剩余空间*/ height: 0; /*避免生成的内容破坏原有空间的高度*/ clear: both; /*闭合浮动*/ visibility: hidden; /*使得生成内容不可见，并允许可能生成内容盖住的内容进行点击和交互*/&#125; 除了代码较多不好记之外是比较完美的解决方案，推荐使用。 使用了以上的办法，可以发现问题都能成功的解决。 关于display:inlie-block的使用使用display:inlie-block时存在的问题可以看出在使用display:inlie-block之后虽然子元素能够横向排列了，但是他们之间却会出现间隙，不过这种间隙不是来自边距，而是因为我们在书写div时回车会产生回车符，回车符相当于空白符，通常情况下，多个连续的空白符会合并成一个空白符，而产生“空白间隙”的真正原因就是这个让我们并不怎么注意的空白符。 解决办法我们可以发现其实这个空白符的间距其实是和字体大小有关系的，所以我们只需要将父级的字体大小设为0即可消去空白符。我们可以看到空白符已经被消去了，但是里面的字也不见了，所以我们要记得给子元素设置字体大小。 后面又发现的问题 通过图片我们可以看出，第一个和第三个子元素没有内容，那么他们就不会和有内容的子元素同占一行，会发生错位 而将他们同时设为有内容或者没有内容的时候这种情况就消失了，所以要十分注意这个问题]]></content>
  </entry>
  <entry>
    <title><![CDATA[jQuery学习（css样式操作）]]></title>
    <url>%2F2019%2F05%2F12%2FjQuery%E5%AD%A6%E4%B9%A0%EF%BC%88css%E6%A0%B7%E5%BC%8F%E6%93%8D%E4%BD%9C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言 这次学了jQuery关于css样式的操作，通过jQuery的方法给元素添加修改样式以及改变和获取元素的各种宽高。 操作css样式 css(name|pro|[,val|fn])方法格式1:DOM元素.css(“样式名称”, “值”);格式2:DOM元素.css({“样式名称1”:”值1”,”样式名称2”:”值2”}); 123456789101112131415&lt;body&gt;&lt;script&gt;$(function()&#123; var $test=$('.test'); $test.css('height','100px').css('outline','1px solid red'); // 这是第一种写法，添加多个css样式 $('.test').css(&#123; 'width':'200px', 'font-size':'30px', // 这是第二种添加css样式的方法 &#125;);&#125;)&lt;/script&gt;&lt;div class="test"&gt;这是一个测试div&lt;/div&gt;&lt;/body&gt; 操作尺寸width([val|fn])方法1234567891011121314&lt;body&gt;&lt;script&gt;$(function()&#123; var $test=$('.test'); console.log($test.width()); // 获取到数值为1520 $test.width('200px'); // 设置元素宽度为200px console.log($test.width()); // 结果为200&#125;)&lt;/script&gt;&lt;div class="test"&gt;这是一个测试div&lt;/div&gt;&lt;/body&gt; height([val|fn])方法 用法与效果与width方法一致 innerHeight()/innerWidth()获取第一个匹配元素内部区域高度/宽度（包括补白、不包括边框）。 outerHeight/outerWidth() 获取第一个匹配元素外部高度（默认包括补白和边框）。 设置为 true 时，计算边距在内。1234567891011121314&lt;body&gt;&lt;script&gt;$(function()&#123; var $test=$('.test'); console.log($test.outerHeight()); // 21 console.log($test.height()); // 21 console.log($test.outerHeight(true)); // 填入参数true时会获取边距的数值，此时设置了外边距，值为41 &#125;)&lt;/script&gt;&lt;div class="test"&gt;这是一个测试div&lt;/div&gt;&lt;/body&gt; 操作和获取元素位置offset([coordinates]) 获取或设置元素相对窗口的偏移位123456789101112131415161718192021&lt;style&gt;.test&#123; margin-top: 2000px; outline: 1px solid red; height: 20px;&#125;&lt;/style&gt;&lt;body&gt;&lt;script&gt;$(function()&#123; var $test=$('.test'); console.log($test.offset().top); // 获取到值为2000 $test.offset(&#123;top:200,left:200&#125;); console.log($test.offset()); // [object Object]: &#123;left: 200, top: 200&#125;，位置成功发生变化 &#125;)&lt;/script&gt;&lt;div class="test"&gt;这是一个测试div&lt;/div&gt;&lt;/body&gt; position()获取匹配元素相对父元素的偏移。返回的对象包含两个整型属性：top 和 left。为精确计算结果，请在补白、边框和填充属性上使用像素单位。此方法只对可见元素有效。12345678910111213141516171819202122232425&lt;style&gt;.test&#123; /* margin-top: 2000px; */ outline: 1px solid red; height: 20px; position: absolute; top: 20px; left: 20px;&#125;.father&#123; position: relative;&#125;&lt;/style&gt;&lt;body&gt;&lt;script&gt;$(function()&#123; var $test=$('.test'); console.log($test.position()); // 成功获取到了绝对定位的数值20，20 &#125;)&lt;/script&gt;&lt;div class="father"&gt;&lt;div class="test"&gt;这是一个测试div&lt;/div&gt;&lt;/div&gt;&lt;/body&gt; scrollTop([val])与scrollLeft([val])获取匹配元素相对滚动条顶部的偏移。此方法对可见和隐藏元素均有效。下面以scrollTo()为例：123456789101112131415161718192021222324252627282930313233&lt;style&gt;.test&#123; margin-top: 2000px; outline: 1px solid red; height: 20px; position: absolute; top: 20px; left: 20px;&#125;button&#123; margin-top: 200px;&#125;&lt;/style&gt;&lt;body&gt;&lt;script&gt;$(function()&#123; console.log($('html').scrollTop()+$('body').scrollTop()); // 当拖动滚轮，点击按钮获取数值，数值能够正确显示。 $('button').eq(0).click(function()&#123; alert(($('html').scrollTop()+$('body').scrollTop())); // 兼容处理，保证所有浏览器都能正确获取数值&#125;); $('button').eq(1).click(function()&#123; $('html').scrollTop(300)+$('body').scrollTop(300);&#125;);&#125;)&lt;/script&gt;&lt;div class="father"&gt;&lt;div class="test"&gt;这是一个测试div&lt;/div&gt;&lt;/div&gt;&lt;button&gt;显示scrolltop&lt;/button&gt;&lt;button&gt;设置scrolltop&lt;/button&gt;&lt;/body&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[关于css选择器的一个小小的问题]]></title>
    <url>%2F2019%2F05%2F12%2F%E5%85%B3%E4%BA%8Ecss%E9%80%89%E6%8B%A9%E5%99%A8%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%B0%8F%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[前言 昨天在写一个页面的时候，写到css样式的时候，出现了一个问题,让我有一开始有点想不明白，后面明白了，记录一下。 问题情况： 这是html代码 12345&lt;div class="father"&gt; &lt;ul&gt; &lt;li class="son"&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 这是css代码 123456789101112.father ul li&#123; display:none; /* 此时这个div块中的所有内容都将不显示 */&#125;.son&#123; display:block; /* 起初我认为此时这个li中放的所有内容都应该显示，但是我在li中放的图片并没有显示，我就去查看控制台的样式，发现在这个li中的样式是有block这个属性但是并没有生效。 */&#125;.father ul .son&#123; display:block; /* 后面我尝试着这样写，却发现这下图片就显示出来了 ，随后并猜测是选择器优先级的问题，随即查阅资料，发现组合选择器的优先级为成员选择器的权重相加，只写一个类选择器干不过上面的多个选择器权重相加，所以多组合一些就好了，或者用!important 来拉满。*/&#125; 总结选择器的权重问题。虽然以前看到过选择器优先级相关的知识，但是还没有接触过很多这种情况，以后要注意！]]></content>
  </entry>
  <entry>
    <title><![CDATA[jQuery学习（核心函数）]]></title>
    <url>%2F2019%2F05%2F10%2FjQuery%E5%AD%A6%E4%B9%A0%EF%BC%88%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言 记录了jQuery的核心函数以及jQuery对象，jQuery的静态方法的使用。 jQuery核心函数jQuery核心函数一共3大类4小类 jQuery(callback)当DOM加载完成后执行传入的回调函数 jQuery([sel,[context]])接收一个包含 CSS 选择器的字符串，然后用这个字符串去匹配一组元素,并包装成jQuery对象,也就是jQuery的选择器。 jQuery(html,[ownerDoc])根据 HTML 标记字符串，动态创建DOM 元素 12345678910111213141516&lt;script&gt;$(function()&#123; var $text=$("&lt;p&gt;这是一段文字&lt;/p&gt;"); $("body").append($text);&#125;);&lt;/script&gt;``` ### jQuery对象* jQuery对象的本质是什么? jQuery对象的本质是一个伪数组```html&lt;script&gt; var $div = $('div'); console.log($div); // [object Object]: &#123;0: Object, context: Object, length: 1, prevObject: Object, selector: "div"&#125;&lt;/script&gt; 什么是伪数组?有0到length-1的属性,并且有length属性 jQuery静态方法 什么是静态方法?静态方法对应的是对象方法,对象方法用实例对象调用,而静态方法用类名调用 jQuery.holdReady(hold)暂停或者恢复jQuery.ready()事件传入true或false1234567891011121314151617181920&lt;script&gt; // 使用$直接调用,是静态方法 $.holdReady(true); // 暂停住了 $(function () &#123; $("#first").click(function () &#123; alert("我是你想要的弹窗"); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button id="first"&gt;点击测试弹出&lt;/button&gt;&lt;button id="second"&gt;解除延迟&lt;/button&gt;&lt;script&gt; $("#second").click(function()&#123; $.holdReady(false); // 单击会触发这个，然后恢复 &#125;);&lt;/script&gt; $.each(object,[callback])遍历对象或数组优点统一遍历对象和数组的方式回调参数的顺序更符合我们的思维模式 $.map(arr|obj,callback)遍历对象或数组,将回调函数的返回值组成一个新的数组返回 $.trim(str)去掉字符串起始和结尾的空格。 $.isArray(obj)判断是否是数组 $.isFunction(obj)判断是否是函数 $.isWindow(obj)判断是否是window对象]]></content>
  </entry>
  <entry>
    <title><![CDATA[jQuery学习（入口函数与冲突问题）]]></title>
    <url>%2F2019%2F05%2F10%2FjQuery%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%A5%E5%8F%A3%E5%87%BD%E6%95%B0%E4%B8%8E%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言 jQuery入口函数与原声js入口函数的区别，以及解决冲突问题，还有一些小细节，帮助我学习。 jQuery入口函数 多个window.onload只会执行一次, 后面的会覆盖前面的 多个$(document).ready()会执行多次,后面的不会覆盖前面的 不会覆盖的本质(了解,后面jQuery原理会详细讲解)jQuery框架本质是一个闭包,每次执行我们都会给ready函数传递一个新的函数,不同函数内部的数据不会相互干扰 window.onload $(document).ready() 执行时机 必须等待网页全部加载完毕(包括 图片等),然后再执行包裹代码 只需要等待网页中的DOM结构 加载完毕,就能执行包裹的代码 执行次数 只能执行一次,如果第二次,那么 第一次的执行会被覆盖 可以执行多次,第N次都不会被上 一次覆盖 简写方案 无 $(function () { }); 解决$符号冲突问题 为什么是window.jQuery = window.$ = jQuery;,而不是window.jQuery = jQuery; jQuery框架之所以提供了jQuery访问还提供$访问,就是为了提升开发者的编码效率 $符号冲突怎么办? 很多js的框架都提供了类似jQuery这样的便捷访问方式,所以很有可能某一天我们在使用多个框架的时,多个框架作者提供的便捷访问方式冲突(A框架通过$访问,B框架也通过$访问) ***释放$使用权 当便捷访问符号发生冲突时,我们可以释放$使用权, 释放之后只能使用jQuery]]></content>
  </entry>
  <entry>
    <title><![CDATA[jQuery学习（介绍与使用）]]></title>
    <url>%2F2019%2F05%2F10%2FjQuery%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言 对于前端来说，学习掌握jQuery是基础，则将会是我学习jQuery的记录。jQuery中文文档：http://hemin.cn/jq/。 jQuery是什么？ jQuery是一款优秀的JavaScript库，从命名可以看出jQuery最主要的用途是用来做查询（jQuery=js+Query）. 在jQuery官方Logo下方还有一个副标题（write less, do more）, 体现了jQuery除了查询以外,还能让我们对HTML文档遍历和操作、事件处理、动画以及Ajax变得更加简单 为什么要使用jQuery？ 强大选择器: 方便快速查找DOM元素如上面实例所展示一样，通过jQuery查找DOM元素要比原生js快捷很多jQuery允许开发者使用CSS1-CSS3几乎所有的选择器,以及jQuery独创的选择器 以下是一段jQuery代码：1234567891011121314151617&lt;body&gt; &lt;div class="test1"&gt;这是1&lt;/div&gt; &lt;div&gt;这是0&lt;/div&gt; &lt;div id="test2"&gt;这是2&lt;/div&gt; &lt;script&gt; $(document).ready(function()&#123; $(".test1").css('width','100px').css('height','200px'); $("#test2").css('background','blue'); // 读取数据 var $tx = $("div").eq(0).text(); alert($tx); // 写入数据 $("div").eq(0).text("新的数据"); &#125;); &lt;/script&gt;&lt;/body&gt; 通过以上代码可以看出，jQuery查找元素要快的多，方便的多，并且jQuery可以不断的调用jQuery对象的方法，并且可以一次操作。读取数据也是一个函数，使用比较方便 事件处理 DOM操作(C增U改D删) 样式操作 动画 丰富的插件支持 浏览器兼容(前端开发者痛点) 如何使用jQuery？下载过后这样调用就可以了：1&lt;script src="../jquery-1.12.4.js"&gt;&lt;/script&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[关于classList的使用]]></title>
    <url>%2F2019%2F05%2F10%2F%E5%85%B3%E4%BA%8EclassList%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言 关于classList的学习总结，作为DOMTokenList对象该属性用于在元素中添加、移出、切换css类，使用classList可以实现十分多的功能，十分的有用，以下是我的学习笔记。 语法：elem.classList方法：add( String[,String])：添加指定的类值。如果这些类已经存在于元素的属性中，那么他们将被忽略remove(String[,String])：删除指定的类值item(Number)：按集合中的索引返回类值toggle(String[,force])： 当只有一个参数的时，切换class value ，即如果类存在，删除它，并返回false，如果类不存在，则添加它并返回true。 当存在第二个参数时，如果第二个参数的计算结果为true，则添加指定的类值，如果计算结果为false，则删除它 contains(string)：检查元素的类属性中是否存在指定的类值属性：length：返回类列表中类的数量，该属性是只读的 下面是利用classList实现标签栏切换的一个小例子：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;style&gt; div &#123; width: 500px; margin: 10px; &#125; .db&#123; height: 50px; width: 300px; margin: 0 auto; border: none; &#125; .dh&#123; background: #666; height: 25px; width: 300px; margin: 0 auto; color: white; text-align: center; border: none; &#125; .dhd&#123; margin: 0 0px; width: 100px; float: left; margin-top: 3px; &#125; .dbd&#123; width: 100px; height: 50px; float: left; margin: 0 0px; display: none; width: 300px; &#125; .current&#123; display: block; background: white; color: black; &#125; .ttt&#123; border: 1px solid black; width: 300px; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class="ttt"&gt; &lt;div class='dh'&gt; &lt;div class="dhd current"&gt;标签栏一&lt;/div&gt; &lt;div class="dhd"&gt;标签栏二&lt;/div&gt; &lt;div class="dhd"&gt;标签栏三&lt;/div&gt; &lt;/div&gt; &lt;div class='db'&gt; &lt;div class="dbd current"&gt;这是内容一&lt;/div&gt; &lt;div class="dbd"&gt;这是内容二&lt;/div&gt; &lt;div class="dbd"&gt;这是内容三&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; // 利用classList的方法给当前元素添加样式让其显示，其他元素默认不显示，以达到切换效果 var hs=document.getElementsByClassName('dhd'); var ds=document.getElementsByClassName('dbd'); for(var i=0;i&lt;hs.length;i++)&#123; hs[i].onmouseover=function()&#123; for(var i=0;i&lt;ds.length;i++)&#123; if(hs[i]==this)&#123; ds[i].classList.add('current'); hs[i].classList.add('current'); &#125; else&#123; ds[i].classList.remove('current'); hs[i].classList.remove('current'); &#125; &#125; &#125; &#125; &lt;/script&gt;&lt;/body&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[html中的块级元素与行级元素]]></title>
    <url>%2F2019%2F05%2F10%2Fhtml%E4%B8%AD%E7%9A%84%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E4%B8%8E%E8%A1%8C%E7%BA%A7%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[前言 在最开始的时候没有清除的认识到块级元素与行级元素的差别，也没有想到二者之间有如此大的差别，以及二者之间的关系以下是我对二者的学习总结： 块级元素和行内元素的定义块级元素： 总是在新行上开始； 高度，行高以及外边距和内边距都可控制； 宽度缺省是它的容器的100%，除非设定一个宽度。 它可以容纳内联元素和其他块元素 行内元素？ 和其他元素都在一行上； 高，行高及外边距和内边距不可改变； 宽度就是它的文字或图片的宽度，不可改变 内联元素只能容纳文本或者其他内联元素 对行内元素，需要注意如下： 设置宽度width 无效。 设置高度height 无效，可以通过line-height来设置。 设置margin 只有左右margin有效，上下无效。 设置padding 只有左右padding有效，上下则无效。注意元素范围是增大了，但是对元素周围的内容是没影响的。 可以通过display对二者进行调整display属性表： 值 描述 none 此元素不会被显示。 block 此元素将显示为块级元素，此元素前后会带有换行符。 inline 默认。此元素会被显示为内联元素，元素前后没有换行符。 inline-block 行内块元素。（CSS2.1 新增的值） list-item 此元素会作为列表显示。 run-in 此元素会根据上下文作为块级元素或内联元素显示。 compact CSS 中有值 compact，不过由于缺乏广泛支持，已经从 CSS2.1 中删除。 marker CSS 中有值 marker，不过由于缺乏广泛支持，已经从 CSS2.1 中删除。 table 此元素会作为块级表格来显示（类似 &lt;table&gt;），表格前后带有换行符。 inline-table 此元素会作为内联表格来显示（类似 &lt;table&gt;），表格前后没有换行符。 table-row-group 此元素会作为一个或多个行的分组来显示（类似 &lt;tbody&gt;）。 table-header-group 此元素会作为一个或多个行的分组来显示（类似 &lt;thead&gt;）。 table-footer-group 此元素会作为一个或多个行的分组来显示（类似 &lt;tfoot&gt;）。 table-row 此元素会作为一个表格行显示（类似 &lt;tr&gt;）。 table-column-group 此元素会作为一个或多个列的分组来显示（类似 &lt;colgroup&gt;）。 table-column 此元素会作为一个单元格列显示（类似 &lt;col&gt;） table-cell 此元素会作为一个表格单元格显示（类似 &lt;td&gt; 和 &lt;th&gt;） table-caption 此元素会作为一个表格标题显示（类似 &lt;caption&gt;） inherit 规定应该从父元素继承 display 属性的值。 这是一个小测试：123456789101112131415161718192021222324252627282930&lt;style&gt; div&#123; border: 1px solid blue; margin-bottom: 10px; &#125; span&#123; border: 1px solid red; height: 50px; margin: 40px; /* 可以发现对span这个行内元素设置了height属性但是其并没有生效 设置了margin，但只有左右margin生效，padding同理。 */ &#125; .div3&#123; display: inline; /* 将其设为行内元素，其只拥有行内元素的特性 */ &#125; .div4&#123; display: inline-block; /* 将其设置为行内块级元素，兼具二者特性 */ height: 50px; &#125;&lt;/style&gt;&lt;body&gt;&lt;div&gt;这是第一个div:div是块级元素，默认宽度是100%,可以设置宽度与高度，默认自动占一行&lt;/div&gt;&lt;div&gt;这是第二个div&lt;span&gt;这是一个块级元素:大小只与内容有关，不可以设置宽度与高度，但能设置行高，默认不占一行&lt;/span&gt;&lt;/div&gt;&lt;div"&gt;这是第三个div：通过display:inline将其变为行内元素&lt;/div&gt;&lt;div"&gt;这是第四个div:通过display:inline-block将其变为行内块级元素，兼具二者特性&lt;/div&gt;&lt;/body&gt; 效果图： 以上就是我的学习总结。]]></content>
  </entry>
  <entry>
    <title><![CDATA[一个简单的网页二级菜单]]></title>
    <url>%2F2019%2F05%2F09%2F%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%BD%91%E9%A1%B5%E4%BA%8C%E7%BA%A7%E8%8F%9C%E5%8D%95%2F</url>
    <content type="text"><![CDATA[前言 网页二级菜单十分常见，我学习到了写法，以下是我写的一个简单的demo当作练习，以及原理说明。 CSS代码12345678910111213.menu&#123; list-style: none;&#125;.menu&gt;li&#123; float: left;&#125;li&gt;ul&#123; display: none;&#125;.menu&gt;li:hover&gt;ul&#123; display: block;&#125; 实现二级菜单的主要原理部分还是在css部分，先将所有的二级菜单的内容通过display隐藏，当鼠标经过一级菜单则将二级菜单的内容显示出来。 html代码123456789101112131415161718192021222324252627&lt;body&gt; &lt;ul class="menu"&gt; &lt;li&gt;&lt;a href="#"&gt;菜单一&lt;/a&gt; &lt;ul&gt; &lt;li&gt;测试a1&lt;/li&gt; &lt;li&gt;测试a2&lt;/li&gt; &lt;li&gt;测试a3&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="#"&gt;菜单二&lt;/a&gt; &lt;ul&gt; &lt;li&gt;测试b1&lt;/li&gt; &lt;li&gt;测试b2&lt;/li&gt; &lt;li&gt;测试b3&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="#"&gt;菜单三&lt;/a&gt; &lt;ul&gt; &lt;li&gt;测试c1&lt;/li&gt; &lt;li&gt;测试c2&lt;/li&gt; &lt;li&gt;测试c3&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/body&gt; 效果图&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[css选择器总结]]></title>
    <url>%2F2019%2F05%2F08%2Fcss%E9%80%89%E6%8B%A9%E5%99%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前言 在编写css代码时合理使用选择器有助于提升编写效率以及缩短代码量，所以对常用的选择器熟练使用是十分有必要的，以下为一些选择器的使用总结。 基础的一些选择器标签选择器，以标签名作为选择器名类选择器，通过”.”+类名作为选择器名称如：.testid选择器，通过”#”+类名作为选择器名称如：#test 交集选择器标记选择器+类选择器或id选择器，中间不能有任何的空格如：p.aaa或p#aaa注意：后代选择器作用于所有后代。（与子代选择器的区分） 后代选择器：由两个标记选择器组成，第一个为父级，第二个为子代，中间一定要有空格div p注意：子代选择器作用于所有后代。（与后代选择器的区分） 子代选择器此时选择到的是作为子代的p 子代选择器与后代选择器的区别，子代选择器只作用于后一代儿子，而不会影响到孙子，后代选择器作用于所有后代div&gt;p 并集选择器：由若干个任意选择器组成，由逗号分隔开可以同时对多个目标生效。h1,.aaa,#bbb 属性选择器假设有html代码：1&lt;input name="test" placeholder="初始值" class="test" id="test" type="text" value=""&gt; E[att^=value] E可以省略，满足 属性值 等于valueinput[name^=test]E[att$=value] E可以省略，满足 属性值后缀 等于valueinput[name$=st]E[att*=value] E可以省略，满足 属性值包含 valueinput[name*=es] 兄弟选择器p+h2 选择到的是p后面的 相邻的 h2p~h2 选择到的是p后面的 不一定相邻的 h2 伪类选择器：:root 该选择器对页面所有元素的生效，可以用其他选择器将其覆盖:not 该选择器可以将选定内容排除在大选择器之外（body :not(p)）此时选择器就不会选择到p标记。冒号之前必须有空格 伪元素选择器：:first-letter 向文本的第一个字母添加样式:first-line 向文本的首行添加特殊样式。:before 在元素之前添加内容。:after 在元素之后添加内容。 链接伪类：a:link 未访问时的状态a:visited 访问后的状态a:active 鼠标单击不动时的状态a:hover 悬停时的状态 关于选择器的优先级比较同一级别的个数，数量多的优先级高，如果相同即比较下一级别的个数important &gt; 内联 &gt; ID &gt; 类 &gt; 标签 | 伪类 | 属性选择 &gt; 伪对象 &gt; 通配符 &gt; 继承]]></content>
  </entry>
  <entry>
    <title><![CDATA[markdown基本语法(在hexo中的使用)]]></title>
    <url>%2F2019%2F03%2F11%2Fmarkdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95(%E5%9C%A8hexo%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8)%2F</url>
    <content type="text"><![CDATA[前言 hexo使用markdown来书写博客，所以熟悉了解markdown十分有必要，这是markdown在hexo中的使用,这里介绍markdown的基础以及在hexo中的应用。 一、标题12345# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题 效果： 这是一级标题这是二级标题这是三级标题这是四级标题这是五级标题二、文字1234**这是加粗的文字** //用两个*将文字包起即加粗*这是斜体文字* //用一个*将文字包起即斜体***这是加粗同时斜体的文字*** //用三个*将文字包起即加粗斜体 ~~这是加删除线的文字~~ //要加删除线的文字左右分别用两个~~号包起来 效果： 这是加粗的文字这是斜体文字这是加粗同时斜体的文字这是加删除线的文字 三、引用在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;n个…123&gt;这是引用的内容&gt;&gt;这是引用的内容&gt;&gt;&gt;这是引用的内容 效果： 这是引用的内容 这是引用的内容 这是引用的内容 四、分割线几种样式，效果一样1234-------******** 五、图片图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加还可以用html标记来插入图片：1&lt;img width=200 src=&quot;../images/lm.jpg&quot;/&gt; 并且可以自定义大小但是hexo中使用以上两种方式会导致一些问题，所以在hexo中建议使用以下方法：1&#123;% asset_img example.jpg This is an example image %&#125; 六、超链接1[超链接名](超链接地址 &quot;超链接title&quot;) title可加可不加示例：1[百度](https://www.baidu.com) 百度一样的可以使用html标记来插入超链接： 百度并且可以设置在新窗口打开 七、列表无序：123- 列表内容+ 列表内容* 列表内容 注意：- + * 跟内容之间都要有一个空格 列表内容 列表内容 列表内容 用html标记也可以：12345&lt;ul&gt;&lt;li&gt;列表内容1&lt;/li&gt;&lt;li&gt;列表内容2&lt;/li&gt;&lt;li&gt;列表内容3&lt;/li&gt;&lt;/ul&gt; 有序：数字加点:1231. 列表内容2. 列表内容3. 列表内容 列表内容 列表内容 列表内容 注意：序号跟内容之间要有空格 八、表格1234表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容 表头 表头 表头 内容 内容 内容 内容 内容 内容 第二行分割表头和内容。-有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略同样，可以用html标记实现：12345&lt;table&gt;&lt;tr&gt;&lt;td&gt;表头&lt;/td&gt;&lt;td&gt;表头&lt;/td&gt;&lt;td&gt;表头&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;内容&lt;/td&gt;&lt;td&gt;内容&lt;/td&gt;&lt;td&gt;内容&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;内容&lt;/td&gt;&lt;td&gt;内容&lt;/td&gt;&lt;td&gt;内容&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 表头表头表头内容内容内容内容内容内容 九、代码单行代码：代码之间分别用一个反引号包起来代码内容代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行123代码...在开头的三个反引号后面加上语言名称还可以显示对应高亮代码... 代码高亮 十、流程图由于hexo不支持流程图所以不做演示 十一、在实际使用过程中遇到的一些问题以及解决办法在实际的使用过程中使用markdown在hexo编写文章有时会遇到一些意想不到的问题，这里来进行一个汇总以及解决办法： 在hexo中使用表格的时候在vscode中预览的时候是好好的，可是当打开网页之后却会出现表格上方会出现大量的留白的情况，检查网页代码发现是网页中多了很多的换行符那么解决办法是在表格使用 `` 与 ``包裹起来，然后再回去查看网页，ok，问题解决。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F12%2F02%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
